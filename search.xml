<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[maven]]></title>
    <url>%2FMeBlog%2F2019%2F06%2F10%2Fmaven%2F</url>
    <content type="text"><![CDATA[maven介绍什么是mavenMaven 的正确发音是[ˈmevən],而不是“马瘟”以及其他什么瘟。Maven 在美国是一个口语化的词 语,代表专家、内行的意思。 maven 是一个项目管理工具,它包含了一个项目对象模型（pom:project object model）一组标准集合,一个项目生命周期（project Lifecycle）,一个依赖管理系统（dependency management system）和用来运行定义在生命周期阶段中插件目标的逻辑 maven 能做什么1.引入jar包，可控制jar包冲突问题 2.编译（java文件编译为字节码） 3.运行测试用例 4.打包 maven 的特点依赖管理根据pom中的坐标将jar包导入项目中，可以做到jar包的复用。 如将一个junit导入项目使用maven则体现为 123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 依赖传递下面从字面依赖和传递两个方面了解依赖传递的概念 依赖：项目A中引入了项目B,这时我们就可以说A依赖于B 传递：项目B中依赖了项目C由于A依赖于B,所以根据依赖的关系A也就依赖了项目C maven的依赖传递可以方便引入一些项目，但是存在一个问题就是如果一个项目同时依赖2个项目。而依赖的2个项目分别又依赖同一个项目的不同版本。这里由于版本的不同可能会引发一些兼容性问题。我们把这种情况称之为依赖传递冲突。 maven对这种冲突提供的解决方案如下： 依赖调节原则： 1、第一声明者优先原则：在 pom 文件定义依赖,先声明的依赖为准。2、路径近者优先原则:例如:A项目依赖B B依赖C C又依赖D 如果我们在A中申明依赖D的不同版本，那么A项目就会依赖D的声明版本而不是传递的D版本。 只要我们遵循原则maven会帮我们自动处理依赖 ，但我们如果不想遵循原则就不能解决冲突了吗？答案肯定是可以，毕竟maven是一款优秀的自动化构建工具 不遵循原则如何解决冲突： 1.排除依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;com.itcast.ssm&lt;/groupId&gt; &lt;artifactId&gt;ssm_service&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;XXX&lt;/groupId&gt; &lt;artifactId&gt;XXX&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 2.锁定版本12345678910 &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 3.可选依赖当坐标被赋予1&lt;optional&gt;true&lt;/optional&gt; 时此坐标不会被传递依赖。 example：1234567891011 &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 一键构建maven 规范化流程如下图 一键构建是指，如果用户需要实现上述流程中的清理，只需要使用maven自带的mvn clean命令即可完成项目的清空。 如果是实现流程中的打包，则使用命令mvn package 即可，并且它还会执行打包前的所有流程项。 maven 安装后目录解析bin:存放了 maven 的命令,比如我们前面用到的 mvn tomcat:runboot:存放了一些 maven 本身的引导程序,如类加载器等conf:存放了 maven 的一些配置文件,如 setting.xml 文件lib:存放了 maven 本身运行所需的一些 jar 包在使用maven前电脑需安装jdk或jre因为maven是用java编写的 maven 命令查看maven的帮助信息1spiderbao@spiderbao-CW65S:~$ mvn -help maven 查看版本信息1234567spiderbao@spiderbao-CW65S:~$ mvn -vApache Maven 3.6.0Maven home: xxxJava version: 1.8.0_191, vendor: Oracle Corporation, runtime: xxxjava-8-openjdk-amd64/jreDefault locale: zh_CN, platform encoding: UTF-8OS name: &quot;linux&quot;, version: &quot;4.18.0-18-generic&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot; compile 编译12345678910111213141516171819spiderbao@spiderbao-CW65S:~/idea_dev/hello_maven$ mvn complie[INFO] Scanning for projects...[INFO] [INFO] ----------------------&lt; com.itheima:hello_maven &gt;-----------------------[INFO] Building hello_maven Maven Webapp 1.0-SNAPSHOT[INFO] --------------------------------[ war ]---------------------------------[INFO] ------------------------------------------------------------------------[INFO] BUILD FAILURE[INFO] ------------------------------------------------------------------------[INFO] Total time: 0.145 s[INFO] Finished at: 2019-05-08T14:24:23+08:00[INFO] ------------------------------------------------------------------------[ERROR] Unknown lifecycle phase &quot;complie&quot;. You must specify a valid lifecycle phase or a goal in the format &lt;plugin-prefix&gt;:&lt;goal&gt; or &lt;plugin-group-id&gt;:&lt;plugin-artifact-id&gt;[:&lt;plugin-version&gt;]:&lt;goal&gt;. Available lifecycle phases are: validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy, pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy. -&gt; [Help 1][ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.[ERROR] Re-run Maven using the -X switch to enable full debug logging.[ERROR] [ERROR] For more information about the errors and possible solutions, please read the following articles:[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/LifecyclePhaseNotFoundException mvn complie 打错 改为 compile1234567891011121314151617181920spiderbao@spiderbao-CW65S:~/idea_dev/hello_maven$ mvn compile[INFO] Scanning for projects...[INFO] [INFO] ----------------------&lt; com.itheima:hello_maven &gt;-----------------------[INFO] Building hello_maven Maven Webapp 1.0-SNAPSHOT[INFO] --------------------------------[ war ]---------------------------------[INFO] [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ hello_maven ---[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.[INFO] skip non existing resourceDirectory /home/spiderbao/idea_dev/hello_maven/src/main/resources[INFO] [INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ hello_maven ---[INFO] Changes detected - recompiling the module![INFO] Compiling 1 source file to /home/spiderbao/idea_dev/hello_maven/target/classes[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 1.307 s[INFO] Finished at: 2019-05-08T14:26:40+08:00[INFO] ------------------------------------------------------------------------ test 测试1234567891011121314151617181920212223242526272829spiderbao@spiderbao-CW65S:~/idea_dev/hello_maven$ mvn test[INFO] Scanning for projects...[INFO] [INFO] ----------------------&lt; com.itheima:hello_maven &gt;-----------------------[INFO] Building hello_maven Maven Webapp 1.0-SNAPSHOT[INFO] --------------------------------[ war ]---------------------------------[INFO] [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ hello_maven ---[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.[INFO] skip non existing resourceDirectory /home/spiderbao/idea_dev/hello_maven/src/main/resources[INFO] [INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ hello_maven ---[INFO] Nothing to compile - all classes are up to date[INFO] [INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ hello_maven ---[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.[INFO] skip non existing resourceDirectory /home/spiderbao/idea_dev/hello_maven/src/test/resources[INFO] [INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ hello_maven ---[INFO] No sources to compile[INFO] [INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ hello_maven ---[INFO] No tests to run.[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 1.072 s[INFO] Finished at: 2019-05-08T14:27:10+08:00[INFO] ------------------------------------------------------------------------ 由于没有写测试用例所以No tests to run.clean 清空1234567891011121314spiderbao@spiderbao-CW65S:~/idea_dev/hello_maven$ mvn clean[INFO] Scanning for projects...[INFO] [INFO] ----------------------&lt; com.itheima:hello_maven &gt;-----------------------[INFO] Building hello_maven Maven Webapp 1.0-SNAPSHOT[INFO] --------------------------------[ war ]---------------------------------[INFO] [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ hello_maven ---[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 0.289 s[INFO] Finished at: 2019-05-08T14:23:21+08:00[INFO] ------------------------------------------------------------------------ package 打包12345678910111213141516171819202122232425262728293031323334353637spiderbao@spiderbao-CW65S:~/idea_dev/hello_maven$ mvn package[INFO] Scanning for projects...[INFO] [INFO] ----------------------&lt; com.itheima:hello_maven &gt;-----------------------[INFO] Building hello_maven Maven Webapp 1.0-SNAPSHOT[INFO] --------------------------------[ war ]---------------------------------[INFO] [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ hello_maven ---[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.[INFO] skip non existing resourceDirectory /home/spiderbao/idea_dev/hello_maven/src/main/resources[INFO] [INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ hello_maven ---[INFO] Nothing to compile - all classes are up to date[INFO] [INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ hello_maven ---[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.[INFO] skip non existing resourceDirectory /home/spiderbao/idea_dev/hello_maven/src/test/resources[INFO] [INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ hello_maven ---[INFO] No sources to compile[INFO] [INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ hello_maven ---[INFO] No tests to run.[INFO] [INFO] --- maven-war-plugin:2.2:war (default-war) @ hello_maven ---[INFO] Packaging webapp[INFO] Assembling webapp [hello_maven] in [/home/spiderbao/idea_dev/hello_maven/target/hello_maven][INFO] Processing war project[INFO] Copying webapp resources [/home/spiderbao/idea_dev/hello_maven/src/main/webapp][INFO] Webapp assembled in [22 msecs][INFO] Building war: /home/spiderbao/idea_dev/hello_maven/target/hello_maven.war[INFO] WEB-INF/web.xml already added, skipping[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 1.515 s[INFO] Finished at: 2019-05-08T14:28:25+08:00 install 安装123456789101112131415161718192021222324252627282930313233343536373839404142spiderbao@spiderbao-CW65S:~/idea_dev/hello_maven$ mvn install[INFO] Scanning for projects...[INFO] [INFO] ----------------------&lt; com.itheima:hello_maven &gt;-----------------------[INFO] Building hello_maven Maven Webapp 1.0-SNAPSHOT[INFO] --------------------------------[ war ]---------------------------------[INFO] [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ hello_maven ---[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.[INFO] skip non existing resourceDirectory /home/spiderbao/idea_dev/hello_maven/src/main/resources[INFO] [INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ hello_maven ---[INFO] Nothing to compile - all classes are up to date[INFO] [INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ hello_maven ---[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.[INFO] skip non existing resourceDirectory /home/spiderbao/idea_dev/hello_maven/src/test/resources[INFO] [INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ hello_maven ---[INFO] No sources to compile[INFO] [INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ hello_maven ---[INFO] No tests to run.[INFO] [INFO] --- maven-war-plugin:2.2:war (default-war) @ hello_maven ---[INFO] Packaging webapp[INFO] Assembling webapp [hello_maven] in [/home/spiderbao/idea_dev/hello_maven/target/hello_maven][INFO] Processing war project[INFO] Copying webapp resources [/home/spiderbao/idea_dev/hello_maven/src/main/webapp][INFO] Webapp assembled in [23 msecs][INFO] Building war: /home/spiderbao/idea_dev/hello_maven/target/hello_maven.war[INFO] WEB-INF/web.xml already added, skipping[INFO] [INFO] --- maven-install-plugin:2.4:install (default-install) @ hello_maven ---[INFO] Installing /home/spiderbao/idea_dev/hello_maven/target/hello_maven.war to /home/spiderbao/.m2/repository/com/itheima/hello_maven/1.0-SNAPSHOT/hello_maven-1.0-SNAPSHOT.war[INFO] Installing /home/spiderbao/idea_dev/hello_maven/pom.xml to /home/spiderbao/.m2/repository/com/itheima/hello_maven/1.0-SNAPSHOT/hello_maven-1.0-SNAPSHOT.pom[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 1.604 s[INFO] Finished at: 2019-05-08T14:42:26+08:00[INFO] ------------------------------------------------------------------------ maven 库maven库可以分为3类分别是： 本地仓库本地仓库 :用来存储从远程仓库或中央仓库下载的插件和 jar 包,项目使用一些插件或 jar 包, 优先从本地仓库查找 远程仓库远程仓库:如果本地需要插件或者 jar 包,本地仓库没有,默认去远程仓库下载。 远程仓库可以在互联网内也可以在局域网内。 中央仓库中央仓库 :在 maven 软件中内置一个远程仓库地址 http://repo1.maven.org/maven2 ,它是中 央仓库,服务于整个互联网,它是由 Maven 团队自己维护,里面存储了非常全的 jar 包,它包含了世界上大部分流行的开源项目构件。 settingsetting 文件主要用来配置maven的一些仓库设置，如本地仓库，远程仓库等。 全局setting 和用户 setting在 maven 安装目录下的有 conf/setting.xml 文件,此 setting.xml 文件用于 maven 的所有 project项目,它作为 maven 的全局配置。如需要个性配置则需要在用户配置中设置,用户配置的 setting.xml 文件默认的位置在: ${user.dir}/.m2/settings.xml 目录中,${user.dir} 指 windows 中的用户目录。或在项目中添加setting.xmlmaven 会先找用户配置,如果找到则以用户配置文件为准,否则使用全局配置文件。 maven 工程认识maven 工程的目录结构如下图 作为一个 maven 工程,它的 src 目录和 pom.xml 是必备的。进入 src 目录后,我们发现它里面的目录结构如下: src/main/java —— 存放项目的.java 文件src/main/resources —— 存放项目资源文件,如 spring, hibernate 配置文件src/test/java —— 存放所有单元测试.java 文件,如 JUnit 测试类src/test/resources —— 测试资源文件target —— 项目输出位置,编译后的 class 文件会输出到此目录pom.xml——maven 项目核心配置文件注意:如果是普通的 java 项目,那么就没有 webapp 目录。 maven 指令的生命周期maven 对项目构建过程分为三套相互独立的生命周期,请注意这里说的是“三套”,而且“相互独立”,这三套生命周期分别是: Clean Lifecycle 在进行真正的构建之前进行一些清理工作。Default Lifecycle 构建的核心部分,编译,测试,打包,部署等等。Site Lifecycle 生成项目报告,站点,发布站点 maven 概念模型Maven 包含了一个项目对象模型 (Project Object Model),一组标准集合,一个项目生命周期(ProjectLifecycle),一个依赖管理系统(Dependency Management System),和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。 项目对象模型 (Project Object Model)一个 maven 工程都有一个 pom.xml 文件,通过 pom.xml 文件定义项目的坐标、项目依赖、项目信息、插件目标等。 依赖管理系统(Dependency Management System)通过 maven 的依赖管理对项目所依赖的 jar 包进行统一管理。比如:项目依赖 junit4.9,通过在 pom.xml 中定义 junit4.9 的依赖即使用 junit4.9,如下所示是 junit4.9的依赖定义: 12345678910111213&lt;!-- 依赖关系 --&gt;&lt;dependencies&gt; &lt;!-- 此项目运行使用 junit,所以此项目依赖 junit --&gt; &lt;dependency&gt; &lt;!-- junit 的项目名称 --&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;!-- junit 的模块名称 --&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!-- junit 版本 --&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;!-- 依赖范围:单元测试时使用 junit --&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 一个项目生命周期(Project Lifecycle)使用 maven 完成项目的构建,项目构建包括:清理、编译、测试、部署等过程,maven 将这些过程规范为一个生命周期,如下所示是生命周期的各各阶段:maven 通过执行一些简单命令即可实现上边生命周期的各各过程,比如执行 mvn compile 执行编译、执行 mvn clean 执行清理。 一组标准集合maven 将整个项目管理过程定义一组标准,比如:通过 maven 构建工程有标准的目录结构,有标准的生命周期阶段、依赖管理有标准的坐标定义等。 插件(plugin)目标(goal)maven 管理项目生命周期过程都是基于插件完成的 maven的继承和聚合maven的继承 继承后maven的子模块会拥有父模块的所有pom信息12345&lt;parent&gt; &lt;artifactId&gt;ssm_parent&lt;/artifactId&gt; &lt;groupId&gt;com.itcast.ssm&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; maven的聚合 我把maven的聚合看做，一个pom件就可以构建指定模块并组合成为一个项目 maven 坐标的来源方式坐标搜索网站central or mvnrepository maven 私服搭建及其使用maven私服搭建下载nexus安装包123 $ cd /opt $ wget http://download.sonatype.com/nexus/oss/nexus-2.10.0-02-bundle.tar.gz 解压并安装1234567 $ cd /opt/ $ tar -zxvf nexus-2.10.0-02-bundle.tar.gz $ cd /opt/nexus-2.10.0-02/bin $ vim nexus 在 nexus文件中添加RUN_AS_USER用户如下1RUN_AS_USER=root 启动nexus1 $ ./nexus start nexus 配置解析： 查看 nexus 的配置文件 conf/nexus.properties 1234567891011# Jetty sectionapplication-port=8081 # nexus 的访问端口配置application-host=0.0.0.0 # nexus 主机监听配置(不用修改)nexus-webapp=$&#123;bundleBasedir&#125;/nexusnexus-webapp-context-path=/nexus# nexus 工程目录# nexus 的 web 访问路径# Nexus sectionnexus-work=$&#123;bundleBasedir&#125;/../sonatype-work/nexus# nexus 仓库目录runtime=$&#123;bundleBasedir&#125;/nexus/WEB-INF # nexus 运行程序目录 nexus仓库类型nexus 的仓库有 4 种类型: 1.hosted,宿主仓库,部署自己的 jar 到这个类型的仓库,包括 releases 和 snapshot 两部分,Releases 公司内部发布版本仓库、 Snapshots 公司内部测试版本仓库 2.proxy,代理仓库,用于代理远程的公共仓库,如 maven 中央仓库,用户连接私服,私服自动去中央仓库下载 jar 包或者插件。 3.group,仓库组,用来合并多个 hosted/proxy 仓库,通常我们配置自己的 maven 连接仓库组。 4.virtual(虚拟):兼容 Maven1 版本的 jar 或者插件 nexus 仓库默认在 sonatype-work 目录中 将项目发布到私服1.setting配置添加 server 12345678910&lt;server&gt; &lt;id&gt;releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt;&lt;server&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt; 2.项目pom添加仓库12345678910&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;releases&lt;/id&gt; &lt;url&gt;http://localhost:8081/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;url&gt;http://localhost:8081/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt; 3.使用maven命令发布 1mvn deploy maven 配置私服下载jar包没有配置nexus之前,如果本地仓库没有,去中央仓库下载,通常在企业中会在局域网内部署一台私服服务器,有了私服本地项目首先去本地仓库找 jar,如果没有找到则连接私服从私服下载 jar 包,如果私服没有 jar 包私服同时作为代理服务器从中央仓库下载 jar 包,这样做的好处是一方面由私服对公司项目的依赖 jar 包统一管理,一方面提高下载速度,项目连接私服下载 jar 包的速度要比项目连接中央仓库的速度快的多。 setting配置 12345678910111213141516171819202122&lt;profile&gt; &lt;!--仓库id--&gt; &lt;id&gt;dev&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;!--仓库 id,repositories 可以配置多个仓库,保证 id 不重复--&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;!--仓库地址,即 nexus 仓库组的地址--&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;/profile&gt;&lt;activeProfiles&gt; &lt;activeProfile&gt;dev&lt;/activeProfile&gt;&lt;/activeProfiles&gt; 将第三方jar导入本地maven12mvn install:install-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37-Dfile= fastjson-1.1.37.jar -Dpackaging=jar 参数说明DgroupId 和 DartifactId 构成了该 jar 包在 pom.xml 的坐标,项目就是依靠这两个属性定位。自己起名字也行。Dfile 表示需要上传的 jar 包的绝对路径。Durl 私服上仓库的位置,打开 nexus——&gt;repositories 菜单,可以看到该路径。DrepositoryId 服务器的表示 id,在 nexus 的 configuration 可以看到。Dversion 表示版本信息 将第三方jar导入私服1.在setting中配置第三方server12345&lt;server&gt; &lt;id&gt;thirdparty&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt; 1234mvn deploy:deploy-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37-Dpackaging=jar -Dfile=fastjson-1.1.37.jar-Durl=http://localhost:8081/nexus/content/repositories/thirdparty/-DrepositoryId=thirdparty 参数说明DgroupId 和 DartifactId 构成了该 jar 包在 pom.xml 的坐标,项目就是依靠这两个属性定位。自己起名字也行。Dfile 表示需要上传的 jar 包的绝对路径。Durl 私服上仓库的位置,打开 nexus——&gt;repositories 菜单,可以看到该路径。DrepositoryId 服务器的表示 id,在 nexus 的 configuration 可以看到。Dversion 表示版本信息]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux-命令篇]]></title>
    <url>%2FMeBlog%2F2019%2F06%2F10%2FLinux-%E5%91%BD%E4%BB%A4%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Linux 常用命令命令格式 目录处理命令 使用 -a 时会看到有的文件名前有.此时表示此文件为隐藏文件。 使用-l 查看详细信息 上面1表示此文件的链接计数 上面的root 表示文件的所有者，也就是文件的创建人或负责人，一个文件只能有一个所有者 上面表示文件的所属组，一个文件只能拥有一个所有组 在-l 后追加h -lh 表示人性化显示，使文件的大小更直观、 ls -i 可以获取文件的I节点或获取文件的id号 cd - 回到上次操作的目录 cd ~ 回到当前用户的根目录 cd 回到当前用户的根目录 tree 命令以目录树的方式显示文件结构信息 使用tree 时可能会遇到command not found ,这时就需要安装此命令 本人使用的是centos 7 的系统 发现使用yum 无法获取tree的安装包 所以只能使用源码包安装，于是在ftp://mama.indstate.edu/linux/tree/ 下载了 源码包 在/usr/local/src 下使用make 编译了源码包 文件处理命令 cat 适用于查看简短文件内容，如shell脚本 less 进入后使用 /关键字 可进行反白关键字高亮显示，同时按N键可以跳到下一个关键字，在高亮的关键字后加入！可以取消高亮效果 硬链接的生成命令 1ln /tmp/china/changzhi /root/china.hard 硬链接 共享文件的inode ,但是文件夹不能创建硬链接。 权限管理命令权限分为了三类 r w s 读 写 执行 其他权限管理命令 文件搜索命令find -name 加通配符可实现模糊搜索文件 通配符 * 表示多个字符 通配符 ？表示单个字符 其他搜索命令 此查询基于文件资料库所以，查询时对比find占用系统资源较少。 存在缺陷无法查询tmp目录下的文件 不能实时查询，如果刚创建的数据没有录入文件资料库时。会导致无法查询到文件。此时使用命令 1updatedb 然后再次使用 locate可查找到文件 帮助命令 帮助命令类型 1表示命令，5表示配置文件 命令名称：whatis NAME whatis - 在 whatis 数据库里查找完整的单词 总览 (SYNOPSIS) whatis keyword … 描述 (DESCRIPTION) whatis 命令在一些特定的包含系统命令的简短描述的数据库文件里查找关键字， 然后把 结果送到标准输出。 查找的内容必须完全匹配关键字的才会输出。 whatis 数据库文件是用 /usr/sbin/makewhatis 命令建立的。 参见 (SEE ALSO) apropos(1), man(1). [中文版维护人] 唐友 &#x74;&#x6f;&#x6e;&#x79;&#95;&#116;&#121;&#x40;&#x32;&#x36;&#x33;&#x2e;&#x6e;&#101;&#116; [中文版最新更新] 2001/9/8 [中国Linux论坛man手册页翻译计划] http://cmpp.linuxforum.net 命令名称：apropos NAME apropos - 在 whatis 数据库中查找字符串 总览 (SYNOPSIS) apropos keyword … 描述 (DESCRIPTION) apropos 命令在一些特定的包含系统命令的简短描述的数据库文件里查找关键字， 然后把 结果送到标准输出。 参见 (SEE ALSO) whatis(1), man(1). [中文版维护人] 唐友 &#116;&#111;&#x6e;&#x79;&#95;&#116;&#121;&#x40;&#50;&#54;&#51;&#46;&#110;&#101;&#x74; [中文版最新更新] 2001/9/20 [中国Linux论坛man手册页翻译计划] http://cmpp.linuxforum.net 用户管理命令 压缩和解压命令压缩格式gz zip rar 其中 zip 是windos和Linux 都支持的压缩格式 压缩解压命令使用 gzip的缺陷就是目前只能压缩文件，并且压缩后是不保留源文件的。 tar 格式表示打包 unzip 解压文件时出现乱码如何解决，使用命令 unzip -O CP936 压缩包名称 即可。其中-O表示知道文件的编码集，CP936是IBM code page 中的第936页也就是咋们俗称的GBK。 rar 格式的文件解压或压缩12345#安装rar shell脚本 sudo apt install rarrar x 文件名进行解压更多信息使用 man rar 网络命令 mail 命令操作时需要使用CTRL+D 才可生效，如执邮件的删除功能，需要除了使用delete命令后还需使用 CTRL+D才可。 mail 进入使用界面后， h表示查看列表，d表示删除指定的邮件 挂载命令 开关机命令 修改系统默认运行级别代码 1init 2 查看系统存储信息1/proc/meminfo 工具版本切换java jdk版本切换1jdk 版本切换：sudo update-alternatives --config java]]></content>
  </entry>
  <entry>
    <title><![CDATA[mongodb]]></title>
    <url>%2FMeBlog%2F2019%2F06%2F10%2Fmongodb%2F</url>
    <content type="text"><![CDATA[mongodb入门简介mongodb是一个基于分布式文件存储的数据库。由c++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。 mongoab是一个介于关系型数据库和非关系型数据库之间的产品，是非关系型数据库当中功能丰富，最像关系型数据库的一个产品。它支持的数据格式有json,bson等。他最大的特点是它的查询语法类似于面向对象语言。并且它还支持对数据创建索引。 下面的图片是百度百科对mongodb的介绍 基础概念在mongodb中是通过数据库、集合、文档的方式来管理数据的。下边是mongodb与关系型数据库的一些概念比较图。和关系型数据库一样，mongodb允许一个实例创建多个数据库，一个数据库创建多个集合，一个集合创建多个文档 链接mongodbmongodb使用CS架构开发。client shell使用链接命令如下：1mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]] 数据库操作的相关命令查询数据库show dbs: 查询所有数据库信息 db 创建数据库use 库名使用指定的库，没有则创建（注意：当使用一个新建的库，而且没有插入任何数据时。此时的库实际没有被创建。） 删除数据库db.dropDatabase 集合相关操作命令创建集合db.createConllection(name,options)name:表示集合的名称options:表示创建参数 删除集合db..drop() 表示选中的集合 文档先关操作集合中插入文档db..insert(document) 表示选中的集合document:表示文档，可以是json类型的数据格式 集合中修改指定文档信息db..update(,,) 表示选中的集合 表示 查询条件,相当于sql语句的where 表示 更新文档内容 表示 选项 $set修改器db.test_collection.update({“age”:18},{$set:{“name”:”wan”,”age”:16}},{multi:true}) test_collection：集合名称 {“age”:18} ：查询结果 {$set:{“name”:”wan”,”age”:16}} 修改条件 {multi:true}：参数 multi 为true时表示修改全部，false时表示修改第一个匹配的文档。默认为false 集合中移除指定文档db..remove() 表示选中的集合 表示查询的结果删除前最好先执行查询 集合中搜索指定文档db..find(query,projection) 表示选中的集合query :查询条件projection:投影查询key 投影查询db.test_collection.find({“age”:18},{name:1,age:1,address:1,_id:0})test_collection:制定的集合{“age”:18} ：查询条件{name:1,age:1,address:1,_id:0} ：投影参数，个人不明白只有_id可以设置为0，如果别的设置为0会报Projection cannot have a mix of inclusion and exclusion.异常 用户相关操作命令添加用户1234567db.createUser(&#123; user:&quot;spiderBao&quot;, pwd:&quot;xxx&quot;, roles:[ &#123;role:&quot;root&quot;,db:&quot;admin&quot;&#125; ] &#125;) 修改用户12345db.updateUser( &apos;spiderBao1&apos;,&#123; roles:[ &#123;role:&quot;readWriteAnyDatabase&quot;,db:&quot;admin&quot;&#125;] &#125;) 查询用户1show users 删除用户1db.dropUser(&quot;spiderBao1&quot;) 修改密码1db.changeUserPassword(&quot;test1&quot;,&quot;123&quot;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java—日志框架解析-转载]]></title>
    <url>%2FMeBlog%2F2019%2F06%2F10%2FJava%E2%80%94%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90-%E8%BD%AC%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[导语作为Java程序员，幸运的是，Java 拥有功能和性能都非常强大的日志库；不幸的是，这样的日志库有不止一个相信每个人都曾经迷失在JUL(Java Util Log), JCL(Commons Logging), Log4j, SLF4J, Logback，Log4j2等等的迷宫中。在我见过的绝大多数项目中，都没有能够良好的配置和使用日志库。这篇文章先讲述Java常见日志库的历史和关系，后续会讲日志使用的最佳实践。让我们从头(Java Util Log)开始说起吧。 Java Util Log简称JUL，是JDK 中自带的log功能。虽然是官方自带的log lib，JUL的使用确不广泛。主要原因: 1.JUL从JDK1.4 才开始加入(2002年)，当时各种第三方log lib已经被广泛使用了2.JUL早期存在性能问题，到JDK1.5上才有了不错的进步，但现在和Logback/Log4j2相比还是有所不如3.JUL的功能不如Logback/Log4j2等完善，比如Output Handler就没有Logback/Log4j2的丰富，有时候需要自己来继承定制，又比如默认没有从ClassPath里加载配置文件的功能 Log4j 1.xLog4j 是在 Logback 出现之前被广泛使用的 Log Lib, 由 Gülcü 于2001年发布，后来成为Apache基金会的顶级项目。Log4j 在设计上非常优秀，对后续的 Java Log 框架有长久而深远的影响，也产生了Log4c, Log4s, Log4perl 等到其他语言的移植。Log4j 的短板在于性能，在Logback 和 Log4j2出来之后，Log4j的使用也减少了。 Commons Logging简称JCL，是Apache下面的项目。JCL 是一个Log Facade，只提供 Log API，不提供实现，然后有 Adapter来使用 Log4j 或者 JUL 作为Log Implementation。 就像之前所说，JDK现在带了自己的JUL，然后又有第三方的Log4j等日志库存在，不同的项目可能各自使用了不同的日志库。如果你的项目依赖的其他lib各自使用了不同的日志库，你想控制日志行为，就需要针对每个日志库都写一个配置文件，是不是很酸爽? 然后这个时候 JCL 就出现了。在程序中日志创建和记录都是用JCL中的接口，在真正运行时，会看当前ClassPath中有什么实现，如果有Log4j 就是用 Log4j, 如果啥都没有就是用 JDK 的 JUL。 这样，在你的项目中，还有第三方的项目中，大家记录日志都使用 JCL 的接口，然后最终运行程序时，可以按照自己的需求(或者喜好)来选择使用合适的Log Implementation。如果用Log4j, 就添加 Log4j 的jar包进去，然后写一个 Log4j 的配置文件；如果喜欢用JUL，就只需要写个JUL的配置文件。如果有其他的新的日志库出现，也只需要它提供一个Adapter，运行的时候把这个日志库的 jar 包加进去。 到这个时候一切看起来都很简单，很美好。接口和实现做了良好的分离，在统一的JCL之下，不改变任何代码，就可以通过配置就换用功能更强大，或者性能更好的日志库实现。 这种简单美好一直持续到SLF4J出现。 SLF4J/LogbackSLF4J(The Simple Logging Facade for Java)和Logback也是Gülcü创立的项目，其创立主要是为了提供更高性能的实现。其中，SLF4j 是类似于JCL 的Log Facade,Logback 是类似于Log4j 的 Log Implementation。 之前已经说过，Apache 有了个JCL，用来做各种Log lib统一的接口，如果 Gülcü 要搞一个更好的Log实现的话，直接写一个实现就好了，为啥还要搞一个和SLF4J呢? 原因是Gülcü 认为 JCL 的 API 设计得不好，容易让使用者写出性能有问题的代码。 比如在用 JCL 输出一个 debug 级别的 log: 1logger.debug("start process request, url:" + url); 这个有什么问题呢？一般生产环境 log 级别都会设到 info 或者以上，那这条 log 是不会被输出的。然而不管会不会输出，这其中都会做一个字符串连接操作，然后生产一个新的字符串。如果这条语句在循环或者被调用很多次的函数中，就会多做很多无用的字符串连接，影响性能。 所以 JCL 的最佳实践推荐这么写： 123if (logger.isDebugEnabled()) &#123; logger.debug("start process request, url:" + url);&#125; 然而开发者常常忽略这个问题或是觉得麻烦而不愿意这么写。所以SLF4J提供了新的API，方便开发者使用: 1logger.debug("start process request, url:&#123;&#125;", url); 这样的话，在不输出 log 的时候避免了字符串拼接的开销；在输出的时候需要做一个字符串format，代价比手工拼接字符串大一些,但是可以接受。 而 Logback 则是作为 Log4j 的继承者来开发的，提供了性能更好的实现，异步 logger，Filter等更多的特性。 现在事情变复杂了。我们有了两个流行的 Log Facade，以及三个流行的 Log Implementation。Gülcü是个追求完美的人，他决定让这些Log之间都能够方便的互相替换，所以做了各种 Adapter 和 Bridge 来连接: 可以看到甚至 Log4j 和 JUL 都可以桥接到SLF4J，再通过 SLF4J 适配到到 Logback! 在这里需要注意不能搞出循环的桥接，比如下面这些依赖就不能同时存在: 1.jcl-over-slf4j 和 slf4j-jcl2.log4j-over-slf4j 和 slf4j-log4j123.jul-to-slf4j 和 slf4j-jdk14 总感觉事情在变得更麻烦呢！ Log4j2现在有了更好的 SLF4J 和 Logback——你会想事情到这里总该了解了吧，让他们慢慢取代JCL 和 Log4j 好了。 然而维护 Log4j 的人不这样想，他们不想坐视用户一点点被 SLF4J /Logback 蚕食，继而搞出了 Log4j2。 Log4j2 和 Log4j1.x 并不兼容，设计上很大程度上模仿了 SLF4J/Logback，性能上也获得了很大的提升。 Log4j2 也做了 Facade/Implementation 分离的设计，分成了 log4j-api 和 log4j-core。 现在好了，我们有了三个流行的Log 接口和四个流行的Log实现，如果画出桥接关系的图来回事什么样子呢? 是不是感觉有点晕呢？同样，在添加依赖的时候，要小心不要搞成循环依赖。对于如今的局面我的日志使用方案是 个人推荐日志搭配方案1. 总是使用Log Facade，而不是具体Log Implementation正如之前所说的，使用 Log Facade 可以方便的切换具体的日志实现。而且，如果依赖多个项目，使用了不同的Log Facade，还可以方便的通过 Adapter 转接到同一个实现上。如果依赖项目使用了多个不同的日志实现，就麻烦的多了。 具体来说，现在推荐使用 Log4j-API 或者 SLF4j，不推荐继续使用 JCL。 2. 只添加一个 Log Implementation依赖毫无疑问，项目中应该只使用一个具体的 Log Implementation，建议使用 Logback 或者Log4j2。如果有依赖的项目中，使用的 Log Facade不支持直接使用当前的 Log Implementation，就添加合适的桥接器依赖。具体的桥接关系可以看上一篇文章的图。 3. 具体的日志实现依赖应该设置为optional和使用runtime scope在项目中，Log Implementation的依赖强烈建议设置为runtime scope，并且设置为optional。例如项目中使用了 SLF4J作为 Log Facade，然后想使用 Log4j2 作为 Implementation，那么使用 maven 添加依赖的时候这样设置: 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 设为optional，依赖不会传递，这样如果你是个lib项目，然后别的项目使用了你这个lib，不会被引入不想要的LogImplementation 依赖； Scope设置为runtime，是为了防止开发人员在项目中直接使用Log Implementation中的类，而不适用Log Facade中的类。 4. 如果有必要, 排除依赖的第三方库中的Log Impementation依赖这是很常见的一个问题，第三方库的开发者未必会把具体的日志实现或者桥接器的依赖设置为optional，然后你的项目继承了这些依赖——具体的日志实现未必是你想使用的，比如他依赖了Log4j，你想使用Logback，这时就很尴尬。另外，如果不同的第三方依赖使用了不同的桥接器和Log实现，也极容易形成环。 这种情况下，推荐的处理方法，是使用exclude来排除所有的这些Log实现和桥接器的依赖，只保留第三方库里面对Log Facade的依赖。 比如阿里的JStorm就没有很好的处理这个问题，依赖jstorm会引入对Logback和log4j-over-slf4j的依赖，如果你想在自己的项目中使用Log4j或其他Log实现的话，就需要加上excludes: 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.alibaba.jstorm&lt;/groupId&gt; &lt;artifactId&gt;jstorm-core&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 5. 避免为不会输出的log付出代价(减少对不输出日志的成本)Log库都可以灵活的设置输出界别，所以每一条程序中的log，都是有可能不会被输出。这时候要注意不要额外的付出代价。（字符拼接代价） 先看两个有问题的写法： 12logger.debug("start process request, url: " + url);logger.debug("receive request: &#123;&#125;", toJson(request)); 第一条是直接做了字符串拼接，所以即使日志级别高于debug也会做一个字符串连接操作；第二条虽然用了SLF4J/Log4j2中的懒求值方式来避免不必要的字符串拼接开销，但是toJson()这个函数却是都会被调用并且开销更大。 推荐的写法如下: 123456logger.debug("start process request, url:&#123;&#125;", url); // SLF4J/LOG4J2logger.debug("receive request: &#123;&#125;", () -&gt; toJson(request)); // LOG4J2logger.debug(() -&gt; "receive request: " + toJson(request)); // LOG4J2if (logger.isDebugEnabled()) &#123; // SLF4J/LOG4J2 logger.debug("receive request: " + toJson(request)); &#125; 6. 日志格式中最好不要使用行号，函数名等字段原因是，为了获取语句所在的函数名，或者行号，log库的实现都是获取当前的stacktrace，然后分析取出这些信息，而获取stacktrace的代价是很昂贵的。如果有很多的日志输出，就会占用大量的CPU。在没有特殊需要的情况下，建议不要在日志中输出这些这些字段。 7. log中不要输出稀奇古怪的字符！部分开发人员为了方便看到自己的log，会在log语句中加上醒目的前缀，比如: 1logger.debug("========================start process request============="); 虽然对于自己来说是方便了，但是如果所有人都这样来做的话，那log输出就没法看了！正确的做法是使用grep（linux 中的shell命令） 来看只自己关心的日志。 转载处：https://zhuanlan.zhihu.com/p/24272450]]></content>
  </entry>
  <entry>
    <title><![CDATA[AJAX]]></title>
    <url>%2FMeBlog%2F2019%2F05%2F30%2Fajax%2F</url>
    <content type="text"><![CDATA[AJAX 简介AJAX 全称 Asynchronous JavaScript and XML AJAX = 异步 JavaScript 和 XML。 AJAX 是一种用于创建快速动态网页的技术。 AJAX 工作流程图 ajax基于InternetAJAX是基于现有的Internet标准，并且联合使用它们： XMLHttpRequest 对象 (异步的与服务器交换数据) JavaScript/DOM (信息显示/交互) CSS (给数据定义样式) XML (作为转换数据的格式) lamp AJAX应用程序与浏览器和平台无关的！ ajax实例基础实例123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;script&gt; function loadXMLDoc()&#123; var xmlhttp; if (window.XMLHttpRequest)&#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp=new XMLHttpRequest(); &#125; else&#123; // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)&#123; document.getElementById("myDiv").innerHTML=xmlhttp.responseText; &#125; &#125; xmlhttp.open("GET","https://www.runoob.com/try/ajax/ajax_info.txt",true); xmlhttp.send(); &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="myDiv"&gt;&lt;h2&gt;使用 AJAX 修改该文本内容&lt;/h2&gt;&lt;/div&gt;&lt;button type="button" onclick="loadXMLDoc()"&gt;修改内容&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 内容解析： xmlHttpRequest 请求运行流程 1.创建xmlHttpRequest对象 2.使用xmlHttpRequest对象开启一个请求方式 3.发送请求1234567891011121314151617181.创建xmlHttpRequest对象xmlhttp=new XMLHttpRequest(); //创建xmlHttpRequest对象，IE7+, Firefox, Chrome, Opera, Safari 浏览器可执行代码xmlhttp=new ActiveXObject("Microsoft.XMLHTTP"); //同样也是创建XMLHttpRequest对象，针对IE 6,5老版本的创建方式2.使用xmlHttpRequest对象开启一个请求//open(method,url,async) // 规定请求的类型、URL 以及是否异步处理请求。(开启一个请求)// method：请求的类型；GET 或 POST// url：文件在服务器上的位置，服务器请求路径// async：true（异步）或 false（同步),ajax中此选项一般都是 truexmlhttp.open("GET","https://www.runoob.com/try/ajax/ajax_info.txt",true);//send(string)// 将请求发送到服务器。// string：仅用于 POST 请求,用于添加post请求中的数据xmlhttp.send(); GET 于 POST 的对比与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。 然而，在以下情况中，请使用 POST 请求： 1.无法使用缓存文件（更新服务器上的文件或数据库）2.向服务器发送大量数据（POST 没有数据量限制）3.发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 xmlHttpRequest.setRequestHeader(header,value)此方法用于，向请求添加 HTTP 头。 header: 规定头的名称value: 规定头的值 例如1xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded"); responseText and responseXMLresponseText 用于获取服务器中的文本信息资源 responseXML 用于获取服务器中的XML格式资源 使用实例1document.getElementById("myDiv").innerHTML=xmlhttp.responseText; onreadystatechange 事件当请求被发送到服务器时，我们需要执行一些基于响应的任务。 每当 readyState 改变时，就会触发 onreadystatechange 事件。 readyState 属性存有 XMLHttpRequest 的状态信息。 下面是 XMLHttpRequest 对象的三个重要的属性： onreadystatechange ：存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState ： 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 status ：200: OK HTTP 响应状态码。404 :未找到页面 使用实例：123456789function myFunction()&#123; loadXMLDoc("/try/ajax/ajax_info.txt",function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)&#123; //要做的事情 todo document.getElementById("myDiv").innerHTML=xmlhttp.responseText; &#125; &#125;);&#125; 参考网址：https://www.runoob.com/ajax/ajax-tutorial.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[nginx]]></title>
    <url>%2FMeBlog%2F2019%2F05%2F22%2Fnginx%2F</url>
    <content type="text"><![CDATA[nginx 的安装ubuntu 下安装1apt install nginx nginx 虚拟主机配置1234567891011121314sudo vim /etc/nginx/nginx.conf在 http &#123;&#125;中添加server&#123; listen 80; //监听端口 server_name www.xuecheng.com; //服务名 ssi on; //是否开启ssi ssi_silent_errors on; location / &#123; alias /home/spiderbao/webStrom_dev/xc-ui-pc-static-portal/;//主机映射的路径 index index.html; &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2FMeBlog%2F2019%2F05%2F17%2Fgit%2F</url>
    <content type="text"><![CDATA[为什么使用git这个问题的答案就在于，集中式版本控制和分布式版本控制的的区别。 那么怎样算得上集中式版本控制呢？ 比如说SVN就是集中式版本控制系统，版本库是集中放在中央服务器的,而干活的时候,用的都是自己的电脑,所以首先要从中央服务器哪里得到最新的版本,然后干活,干完后,需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作,如果在局域网还可以,带宽够大,速度够快,如果在互联网下,如果网速慢的话,就郁闷了。 集中式版本控制存在如下缺陷： 依赖网络性强，由于只使用一个中央服务器，所以会有单点问题。 以上说了集中式版本控制，那么分布式版本控制工具又是怎么样的呢？ 分布式版本控制的代表就是git Git 是分布式版本控制系统,那么它就没有中央服务器,每个人的电脑就是一个完整的版本库,这样,工作的时候就不需要联网了,因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库,那多个人如何协作呢?比如说自己在电脑上改了文件A,其他人也在电脑上改了文件A,这时,你们两之间只需把各自的修改推送给对方,就可以互相看到对方的修改了。下图就是分布式版本控制工具管理方式: 分布式版本控制：解决了集中式版本控制的单点问题，和网络依赖性问题，适用于互联网多地区协同开发，但是在只是在局域网下开发，个人认为还是使用svn会更方便，git虽然性能优越但是使用上没有SVN简便。 git简介同生活中的许多伟大事件一样,Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991-2002 年间)。到 2002 年,整个项目组开始启用分布式版本控制系统 BitKeeper 来管理和维护代码。到 2005 年的时候,开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束,他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区(特别是 Linux 的缔造者 Linus Torvalds )不得不吸取教训,只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统订了若干目标:• 速度• 简单的设计• 对非线性开发模式的强力支持(允许上千个并行开发的分支)• 完全分布式• 有能力高效管理类似 Linux 内核一样的超大规模项目(速度和数据量) 工作流程一般工作流程如下:1.从远程仓库中克隆 Git 资源作为本地仓库。2.从本地仓库中 checkout 代码然后进行代码修改3.在提交前先将代码提交到暂存区。4.提交修改。提交到本地仓库。本地仓库中保存修改的各个历史版本。5.在修改完成后,需要和团队成员共享代码时,可以将代码 push 到远程仓库。下图展示了 Git 的工作流程: git 的工作目录介绍 其中 ./git 文件夹下就是git的本地仓库 git的使用创建仓库1git init 要初始的文件夹路径 添加文件到暂存区1git add 要加入的文件 将暂存区文件添加到本地仓库，并将本地仓库推送到远程仓库中将缓存区域文件添加到本地仓库1git commit 将本地仓库推送到远程仓库中123456789101112131415161718spiderbao@spiderbao-CW65S:~/git_study$ git push ssh://git@39.xxx.171.29/home/git/git_studyfatal: 当前分支 master 没有对应的上游分支。为推送当前分支并建立与远程上游的跟踪，使用 git push --set-upstream ssh://git@39.XXX.171.29/home/git/git_study masterspiderbao@spiderbao-CW65S:~/git_study$ git push --set-upstream ssh://git@39.XXX.171.29/home/git/git_study mastergit@39.XXX.171.29&apos;s password: Permission denied, please try again.git@39.XXX.171.29&apos;s password: 对象计数中: 6, 完成.Delta compression using up to 4 threads.压缩对象中: 100% (3/3), 完成.写入对象中: 100% (6/6), 523 bytes | 523.00 KiB/s, 完成.Total 6 (delta 0), reused 0 (delta 0)To ssh://39.XXX.171.29/home/git/git_study * [new branch] master -&gt; master分支 &apos;master&apos; 设置为跟踪来自 &apos;ssh://git@39.XXX.171.29/home/git/git_study&apos; 的远程分支 &apos;master&apos;。 查看修改历史123456789101112spiderbao@spiderbao-CW65S:~/git_study$ git logcommit 4cb2b4f87b03b6cf3301b000a3e14c44027e3f42 (HEAD -&gt; master)Author: spiderbao &lt;13593265401@163.com&gt;Date: Fri May 17 14:28:44 2019 +0800 第二次修改commit 1910c01353a8f12304e2a923164f69e33925a03aAuthor: spiderbao &lt;13593265401@163.com&gt;Date: Fri May 17 14:21:19 2019 +0800 first commit 还原修改reset 还原，还原后历史版本不存在12spiderbao@spiderbao-CW65S:~/git_study$ git reset --hard 1910c01353a8f12304e2a923164f69e33925a03aHEAD 现在位于 1910c01 first commit 删除文件12spiderbao@spiderbao-CW65S:~/git_study$ git rm test rm &apos;test&apos; 忽略文件或文件夹在文件目录下创建gitignore 文件12touch .gitignorevim .gitignore 忽略语法 123456789101112131415161718192021空行或是以 # 开头的行即注释行将被忽略。可以在前面添加正斜杠 / 来避免递归,下面的例子中可以很明白的看出来与下一条的区别。可以在后面添加正斜杠 / 来忽略文件夹,例如 build/ 即忽略 build 文件夹。可以使用 ! 来否定忽略,即比如在前面用了 *.apk ,然后使用 !a.apk ,则这个 a.apk 不会被忽略。* 用来匹配零个或多个字符,如 *.[oa] 忽略所有以&quot;.o&quot;或&quot;.a&quot;结尾, *~ 忽略所有以 ~ 结尾的文件(这种文件通常被许多编辑器标记为临时文件); [] 用来匹配括号内的任一字符,如 [abc] ,也可以在括号内加连接符,如 [0-9] 匹配 0 至 9 的数; ? 用来匹配单个字符。看了这么多,还是应该来个栗子:# 忽略 .a 文件*.a# 但否定忽略 lib.a, 尽管已经在前面忽略了 .a 文件!lib.a# 仅在当前目录下忽略 TODO 文件, 但不包括子目录下的 subdir/TODO/TODO# 忽略 build/ 文件夹下的所有文件build/# 忽略 doc/notes.txt, 不包括 doc/server/arch.txtdoc/*.txt# 忽略所有的 .pdf 文件 在 doc/ directory 下的doc/**/*.pdf 解决文件冲突编辑有冲突后的文件，再次提交即可 文件更新或拉取123456789101112spiderbao@spiderbao-CW65S:~/cloneToGit$ git clone ssh://git@39.xxx.xxx.29/home/git/git_study正克隆到 &apos;git_study&apos;...git@39.xxx.xxx.29&apos;s password: remote: Counting objects: 13, done.remote: Compressing objects: 100% (7/7), done.remote: Total 13 (delta 0), reused 0 (delta 0)接收对象中: 100% (13/13), 完成.spiderbao@spiderbao-CW65S:~/cloneToGit$ cd git_study/spiderbao@spiderbao-CW65S:~/cloneToGit/git_study$ git pullgit@39.xxx.xxx.29&apos;s password: 已经是最新的。 git分支管理创建分支1git branch 新分支名称 选择分支1git checkout 分支名称 合并分支123456spiderbao@spiderbao-CW65S:~/git_study$ git merge mybatis 更新 8c65eb0..458de41Fast-forward xiaoli | 1 + 1 file changed, 1 insertion(+) create mode 100644 xiaoli]]></content>
  </entry>
  <entry>
    <title><![CDATA[Docker]]></title>
    <url>%2FMeBlog%2F2019%2F05%2F17%2FDocker%2F</url>
    <content type="text"><![CDATA[Docker学习目标： 掌握Docker基础知识，能够理解Docker镜像与容器的概念 完成Docker安装与启动 掌握Docker镜像与容器相关命令 掌握Tomcat Nginx 等软件的常用应用的安装 掌握docker迁移与备份相关命令 能够运用Dockerfile编写创建容器的脚本 能够搭建与使用docker私有仓库 ​ 1 Docker简介1.1 什么是虚拟化​ 在计算机中，虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。这些资源的新虚拟部份是不受现有资源的架设方式，地域或物理组态所限制。一般所指的虚拟化资源包括计算能力和资料存储。 ​ 在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件 对资源充分利用 ​ 虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等。 1.2 什么是Docker​ Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。 ​ ​ Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。 ​ Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。 ​ 在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。 为什么选择Docker? （1）上手快。 ​ 用户只需要几分钟，就可以把自己的程序“Docker化”。Docker依赖于“写时复制”（copy-on-write）模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改”的境界。 随后，就可以创建容器来运行应用程序了。大多数Docker容器只需要不到1秒中即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。 （2）职责的逻辑分类 ​ 使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）” （3）快速高效的开发生命周期 ​ Docker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。（通俗一点说，Docker就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取。） （4）鼓励使用面向服务的架构 ​ Docker还鼓励面向服务的体系结构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。（当然，可以在一个容器中运行多个应用程序） 1.3 容器与虚拟机比较​ 下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。 与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。 1.4 Docker 组件1.4.1 Docker服务器与客户端​ Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。 1.4.2 Docker镜像与容器​ 镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。例如： 添加一个文件； 执行一个命令； 打开一个窗口。 也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新。 ​ Docker可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可。容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。 容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。 所以Docker容器就是： ​ 一个镜像格式； ​ 一些列标准操作； ​ 一个执行环境。 ​ Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。 和集装箱一样，Docker在执行上述操作时，并不关心容器中到底装了什么，它不管是web服务器，还是数据库，或者是应用程序服务器什么的。所有的容器都按照相同的方式将内容“装载”进去。 Docker也不关心你要把容器运到何方：我们可以在自己的笔记本中构建容器，上传到Registry，然后下载到一个物理的或者虚拟的服务器来测试，在把容器部署到具体的主机中。像标准集装箱一样，Docker容器方便替换，可以叠加，易于分发，并且尽量通用。 1.4.3 Registry（注册中心）​ Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像（说明：在Docker Hub下载镜像巨慢，可以自己构建私有的Registry）。 ​ https://hub.docker.com/ 2 Docker安装与启动2.1 安装Docker​ Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。 ​ 由于我们学习的环境都使用的是CentOS，因此这里我们将Docker安装到CentOS上。注意：这里建议安装在CentOS7.x以上的版本，在CentOS6.x的版本中，安装前需要安装其他很多的环境而且Docker很多补丁不支持更新。 ​ 请直接挂载课程配套的Centos7.x镜像 （1）yum 包更新到最新 1sudo yum update （2）安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 （3）设置yum源为阿里云 1sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo （4）安装docker 1sudo yum install docker-ce （5）安装后查看docker版本 1docker -v 2.2 设置ustc的镜像ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。 https://lug.ustc.edu.cn/wiki/mirrors/help/docker 编辑该文件： 1vi /etc/docker/daemon.json 在该文件中输入如下内容： 123&#123;&quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]&#125; 2.3 Docker的启动与停止systemctl命令是系统服务管理器指令 启动docker： 1systemctl start docker 停止docker： 1systemctl stop docker 重启docker： 1systemctl restart docker 查看docker状态： 1systemctl status docker 开机启动： 1systemctl enable docker 查看docker概要信息 1docker info 查看docker帮助文档 1docker --help 3 常用命令3.1 镜像相关命令3.1.1 查看镜像1docker images REPOSITORY：镜像名称 TAG：镜像标签 IMAGE ID：镜像ID CREATED：镜像的创建日期（不是获取该镜像的日期） SIZE：镜像大小 这些镜像都是存储在Docker宿主机的/var/lib/docker目录下 3.1.2 搜索镜像如果你需要从网络中查找需要的镜像，可以通过以下命令搜索 1docker search 镜像名称 NAME：仓库名称 DESCRIPTION：镜像描述 STARS：用户评价，反应一个镜像的受欢迎程度 OFFICIAL：是否官方 AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的 3.1.3 拉取镜像拉取镜像就是从中央仓库中下载镜像到本地 1docker pull 镜像名称 例如，我要下载centos7镜像 1docker pull centos:7 3.1.4 删除镜像按镜像ID删除镜像 1docker rmi 镜像ID 删除所有镜像 1docker rmi `docker images -q` 3.2 容器相关命令3.2.1 查看容器查看正在运行的容器 1docker ps 查看所有容器 1docker ps –a 查看最后一次运行的容器 1docker ps –l 查看停止的容器 1docker ps -f status=exited 3.2.2 创建与启动容器创建容器常用的参数说明： 创建容器命令：docker run -i：表示运行容器 -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。 –name :为创建的容器命名。 -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。 -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。 -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射 （1）交互式方式创建容器 1docker run -it --name=容器名称 镜像名称:标签 /bin/bash 这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态 退出当前容器 1exit （2）守护式方式创建容器： 1docker run -di --name=容器名称 镜像名称:标签 登录守护式容器方式： 1docker exec -it 容器名称 (或者容器ID) /bin/bash 3.2.3 停止与启动容器停止容器： 1docker stop 容器名称（或者容器ID） 启动容器： 1docker start 容器名称（或者容器ID） 3.2.4 文件拷贝如果我们需要将文件拷贝到容器内可以使用cp命令 1docker cp 需要拷贝的文件或目录 容器名称:容器目录 也可以将文件从容器内拷贝出来 1docker cp 容器名称:容器目录 需要拷贝的文件或目录 3.2.5 目录挂载我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。创建容器 添加-v参数 后边为 宿主机目录:容器目录，例如： 1docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos3 centos:7 如果你共享的是多级的目录，可能会出现权限不足的提示。 这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数 –privileged=true 来解决挂载的目录没有权限的问题 3.2.6 查看容器IP地址我们可以通过以下命令查看容器运行的各种数据 1docker inspect 容器名称（容器ID） 也可以直接执行下面的命令直接输出IP地址 1docker inspect --format=&apos;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&apos; 容器名称（容器ID） 3.2.7 删除容器删除指定的容器： 1docker rm 容器名称（容器ID） 4 应用部署4.1 MySQL部署（1）拉取mysql镜像 1docker pull centos/mysql-57-centos7 （2）创建容器 1docker run -di --name=tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql(镜像名称或ID) -p 代表端口映射，格式为 宿主机映射端口:容器运行端口 -e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是root用户的登陆密码 （3）远程登录mysql 连接宿主机的IP ,指定端口为33306 4.2 tomcat部署（1）拉取镜像 1docker pull tomcat:7-jre7 （2）创建容器 创建容器 -p表示地址映射 12docker run -di --name=mytomcat -p 9000:8080 -v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7(镜像名称或ID) 4.3 Nginx部署（1）拉取镜像 1docker pull nginx （2）创建Nginx容器 1docker run -di --name=mynginx -p 80:80 nginx 4.4 Redis部署（1）拉取镜像 1docker pull redis （2）创建容器 1docker run -di --name=myredis -p 6379:6379 redis 5 迁移与备份5.1 容器保存为镜像我们可以通过以下命令将容器保存为镜像 1docker commit mynginx mynginx_i 5.2 镜像备份我们可以通过以下命令将镜像保存为tar 文件 1docker save -o mynginx.tar mynginx_i 5.3 镜像恢复与迁移首先我们先删除掉mynginx_img镜像 然后执行此命令进行恢复 1docker load -i mynginx.tar -i 输入的文件 执行后再次查看镜像，可以看到镜像已经恢复 6 Dockerfile6.1 什么是DockerfileDockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。 1、对于开发人员：可以为开发团队提供一个完全一致的开发环境；2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了；3、对于运维人员：在部署时，可以实现应用的无缝移植。 6.2 常用命令 命令 作用 FROM image_name:tag 定义了使用哪个基础镜像启动构建流程 MAINTAINER user_name 声明镜像的创建者 ENV key value 设置环境变量 (可以写多条) RUN command 是Dockerfile的核心部分(可以写多条) ADD source_dir/file dest_dir/file 将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压 COPY source_dir/file dest_dir/file 和ADD相似，但是如果有压缩文件并不能解压 WORKDIR path_dir 设置工作目录 6.3 使用脚本创建镜像步骤： （1）创建目录 1mkdir –p /usr/local/dockerjdk8 （2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录 （3）创建文件Dockerfile vi Dockerfile 123456789101112131415#依赖镜像名称和IDFROM centos:7#指定镜像创建者信息MAINTAINER ITCAST#切换工作目录WORKDIR /usrRUN mkdir /usr/local/java#ADD 是相对路径jar,把java添加到容器中ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/#配置java环境变量ENV JAVA_HOME /usr/local/java/jdk1.8.0_171ENV JRE_HOME $JAVA_HOME/jreENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATHENV PATH $JAVA_HOME/bin:$PATH （4）执行命令构建镜像 1docker build -t=&apos;jdk1.8&apos; . 注意后边的空格和点，不要省略 （5）查看镜像是否建立完成 1docker images 7 Docker私有仓库7.1 私有仓库搭建与配置（1）拉取私有仓库镜像（此步省略） 1docker pull registry （2）启动私有仓库容器 1docker run -di --name=registry -p 5000:5000 registry （3）打开浏览器 输入地址http://192.168.184.141:5000/v2/_catalog看到`{&quot;repositories&quot;:[]}` 表示私有仓库搭建成功并且内容为空 （4）修改daemon.json 1vi /etc/docker/daemon.json 添加以下内容，保存退出。 1&#123;"insecure-registries":["192.168.184.141:5000"]&#125; 此步用于让 docker信任私有仓库地址 （5）重启docker 服务 1systemctl restart docker 7.2 镜像上传至私有仓库（1）标记此镜像为私有仓库的镜像 1docker tag jdk1.8 192.168.184.141:5000/jdk1.8 （2）再次启动私服容器 1docker start registry （3）上传标记的镜像 1docker push 192.168.184.141:5000/jdk1.8 8.Docker如何查看容器日志8.1 Docker logs​ 使用命令docker logs 容器名即可查看 1docker logs 容器名 ​ -f 查看实时日志 1docker logs -f 容器名 ​ -t查看日志产生的日期 1docker logs -t 容器名 ​ –since : 此参数指定了输出日志开始日期，即只输出指定日期之后的日志。 1docker logs -f -t --since=&quot;2017-05-31&quot; --tail=10 容器名 ​ –tail=10 : 查看最后的10条日志。 9.Docker的生命周期 10.进入Docker1docker exce -ti 容器名称 /bin/bash]]></content>
  </entry>
  <entry>
    <title><![CDATA[ubuntu 下的软件管理]]></title>
    <url>%2FMeBlog%2F2019%2F05%2F15%2Fubuntu%20%E4%B8%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[概念部分Ubuntu软件包管理概述Ubuntu Linux采用了Debian的软件包管理机制。由于软件包具有易用性、灵活性和扩展性的特点，再加上Internet的支持，使用户随时都能拥有最新的 Ubuntu系统，这也是Ubuntu受到推崇的一个重要原因。因而，Deb软件包管理也成为Ubuntu中最有活力的部分。本章介绍Ubuntu软件包 管理和dpkg软件包管理器。 Deb软件包概述Deb软件包本质上是文件包，这点类似于tar文件将多个文件合并为一个归档文件。但是Deb的身价不在于整合文件，而在于使应用程序更易于传播。 当年流行的两种软件包管理机制 最初，基于Linux系统的开发者在完成应用程序开 发后，将很多二进制文件发给用户，用户使用之前需要将相关程序逐个安装。因此，Debian Linux首先提出“软件包”的管理机制——Deb软件包，将应用程序的二进制文件、配置文档、man/info帮助页面等文件合并打包在一个文件中，用 户使用软件包管理器直接操作软件包，完成获取、安装、卸载、查询等操作。 随即，Redhat Linux基于这个理念推出了自己的软件包管理机制——Rpm软件包。当然，Redhat Linux采用了自己的打包格式生成Rpm包文件，由Rpm包管理器负责安装、维护、查询，甚至软件包版本管理。由于Redhat Linux系统的普及，Rpm软件包被广泛使用，甚至出现第三方开发的软件管理工具，专门管理Rpm格式的软件包。 随着Linux操作系统规模的不断扩大，系统中软件 包之间复杂的依赖关系，导致Linux用户麻烦不断。为了解决这个问题，Debian Linux开发出了APT软件包管理器。它能够自动检查和修复软件包之间的依赖关系。并且，利用Internet网络带来的快捷的连通手段，APT工具可 以帮助用户主动获取软件包。因此，APT工具再次促进了Deb软件包更为广泛地使用，成为Debian Linux的一个无法替代的亮点。 Ubuntu Linux系统的软件包管理机制延续了Debian的包管理方法。 软件包的类型Debian包文件包含了二进制可执行文件、库文件、配置文件和man/info帮助页面等文档。通常Debian包文件的后缀为.deb，因此称为“Deb软件包”。Ubuntu有两种类型的软件包：二进制软件包（deb）和源码包（deb-src）。 ● 二进制软件包（Binary Packages）：包含可执行文件、库文件、配置文件、man/info页面、版权声明和其他文档。 ● 源码包（Source Packages）：包含软件源代码、版本修改说明、构建指令以及编译工具等。先由tar工具归档为.tar.gz文件，然后再打包成.dsc文件。 用户不确定一个软件包具体类型时，可以使用file命令查看文件类型。例如下面命令用于证实一个软件包的文件类型是否是Deb软件包文件。 wdl@UbuntuFisher:~$ file g++_4.1.2-9ubuntu2_i386.deb g++_4.1.2-9ubuntu2_i386: Debian binary package (format 2.0) 在Ubuntu Linux中，需要说明一个概念——虚拟软件包。将系统中具有相同或相近功能的多个软件包作为一个软件包集合，称为虚拟软件包，并指定其中一个软件包作为 虚拟软件包的默认首选项。提出虚拟软件的意图就是为了防止软件安装过程中发生冲突。例如，exim、sendmail和postfix软件包都是用于邮件 传输代理，将“mail-transport-agent”指定为它们的虚拟软件包。当用户安装“mail-transport-agent”时，将选择 安装exim、sendmail和postfix其中的首选项。 软件包的命名在Ubuntu Linux中，软件包的命名遵循以下约定： Filename_Version-Reversion_Architecture.deb 其中，Filename表示软件包文件名，Version表示软件版本号，Reversion表示修订版本号，Architecture表示适用计算机架构。通常，修订版本号是由Ubuntu开发者或创建这个软件包的人指定。在软件包被修改过之后，将修改版本号加1。 以g++_4.1.2-9ubuntu2_i386.deb软件包为例，g++是软件包名，4.1.2是软件版本号，9ubuntu2是修订版本号，i386是适用的计算机架构。 配置部分Ubuntu 方便宜用，最值得让人称道的便是其安装软件的方式, 一条命令: sudo apt-get install xxx 就几乎能帮你搞定所有的软件安装难题。但是有时你可能有这样的需求，查看某个软件包是否安装、安装在哪..., 那我们就来介绍一下 Ubuntu 的软件包管理方式。 一、Ubuntu 采用 Debian 的软件包管理器 dpkg 来管理软件包, 类似 RPM. 系统中所有 packages 的信息都在 /var/lib/dpkg/ 目录下, 其子目录 /var/lib/dpkg/info 用于保存各个软件包的配置文件列表: (1).conffiles 记录了软件包的配置文件列表 (2).list 保存软件包中的文件列表, 用户可以从 .list 的信息中找到软件包中文件的具体安装位置. (3).md5sums 记录了软件包的md5信息, 这个信息是用来进行包验证的. (4).prerm 脚本在 Debian 包解包之前运行, 主要作用是停止作用于即将升级的软件包的服务, 直到软件包安装或升级完成. (5).postinst 脚本是完成 Debian 包解开之后的配置工作, 通常用于执行所安装软件包相关命令和服务重新启动. /var/lib/dpkg/available 文件的内容是软件包的描述信息, 该软件包括当前系统所使用的 Debian 安装源中的所有软件包, 其中包括当前系统中已安装的和未安装的软件包. /var/cache/apt/archives 目录是在用 apt-get install 安装软件时，软件包的临时存放路径 /etc/apt/sources.list 存放的是软件源站点, 当你执行 sudo apt-get install xxx 时，Ubuntu 就去这些站点下载软件包到本地并执行安装 命令操作部分apt和dpkg混合命令 (1)查看某软件包的安装内容 dpkg -L xxx (2)查找软件库中的软件包 apt-cache search 正则表达式 (3)显示系统安装包的统计信息 apt-cache stats (4)显示系统全部可用软件包的名称 apt-cache pkgnames (5)显示某软件包的详细信息 apt-cache show xxx (6)查找某文件属于哪个包 apt-file search xxx (7)查看已经安装了哪些软件包 dpkg -l (8)查询某软件依赖哪些软件包 apt-cache depends xxx (9)查询某软件被哪些软件包依赖 apt-cache rdepends xxx (10)增加一个光盘源 sudo apt-cdrom add 注: 顾名思义, 就是安装更新软件包时让其优先从Ubuntu 光盘上找(如果你不能上网安装/更新, 但有 Ubuntu 的 DVD ISO, 这会对你非常有用) (11)系统升级 sudo apt-get update (12)清除所有已删除软件包的残馀配置文件 dpkg -l |grep ^rc|awk ‘{print $2}’ |sudo xargs dpkg -P (13)编译时缺少h文件的自动处理 sudo auto-apt run ./configure (14)查看安装软件时下载软件包的临时存放目录 ls /var/cache/apt/archives (15)备份当前系统安装的所有软件包的列表 dpkg –get-selections | grep -v deinstall &gt; ~/somefile (16)从上面备份的安装包的列表文件恢复所有包 dpkg –set-selections &lt; ~/somefile sudo dselect (17)清理旧版本的软件缓存 sudo apt-get autoclean (18)清理所有软件缓存 sudo apt-get clean (19)删除系统不再使用的孤立软件 sudo apt-get autoremove (20)查看软件包在服务器上面的地址 apt-get -qq –print-uris install ssh | cut -d\’ -f2 (21)查看安装软件的一些路径信息 dpkg -L 软件包名 deb包安装sudo dpkg -i &apos;deb文件路径加文件名&apos;]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot]]></title>
    <url>%2FMeBlog%2F2019%2F05%2F14%2Fspringboot%2F</url>
    <content type="text"><![CDATA[springboot概述springboot是spring的一个boot版本，它的出现是为了让你能更快的体验或使用spring。我经常把它看做spring的简单易用版。那他是从那几个方面去做到spring的简单易用的呢？ 1.约定优于配置 —自动配置2.依赖自带了起步依赖的坐标。—起步依赖 springboot_quick （dome）1.pom构建：继承springbootparent ，起步依赖配置1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itcast&lt;/groupId&gt; &lt;artifactId&gt;springboot_quick&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 2.创建启动类1234567891011121314151617181920212223package com.itcast;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import javax.swing.*;/** * @className MysoringBoot * @Descirption springboot boot class * @Author WengLiangBao * @Date 19-5-12 下午1:21 * @Vsersion 1.0 */@SpringBootApplicationpublic class MysoringBoot &#123; /* SpringApplication.run(MysoringBoot.class) 代表运行SpringBoot的启动类,参数为SpringBoot启动类的字节码对象 */ public static void main(String[] args)&#123; SpringApplication.run(MysoringBoot.class); &#125;&#125; 3.构建访问控制层controller1234567891011121314151617181920212223package com.itcast.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;/** * @className QuickStartController * @Descirption quick dome contorller * @Author WengLiangBao * @Date 19-5-12 下午1:37 * @Vsersion 1.0 */@Controllerpublic class QuickStartController &#123; @RequestMapping("/quick") @ResponseBody public String quick()&#123; return "springboot 访问成功！"; &#125;&#125; pom中添加热部署 12345&lt;!-- 热部署--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt; 起步依赖自动配置springboot配置文件SpringBoot是基于约定的,所以很多配置都有默认值,但如果想使用自己的配置替换默认配置的话,就可以使用application.properties或者application.yml(application.yaml)进行配置。 SpringBoot默认会从Resources目录下加载application.properties或application.yml(application.yaml) 上面提及过,SpringBoot的配置文件,主要的目的就是对配置信息进行修改的,但在配置时的key从哪里去查询呢?我们可以查阅SpringBoot的官方文档文档URL:https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#common-application-properties 配置文件与配置类的属性映射关系@value1.在application.yml 中添加如下属性123person: name: xiaoming age: 18 2.在对应类中使用1234@Value("$&#123;person.name&#125;")private String name;@Value("$&#123;person.age&#125;")private Integer age; @configurationProperties1.在application.yml 中添加如下属性123person: name: xiaoming age: 18 2.在对应的实体类中使用12345678@ConfigurationProperties(prefix = "person")@Datapublic class QuickStartController &#123; private String name; private int age; 注意使用configurationProperties需要为指定的属性添加getting或setting ，本人使用lombok的@Data自动生成了getting，setting springboot整合mybatis 整合1.pom 中添加坐标1234567891011&lt;!--由于spring官方没有对mybatis整合提供技术方案支持，所以这里需要使用mybatis提供的整合jar包，并指定版本--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 2.application.yml 中配置mybatis及数据库链接信息12345678910#DB configurationspring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/mybatis_study?useUnicode=true&amp;charaterEncoding=utf-8&amp;useSSL=true username: spider password: *****#mybatis configurationmybatis: mapper-locations: classpath:mapper/*Mapper.xml 3.创建dao控制层和mapper映射文件 dao层文件12345678910111213141516171819package com.itcast.dao;import com.itcast.pojo.User;import org.apache.ibatis.annotations.Mapper;import java.util.List;/** * @className UserMapper * @Descirption * @Author WengLiangBao * @Date 19-5-12 下午3:09 * @Vsersion 1.0 */@Mapperpublic interface UserMapper &#123; public List&lt;User&gt; queryUserList();&#125; Mapper ,编写位置对应application.yml中mapper-locations的位置，内容为123456789&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.itcast.dao.UserMapper"&gt; &lt;select id="queryUserList" resultType="com.itcast.pojo.User"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 4.数据库对应pojo编写1234567891011121314151617181920212223package com.itcast.pojo;import lombok.Data;/** * @className User * @Descirption * @Author WengLiangBao * @Date 19-5-12 下午3:07 * @Vsersion 1.0 */@Datapublic class User &#123; private Integer id; private String username; private String password; private String name;&#125; Junit 整合1.pom中添加Junit起步依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;/dependency&gt; 2.编写测试类12345678910111213141516171819202122232425262728293031323334353637383940package com.itcast.daoTest;import com.itcast.MysoringBoot;import com.itcast.dao.UserMapper;import com.itcast.pojo.User;import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import java.util.ArrayList;import java.util.List;/** * @className UserMapperTest * @Descirption 用户映射测试 * @Author WengLiangBao * @Date 19-5-12 下午3:50 * @Vsersion 1.0 */@RunWith(SpringRunner.class)@SpringBootTest(classes = MysoringBoot.class)//程序启动入口类public class UserMapperTest &#123; @Autowired private UserMapper userMapper; @Test public void queryListUser()&#123; List&lt;User&gt; users = userMapper.queryUserList(); Assert.assertNotNull(users); List&lt;User&gt; array = new ArrayList&lt;User&gt;(); array.add(new User(1,"zhangsan","123","张三")); array.add(new User(2,"lisi","123","李四")); System.out.print(users); Assert.assertArrayEquals(users.toArray(),array.toArray()); &#125;&#125; redis 整合1.添加起步依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 2.application.yml 中配置redis所需属性1234spring: redis: host: xx.104.xxx.29 port: 6379 3.编写测试类测试1234567891011121314151617181920@Autowiredprivate UserMapper userMapper;@Autowiredprivate RedisTemplate&lt;String,String&gt; redisTemplate;@Testpublic void redisTest() throws JsonProcessingException &#123; String userListData = redisTemplate.boundValueOps("user.findAll").get(); if(userListData==null)&#123; List&lt;User&gt; users = userMapper.queryUserList(); String uD = new ObjectMapper().writeValueAsString(users); userListData = uD; redisTemplate.boundValueOps("user.findAll").set(uD); System.out.print("从数据库中获取"); &#125;else &#123; System.out.print("从redis缓存中获取"); &#125; System.out.print(userListData);&#125; springJPA 整合1.添加spring Data JPA起步依赖及其所需的一些坐标12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 2.application.yml中配置数据库及jpa的相关属性12345678910spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://127.0.0.1:3306/mybatis_study?useUnicode=true&amp;charaterEncoding=utf-8&amp;useSSL=truespring.datasource.username=spiderspring.datasource.password=*****spring.jpa.database=MySQLspring.jpa.show-sql=truespring.jpa.generate-ddl=truespring.jpa.hibernate.ddl-auto=updatespring.jpa.hibernate.naming_strategy=org.hibernate.cfg.ImprovedNamingStrategy 3.创建pojo并映射123456789101112131415161718192021222324252627282930package com.example.demo.pojo;import lombok.Data;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;/** * @className User * @Descirption * @Author WengLiangBao * @Date 19-5-12 下午4:58 * @Vsersion 1.0 */@Entity@Datapublic class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String username; private String password; private String name;&#125; 4.编写dao层的对应操作接口1234567891011121314151617package com.example.demo.dao;import com.example.demo.pojo.User;import org.springframework.data.jpa.repository.JpaRepository;import java.util.List;/** * @className UserRepository * @Descirption * @Author WengLiangBao * @Date 19-5-12 下午5:21 * @Vsersion 1.0 */public interface UserRepository extends JpaRepository&lt;User,Long&gt; &#123; public List&lt;User&gt; findAll();&#125; 5.编写测试类测试验证1234567891011121314151617181920212223242526package com.example.demo;import com.example.demo.dao.UserRepository;import com.example.demo.pojo.User;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import java.util.List;@RunWith(SpringRunner.class)@SpringBootTest(classes = DemoApplication.class)public class DemoApplicationTests &#123; @Autowired private UserRepository userRepository; @Test public void contextLoads() &#123; List&lt;User&gt; all = userRepository.findAll(); System.out.print(all); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[python_base64]]></title>
    <url>%2FMeBlog%2F2019%2F05%2F05%2Fpyhton_base64%2F</url>
    <content type="text"><![CDATA[目标1：了解base64基础知识，在python中会使用base64base64的编码原理（摘录）Base64是一种用64个字符来表示任意二进制数据的方法。 用记事本打开exe、jpg、pdf这些文件时，我们都会看到一大堆乱码，因为二进制文件包含很多无法显示和打印的字符，所以，如果要让记事本这样的文本处理软件能处理二进制数据，就需要一个二进制到字符串的转换方法。Base64是一种最常见的二进制编码方法。 Base64的原理很简单，首先，准备一个包含64个字符的数组： [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, ... &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, ... &apos;0&apos;, &apos;1&apos;, ... &apos;+&apos;, &apos;/&apos;] 然后，对二进制数据进行处理，每3个字节一组，一共是3x8=24bit，划为4组，每组正好6个bit： 这样我们得到4个数字作为索引，然后查表，获得相应的4个字符，就是编码后的字符串。 所以，Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。 如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用\x00字节在末尾补足后，再在编码的末尾加上1个或2个=号，表示补了多少字节，解码的时候，会自动去掉。 python中的base64加密1base64.b64encode(b'binary\x00string') 解密1base64.b64decode(b'YmluYXJ5AHN0cmluZw==') safe由于标准的Base64编码后可能出现字符+和/，在URL中就不能直接作为参数，所以又有一种&quot;url safe&quot;的base64编码，其实就是把字符+和/分别变成-和_ 1base64.urlsafe_b64encode(b'i\xb7\x1d\xfb\xef\xff') 以上内容参考https://www.liaoxuefeng.com/wiki/1016959663602400/1017684507717184]]></content>
  </entry>
  <entry>
    <title><![CDATA[python_argparse]]></title>
    <url>%2FMeBlog%2F2019%2F05%2F02%2Fpython_argparse%2F</url>
    <content type="text"><![CDATA[argparse由来​ 原文： The argparse module is a command line parsing library which provides more functionality than the existing command line parsing modules in the standard library, getopt [2] and optparse [3]. It includes support for positional arguments (not just options), subcommands, required options, options syntaxes like “/f” and “+rgb”, zero-or-more and one-or-more style arguments, and many other features the other two lack. The argparse module is also already a popular third-party replacement for these modules. It is used in projects like IPython (the Scipy Python shell) [4], is included in Debian testing and unstable [5], and since 2007 has had various requests for its inclusion in the standard library [6] [7] [8]. This popularity suggests it may be a valuable addition to the Python libraries. 个人理解： argparse 是一个命令行分析库，它比标准库中的getopt optparse要强大。argparse属于目前流行的第三方命令分析库。 命令解析模块必知的一些基础概念位置参数如 ls /home/XXX 其中的 ‘/home/XXX’就称之为位置参数 可选参数如 ls -l 其中的 ‘-l’ 就称之为可选参数 帮助文档如 ls --help 入门dome1 1234import argparseparse = argparse.ArgumentParser()parse.parse_args() 用来创建一个基础的命令程序 123456import argparseparse = argparse.ArgumentParser()parse.add_argument('echo',help='回显你输入的字符串')args = parse.parse_args()print(args.echo) 当用户使用命令行python 文件名 –help 会查看到 positional arguments: echo 回显你输入的字符串 positional arguments: what is positional arguments? 通常它代表命令中的坐标信息，并且它一个必选项参数。 下面的dome演示如何构建及其调用 123456789import argparseparse = argparse.ArgumentParser()parse.add_argument('echo',help='回显你输入的字符串')parse.add_argument('square',help='计算输入数的平方',type=int)args = parse.parse_args()print(args.echo)print(args.square**2) 当用户使用命令行python 文件名 –help 会查看到 positional arguments: echo 回显你输入的字符串 square 计算输入数的平方 optional arguments: -h, –help show this help message and exit optional arguments what is optional arguments? 它可以代表命令中的一些附件信息，如下面的2个dome一个是表示选择只有一个参数，一个表示选项可以有多个参数 多参数 123456789import argparseparse = argparse.ArgumentParser()parse.add_argument('--verbosity',help="increase output verbosity")args = parse.parse_args()if args.verbosity: print('verbosity turned on') 1234567891011121314151617spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py --versionusage: argparse_study.py [-h] [--verbosity VERBOSITY]spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py -husage: argparse_study.py [-h] [--verbosity VERBOSITY]optional arguments: -h, --help show this help message and exit --verbosity VERBOSITY increase output verbosityspiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py -verbosity 1usage: argparse_study.py [-h] [--verbosity VERBOSITY]argparse_study.py: error: unrecognized arguments: -verbosity 1spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py --verbosity 1verbosity turned onspiderbao@spiderbao-CW65S:~/python/study/code$ 单参数 123456789import argparseparse = argparse.ArgumentParser()parse.add_argument('--verbosity',help="increase output verbosity",action='store_true')args = parse.parse_args()if args.verbosity: print('verbosity turned on') 123456789101112spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py --verbosityverbosity turned onspiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py --verbosity 1usage: argparse_study.py [-h] [--verbosity]argparse_study.py: error: unrecognized arguments: 1spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py -husage: argparse_study.py [-h] [--verbosity]optional arguments: -h, --help show this help message and exit --verbosity increase output verbosityspiderbao@spiderbao-CW65S:~/python/study/code$ 短选项 1234567import argparseparse = argparse.ArgumentParser()parse.add_argument('-v','--verbosity',help='increase output verbosity',action='store_true')args = parse.parse_args()if args.verbosity: print('verbosity turned on') 命令行输入 123456spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py -v 1verbosity turned onspiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py -v verbosity turned onspiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py --verbosityverbosity turned on 组合Positional和Optional参数 1234567891011parse = argparse.ArgumentParser()parse.add_argument('-v','--verbosity',help='显示输出详情',action='count',default=1)parse.add_argument('square',help='计算输入数的平方',type=int)args = parse.parse_args()answer = args.square**2if args.verbosity&gt;=1: print('%s^2=%s' %(args.square,answer))if args.verbosity&gt;=2: print('runing %s'%__file__)if args.verbosity&lt;1: print(answer) 命令行输入显示 1234567891011121314151617181920212223242526spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py -h usage: argparse_study.py [-h] [-v] squarepositional arguments: square 计算输入数的平方optional arguments: -h, --help show this help message and exit -v, --verbosity 显示输出详情spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py -husage: argparse_study.py [-h] [-v] squarepositional arguments: square 计算输入数的平方optional arguments: -h, --help show this help message and exit -v, --verbosity 显示输出详情spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py 44^2=16spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py 4 -v4^2=16runing argparse_study.pyspiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py 4 -vv4^2=16runing argparse_study.py 选参互斥异常 12345678910111213141516parse = argparse.ArgumentParser(description='calculate X to the power of Y')group = parse.add_mutually_exclusive_group();group.add_argument("-v", "--verbose", action="store_true")group.add_argument("-q", "--quiet", action="store_true")#group 添加互斥项，相当于usage: argparse_study.py [-h] [-v | -q] x y 中的[-v | -q] 只能选取一个parse.add_argument("x", type=int, help="the base")parse.add_argument("y", type=int, help="the exponent")args = parse.parse_args()answer = args.x**args.yif args.quiet: print(answer)elif args.verbose: print("&#123;&#125; to the power &#123;&#125; equals &#123;&#125;".format(args.x, args.y, answer))else: print("&#123;&#125;^&#123;&#125; == &#123;&#125;".format(args.x, args.y, answer)) 命令行输入显示 12345678910111213141516171819202122spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py -husage: argparse_study.py [-h] [-v | -q] x ycalculate X to the power of Ypositional arguments: x the base y the exponentoptional arguments: -h, --help show this help message and exit -v, --verbose -q, --quietspiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py 4 24^2 == 16spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py 4 2 -v4 to the power 2 equals 16spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py 4 2 -q16spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py 4 2 -vqusage: argparse_study.py [-h] [-v | -q] x yargparse_study.py: error: argument -q/--quiet: not allowed with argument -v/--verbose 以上内容参考https://docs.python.org/3/howto/argparse.html?highlight=argparse]]></content>
  </entry>
  <entry>
    <title><![CDATA[vim篇]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2Fvim%E7%AF%87%2F</url>
    <content type="text"><![CDATA[vim文本编辑器vim常用操作​ vim是荷兰一位名叫 Bram Moolenaar 的工程师开发并分享的开源编辑器插件 vim使用技巧 上面连续行注释中 /表示隔离符 \表示转移符 个人用户下编辑添加 .vimrc 文件可以保存一些关于vim的配置和快捷键的使用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[系统安全案例及设计理念]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2F%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[RBAC模型什么是RBACRBAC（全称：Role-Based Access Control）基于角色的权限访问控制，作为传统访问控制（自主访问，强制访问）的有前景的代替受到广泛的关注。在RBAC中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。在一个组织中，角色是为了完成各种工作而创造，用户则依据它的责任和资格来被指派相应的角色，用户可以很容易地从一个角色被指派到另一个角色。角色可依新的需求和系统的合并而赋予新的权限，而权限也可根据需要而从某角色中回收。角色与角色的关系可以建立起来以囊括更广泛的客观情况。访问控制是针对越权使用资源的防御措施，目的是为了限制访问主体（如用户等） 对访问客体（如数据库资源等）的访问权限。企业环境中的访问控制策略大部分都采用基于角色的访问控制（RBAC）模型，是目前公认的解决大型企业的统一资源访问控制的有效方法 基于RBAC实现的设计思路基于角色的访问控制基本原理是在用户和访问权限之间加入角色这一层，实现用户和权限的分离，用户只有通过激活角色才能获得访问权限。通过角色对权限分组，大大简化了用户权限分配表，间接地实现了对用户的分组，提高了权限的分配效率。且加入角色层后，访问控制机制更接近真实世界中的职业分配，便于权限管理。 表结构模型图 需求1前端 ​ 动态加载用户的功能模块 后端 ​ 根据用户权限使用API 基于RBAC dome 案例分析并实现后台无状态安全校验实现​ 底层数据 ​ 问题：数据如何存储便于后期的使用与管理。 ​ 方案：使用RBAC管理模型，根据用户、角色、权限三种概念。来实现数据的访问、使用等相关权限的合理分配。 ​ 数据传输 ​ 问题：数据传输依托于互联网，如何保证其安全。 ​ 方案：认证+校验 ​ 认证 ：依托web认证机制中的方案可实现 ​ 校验 ： ​ 实现逻辑 在请求到达controller 时拦截并校验。 ​ 实现方式有：filter intercept aop 他们三者的关系如下图 ​ ​ 本次案例使用的的过滤方式为，filter 过滤一些不存在token的请求，由intercept拦截校验接下来的数据信息。 后台有状态安全校验实现]]></content>
  </entry>
  <entry>
    <title><![CDATA[单词库]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2F%E5%8D%95%E8%AF%8D%E5%BA%93%2F</url>
    <content type="text"><![CDATA[operating 有道详情 kernel 有道详情 enterprise 有道详情 movie 电影 有道详情 advanced 有道详情 assume 有道详情 echo 有道详情 touch 有道详情 perusal 有道详情 block 有道详情 between 有道详情 owner 有道详情]]></content>
  </entry>
  <entry>
    <title><![CDATA[web认证机制]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2Fweb_%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[HTTP Basic Auth​ HTTP Basic Auth简单点说明就是每次请求API时都提供用户的username和password，简言之，Basic Auth是配合RESTful API 使用的最简单的认证方式，只需提供用户名密码即可，但由于有把用户名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的RESTful API时，尽量避免采用HTTP Basic Auth 个人观点：简单易于实现，安全性低 Cookie Auth​ Cookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time使cookie在一定时间内有效 个人观点：可以使应用认证有状态性，要想保证认证的有状态性使得服务器的session频繁创建，会对服务器的开销增加压力。安全性：一般 OAuth​ OAuth（开放授权）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一web服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。 OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的第三方系统（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容这种基于OAuth的认证机制适用于个人消者类的互联网产品，如社交类APP等应用，但是不太适合拥有自有认证权限管理的企业应用。 个人观点：安全性高。OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容这种基于OAuth的认证机制适用于个人消者类的互联网产品，如社交类APP等应用，但是不太适合拥有自有认证权限管理的企业应用。 Token Auth使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的： 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据 Token Auth的优点 ​ 支持跨域访问: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输. 无状态(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息. 更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可. 去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可. 更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。 CSRF:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。性能: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算 的Token验证和解析要费时得多. 不需要为登录页面做特殊处理: 如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理. 基于标准化:你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby,Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）.]]></content>
  </entry>
  <entry>
    <title><![CDATA[python-入门篇.md]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2Fpython-%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[python的来源​ python是著名的“Guido van Rossum”在1989年圣诞节期间开发的编程语言 现在，全世界差不多有600多种编程语言，但流行的编程语言也就那么20来种。如果你听说过TIOBE排行榜，你就能知道编程语言的大致流行程度。这是最近10年最常用的10种编程语言的变化图： 总的来说，这几种编程语言各有千秋。C语言是可以用来编写操作系统的贴近硬件的语言，所以，C语言适合开发那些追求运行速度、充分发挥硬件性能的程序。而Python是用来编写应用程序的高级编程语言。 当你用一种语言开始作真正的软件开发时，你除了编写代码外，还需要很多基本的已经写好的现成的东西，来帮助你加快开发进度。比如说，要编写一个电子邮件客户端，如果先从最底层开始编写网络协议相关的代码，那估计一年半载也开发不出来。高级编程语言通常都会提供一个比较完善的基础代码库，让你能直接调用，比如，针对电子邮件协议的SMTP库，针对桌面环境的GUI库，在这些已有的代码库的基础上开发，一个电子邮件客户端几天就能开发出来。 Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（batteries included）”。用Python开发，许多功能不必从零编写，直接使用现成的即可。 除了内置的库外，Python还有大量的第三方库，也就是别人开发的，供你直接使用的东西。当然，如果你开发的代码通过很好的封装，也可以作为第三方库给别人使用。 许多大型网站就是用Python开发的，例如YouTube、Instagram，还有国内的豆瓣。很多大公司，包括Google、Yahoo等，甚至NASA（美国航空航天局）都大量地使用Python。 python 的优点 龟叔给Python的定位是“优雅”、“明确”、“简单”，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。 总的来说，Python的哲学就是简单优雅，尽量写容易看明白的代码，尽量写少的代码。如果一个资深程序员向你炫耀他写的晦涩难懂、动不动就几万行的代码，你可以尽情地嘲笑他。 那Python适合开发哪些类型的应用呢？ 首选是网络应用，包括网站、后台服务等等； 其次是许多日常需要的小工具，包括系统管理员需要的脚本任务等等； 另外就是把其他语言开发的程序再包装起来，方便使用。 ##Python的缺点 任何编程语言都有缺点，Python也不例外。优点说过了，那Python有哪些缺点呢？ 第一个缺点就是运行速度慢，和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。 但是大量的应用程序不需要这么快的运行速度，因为用户根本感觉不出来。例如开发一个下载MP3的网络应用程序，C程序的运行时间需要0.001秒，而Python程序的运行时间需要0.1秒，慢了100倍，但由于网络更慢，需要等待1秒，你想，用户能感觉到1.001秒和1.1秒的区别吗？这就好比F1赛车和普通的出租车在北京三环路上行驶的道理一样，虽然F1赛车理论时速高达400公里，但由于三环路堵车的时速只有20公里，因此，作为乘客，你感觉的时速永远是20公里。 python交互模式 使用当前系统的命令模式，输入python3即可进入交互模式，输入exit()可退出python交互式模式。 交互式模式可以直接显示代码运行的结果。但是之前输入的代码退出交互式模式后不能存到硬盘中 命令行执行.py文件 命令行模式下，进入要执行的.py文件同目录下，输入python3 文件名即可运行]]></content>
  </entry>
  <entry>
    <title><![CDATA[spring4]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2Fspring4%2F</url>
    <content type="text"><![CDATA[springMVC​ 运行流程图 dispatcher Servlet 前端控制器（front Controller）核心 快速尝鲜： 基于spring 搭建spring mvc1.将DispatcherServlet 注册到web容器中 在 Servlet 3. 0 环境 中， 容器 会在 类 路径 中 查找 实现 javax. servlet. ServletContainerInitializer 接口 的 类， 如果 能 发现 的 话， 就会 用 它来 配置 Servlet 容器。 ​ Spring 提供 了 这个 接口 的 实现， 名为 SpringServletContainerInitializer。 12@HandlesTypes(&#123;WebApplicationInitializer.class&#125;)public class SpringServletContainerInitializer implements ServletContainerInitializer ​ 其中的HandlesTypes 是什么？ 1.Tomcat的主机容器在添加子容器时，会通过解析.xml并通过类加载器加载@HandlesTypes注解的类 2.读取@HandlesTypes注解值值。并放入ServletContainerInitializers对应的Set集合中 3.在ApplicationContext内部启动时会通知ServletContainerInitializers的onStart方法（）。这个onStart方法的第一个参数就是@HandlesTypes注解的值值指定的类集合 4.在Spring应用中，对ServletContainerInitializers的实现就是SpringServletContainerInitializer，注解指定的类就是WebApplicationInitializer。 通过上面解读过程我们知道，如果要想使用基于servlet3.0支持注解申明servlet。使用spring框架时的关注点就在WebApplicationInitializer接口中。 如果个人有能力或者有兴趣的化可以自己通过实现WebApplicationInitializer接口来注册servlet。但是一般我们只需要使用spring进行过一些封装的AbstractAnnotationConfigDispatcherServletInitializer抽象类即可。 123456789101112131415161718192021222324252627282930313233343536373839package org.springframework.web.servlet.support;import org.springframework.lang.Nullable;import org.springframework.util.ObjectUtils;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;public abstract class AbstractAnnotationConfigDispatcherServletInitializer extends AbstractDispatcherServletInitializer &#123; public AbstractAnnotationConfigDispatcherServletInitializer() &#123; &#125; @Nullable protected WebApplicationContext createRootApplicationContext() &#123; Class&lt;?&gt;[] configClasses = this.getRootConfigClasses(); if (!ObjectUtils.isEmpty(configClasses)) &#123; AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext(); context.register(configClasses); return context; &#125; else &#123; return null; &#125; &#125; protected WebApplicationContext createServletApplicationContext() &#123; AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext(); Class&lt;?&gt;[] configClasses = this.getServletConfigClasses(); if (!ObjectUtils.isEmpty(configClasses)) &#123; context.register(configClasses); &#125; return context; &#125; @Nullable protected abstract Class&lt;?&gt;[] getRootConfigClasses(); @Nullable protected abstract Class&lt;?&gt;[] getServletConfigClasses();&#125; 使用 AbstractAnnotationConfigDispatcherServletInitializer注册容器并初始化上下文 123456789101112131415161718192021222324package com.healthengine.medpro.common.config;import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;public class ServletConfigAchieve extends AbstractAnnotationConfigDispatcherServletInitializer &#123; //用来配置ContextLoaderListener 的上下文 @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[0]; &#125; //用来配置springMvc 中Dispatcher Servlet 上下文 @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[0]; &#125; //配置容器请求的映射路径 @Override protected String[] getServletMappings() &#123; return new String[0]; &#125;&#125; 配置Filter方式1：基于Disparther Servlet 配置​ 123456789101112131415161718192021222324252627282930313233343536package com.healthengine.medpro.common.config;import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;import javax.servlet.Filter;import javax.servlet.MultipartConfigElement;import javax.servlet.ServletContext;import javax.servlet.ServletRegistration;public class ServletConfigAchieve extends AbstractAnnotationConfigDispatcherServletInitializer &#123; //用来配置ContextLoaderListener 的上下文 @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[0]; &#125; //用来配置springMvc 中Dispatcher Servlet 上下文 @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[0]; &#125; //配置容器请求的映射路径 @Override protected String[] getServletMappings() &#123; return new String[0]; &#125; //设置filter @Override protected Filter[] getServletFilters() &#123; return //自己定义的filter 类（数组） &#125;&#125; 方式2：自行实现处理Multipart格式的内容信息​ 1.配置类 12345678910111213141516171819202122232425262728293031323334353637package com.healthengine.medpro.common.config;import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;import javax.servlet.Filter;import javax.servlet.MultipartConfigElement;import javax.servlet.ServletContext;import javax.servlet.ServletRegistration;public class ServletConfigAchieve extends AbstractAnnotationConfigDispatcherServletInitializer &#123; //用来配置ContextLoaderListener 的上下文 @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[0]; &#125; //用来配置springMvc 中Dispatcher Servlet 上下文 @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[0]; &#125; //配置容器请求的映射路径 @Override protected String[] getServletMappings() &#123; return new String[0]; &#125; //自定义注册 @Override protected void customizeRegistration(ServletRegistration.Dynamic registration) &#123; //Multipart 配置设置 registration.setMultipartConfig(new MultipartConfigElement("temp/medpro/")); &#125;&#125; 2.配置MultipartResolver Bean MultipartResolver 是springframework.web提供用于处理Multipart的接口规范 ​ 1.CommonsMultipartResolver： 使用 Jakarta Commons FileUpload 解析 multipart 请求； ​ 2.StandardServletMultipartResolver： 依赖于 Servlet 3. 0 对 multipart 请求 的 支持（ 始于 Spring 3. 1）。 123@Bean public MultipartResolver multipartResolver() throws IOException &#123; return new StandardServletMultipartResolver();&#125; 3.测试代码 12345678@GetMappingpublic void multipartHandle(MultipartFile multipartFile) throws IOException &#123; String originalFilename = multipartFile.getOriginalFilename(); byte[] bytes = multipartFile.getBytes(); String contentType = multipartFile.getContentType(); InputStream inputStream = multipartFile.getInputStream(); String name = multipartFile.getName();&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[springBoot-MultipartAutoConfiguration]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2FSpringBoot-MultipartAutoConfiguration%2F</url>
    <content type="text"><![CDATA[前提：​ 今天本人想实现一个文件上传的功能。 ​ 文件上传的难点在以什么样的传输格式上传文件。 ​ 一般 表单 提交 所 形成 的 请求 结果是 很 简单 的， 就是 以“&amp;” 符 分割 的 多个 name- value 对。 例如 1firstName= Charles&amp; lastName= Xavier&amp; email= professorx% 40xmen. org &amp;username= professorx&amp; password= letmein01 尽管 这种 编码 形式 很 简单， 并且 对于 典型的 基于 文本 的 表单 提交 也 足够 满足要求， 但是 对于 传送 二进制 数据， 如上 传 图片等文件， 就 显得 力不从心 了。 ​ 那么对应二进制数据的上传依托Http请求要怎么去实现呢？ ​ multipart 格式 的 数据 会 将 一个 表单 拆分 为多 个 部分（ part）， 每个 部分 对应 一个 输入 域。 在 一般 的 表单 输入 域 中， 它 所 对应 的 部分 中会 放置 文本 型 数据， 但是 如果 上传 文件 的 话， 它 所 对应 的 部分 可以 是 二进制， 下面 展现 了 multipart 的 请求 体： 123456------WebKitFormBoundaryqgkaBn8IHJCuNmiW Content- Disposition: form- data; name=&quot; firstName&quot; Charles ------WebKitFormBoundaryqgkaBn8IHJCuNmiW Content- Disposition: form- data; name=&quot; lastName&quot; Xavier ------WebKitFormBoundaryqgkaBn8IHJCuNmiW Content- Disposition: form- data; name=&quot; email&quot; charles@ xmen. com ------WebKitFormBoundaryqgkaBn8IHJCuNmiW Content- Disposition: form- data; name=&quot; username&quot; professorx ------WebKitFormBoundaryqgkaBn8IHJCuNmiW Content- Disposition: form- data; name=&quot; password&quot; letmein01 ------WebKitFormBoundaryqgkaBn8IHJCuNmiW Content- Disposition: form- data; name=&quot; profilePicture&quot;; filename=&quot; me. jpg&quot; Content- Type: image/ jpeg [[ Binary image data goes here ]] ------WebKitFormBoundaryqgkaBn8IHJCuNmiW-- 在 这个 multipart 的 请求 中， 我们 可以 看到 profilePicture 部分 与其 他 部分 明显 不同。 除了 其他 内容 以外， 它 还有 自己的 Content- Type 头， 表明 它是 一个 JPEG 图片。 尽管 不一定 那么 明显， 但 profilePicture 部分 的 请求 体 是 二进制 数据， 而 不是 简单 的 文本。 尽管 multipart 请求 看起来 很复杂， 但通过 Spring MVC 处理 它们 却 很容易。 在 编写 控制器 方法 处理 文件 上传 之前， 我们 必须 要 配置 一个 multipart 解析 器， 通过 它来 告诉 DispatcherServlet 该 如何 读取 multipart 请求。 ​ spring mvc 对multipart 解析器定义了 multipart Resolver 接口规范。 并提供了CommonsMultipartResolver： 使用 Jakarta Commons FileUpload 解析 multipart 请求的实现和StandardServletMultipartResolver： 依赖于 Servlet 3. 0 对 multipart 请求 的 支持（ 始于 Spring 3. 1）。 使用springboot 如何操作multipart Resolver 接下来请看MultipartAutoConfiguration装配类都做了什么 MultipartAutoConfiguration]]></content>
  </entry>
  <entry>
    <title><![CDATA[modelAttribute注解]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2FmodelAttribute%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[@modelAttributemoelAttribute 是springmvc提供的注解。 1.运用在参数上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用； 2.运用在方法上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中； 运用在方法上实现案例，抽取request 和response、modelMap将其注入在baseController中。beseController12345678910111213141516171819import lombok.Data;import org.springframework.web.bind.annotation.ModelAttribute;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@Datapublic class BaseController &#123; protected HttpServletRequest request; protected HttpServletResponse response; @ModelAttribute public void initParams(HttpServletResponse response,HttpServletRequest request)&#123; this.request = request; this.response = response; &#125;&#125; 基础controller 1234567891011121314151617181920import com.healthengine.medpro.common.controller.BaseController;import org.springframework.web.bind.annotation.CrossOrigin;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping("/file")@CrossOriginpublic class FileBaseController extends BaseController &#123; @GetMapping("/modelAttributeTest") public String modelAttributeTest()&#123; request.getAuthType(); response.getStatus(); return "OK"; &#125;&#125; 注意：其中的response是多例线程不安全的，如果想要时其线程安全可以使用ThreadLocal]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 参数校验]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2Fspringboot_param_validation%2F</url>
    <content type="text"><![CDATA[解决方案​JSR-303 实现方案+JSR-349Bean 验证 JSR-303的实现使用hibernate的实现 @Valid注解 JSR-349Bean 验证的实现使用spring提供的@Validated注解 校验案例本案例的环境为，springboot2.0.5.RELEASE 基础代码实现： 导入坐标 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 此坐标包含了@Valid 和@Validated 创建入口启动类 1234567891011121314151617181920212223242526package com.healthengine.department;import com.healthengine.medpro.common.utils.IdWorker;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.domain.EntityScan;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;@SpringBootApplication()@ComponentScan("com.healthengine.department")@EntityScan("com.healthengine.medpro.department")@EnableJpaRepositories(basePackages = "com.healthengine.department.dao")public class DepartmentApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(DepartmentApplication.class,args); &#125; //雪花算法用来生成id @Bean public IdWorker idWorker()&#123; return new IdWorker(1,1); &#125;&#125; 注意：此入口启动类要放在Controller包的同级目录下，因为@SpringBootApplication注解会扫描同级目录及其子目录。此类只放在java目录下是不对的。要放在Java目录下的下级目录下 （正确目录格式） (错误目录格式) 配置文件设置 1234567891011121314server: port: 9002spring: application: name: medpro-department datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/medprotwo username: xxxx password: xxxx jpa: database: mysql show-sql: true open-in-view: true 创建controller 案例使用到的java Bean 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.healthengine.medpro.company;import com.healthengine.medpro.department.Department;import lombok.Data;import javax.persistence.Entity;import javax.persistence.Id;import javax.persistence.Table;import javax.validation.Valid;import javax.validation.constraints.NotBlank;import javax.validation.constraints.NotEmpty;import java.io.Serializable;import java.util.Date;import java.util.List;@Entity@Table(name="co_company")@Datapublic class Company implements Serializable &#123; private static final long serialVersionUID = 594829320797158219L; @Id private String id; @NotBlank(message = "用户名不能为空！",groups = &#123;AddDepartment.class&#125;) private String name; private String managerId; @NotBlank(message = "版本号不能为空",groups = &#123;AddDepartment.class&#125;) private String version; private Date renewalDate; private Date expirationDate; private String companyArea; private String companyAddress; private String businessLicenseId; private String legalRepresentative; private String companyPhone; private String mailbox; private String companySize; private String industry; private String remarks; private String auditState; private Integer state; private Double balance; private Date createTime; /** * 部门列表 */ @Valid //开启嵌套校验 @NotEmpty(groups = &#123;AddDepartment.class&#125;,message = "部门列表不能为空！") private List&lt;Department&gt; departmentList;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.healthengine.medpro.department;import lombok.Data;import javax.persistence.Entity;import javax.persistence.Id;import javax.persistence.Table;import javax.validation.constraints.NotBlank;import java.util.Date;@Entity@Table(name = "co_department")@Datapublic class Department &#123; /** * id */ @Id @NotBlank(message = "id不能为空") private String id; /** * 父id */ private String pid; /** * 企业id */ private String companyId; /** * 部门名称 */ private String name; /** * 部门编码，同级部门不可重复 */ private String code; /** * 负责人id */ private String managerId; /** * 负责人名称 */ private String manager; /** * 介绍 */ private String introduce; /** * 创建时间 */ private Date create;&#125; 1234package com.healthengine.medpro.company;public interface AddDepartment &#123;&#125; 基础校验（快速尝鲜）12345//对象参数校验@PostMapping("/test1")public Result test1(@Validated @RequestBody Company company)&#123; return new Result(ResultCode.SUCCESS);&#125; 单个参数校验 在类中加入@Validated 1234@RestController()@RequestMapping("/validation")@Validatedpublic class ValidationTest &#123; 方法上对参数使用校验注解 1234@GetMapping("/test2")public Result test2(@NotNull(message = "年齡不能為空") Integer age)&#123; return new Result(ResultCode.SUCCESS);&#125; 分组校验 创建分组标识接口 12public interface AddDepartment &#123;&#125; 在要校验的字段上使用校验注解并添加groups属性 12@NotBlank(message = "用户名不能为空！",groups = &#123;AddDepartment.class&#125;)private String name; 在方法上使用校验 1234@PostMapping("/test3")public Result test3(@Validated(AddDepartment.class) @RequestBody Company company)&#123; return new Result(ResultCode.SUCCESS);&#125; 嵌套属性校验 在要需要嵌套校验的对象上添加@valid 123456/** * 部门列表 */@Valid //开启嵌套校验@NotEmpty(groups = &#123;AddDepartment.class&#125;,message = "部门列表不能为空！")private List&lt;Department&gt; departmentList; 在方法上使用 1234@PostMapping("/test4")public Result test4(@Valid @Validated(AddDepartment.class) @RequestBody Company company)&#123; return new Result(ResultCode.SUCCESS);&#125; 非嵌套属性校验 1234@PostMapping("/test4")public Result test4(@Validated(AddDepartment.class) @RequestBody Company company)&#123; return new Result(ResultCode.SUCCESS);&#125; 自定义校验规则校验异常类全局处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.healthengine.department.exception;import com.healthengine.medpro.common.entity.Result;import org.springframework.http.converter.HttpMessageConversionException;import org.springframework.validation.BindingResult;import org.springframework.validation.FieldError;import org.springframework.validation.ObjectError;import org.springframework.web.bind.MethodArgumentNotValidException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestControllerAdvice;import javax.validation.ConstraintViolation;import javax.validation.ConstraintViolationException;import java.util.List;@RestControllerAdvicepublic class GlobalExceptionHandler &#123; /** * 单个参数异常抛出 */ @ExceptionHandler(ConstraintViolationException.class) public Result constraintViolationException(ConstraintViolationException ce)&#123; StringBuilder sb = new StringBuilder(); for(ConstraintViolation violation:ce.getConstraintViolations())&#123; sb.append("异常信息： "+violation.getMessage()); &#125; return new Result(500,sb.toString(),false); &#125; /** * 实体类异常抛出 * @param exception * @return */ @ExceptionHandler(MethodArgumentNotValidException.class) public Result validationBodyException(MethodArgumentNotValidException exception)&#123; StringBuilder sb = new StringBuilder(); BindingResult result = exception.getBindingResult(); if (result.hasErrors()) &#123; List&lt;ObjectError&gt; errors = result.getAllErrors(); errors.forEach(p -&gt;&#123; FieldError fieldError = (FieldError) p; sb.append("异常字段："+fieldError.getField()+" 异常信息："+fieldError.getDefaultMessage()).append(System.lineSeparator()); &#125;); &#125; return new Result(500,sb.toString(),false); &#125; /** * 参数类型转换错误 * * @param exception 错误 * @return 错误信息 */ @ExceptionHandler(HttpMessageConversionException.class) public Result parameterTypeException(HttpMessageConversionException exception)&#123; return new Result(500,exception.getCause().getLocalizedMessage(),false); &#125;&#125; 案例后发现的缺陷 使用hibernate参数校验注解后发现，使用Spring jpa 存入数据时也会产生校验。 目前解决方案，使用注解时为其分组。这样可以解决存入数据库时的校验，当存入数据库前，想做校验需要自己手动编写逻辑。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux-用户用户组篇]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2FLinux-%E7%94%A8%E6%88%B7%E7%94%A8%E6%88%B7%E7%BB%84%E7%AF%87%2F</url>
    <content type="text"><![CDATA[用户和用户组管理如何去做用户管理 越是对服务器安全性要求高的服务器，越需要建立合理的用户权限等级制度和服务器操作规范。 在Linux中主要是通过用户配置文件来查看和修改用户信息。 用户配置文件用户信息文件/etc/passwd这个 文件 中 保存 的 就是 系统 中 所有 的 用户 和 用户 的 主要 信息。 文档解读： ​ 文件中一行代表一个用户，每行分为7个字段，下面解释下这7个字段分别附有什么含有 ​ 1.用户名称 ​ 2.密码标识 ，具体密码信息需要进入/etc/shadow查看，并且密码采用SHA512散列加密算法. ​ 3.uid 用户的id标识 0表示超级用户，而且前499已经被系统占用 ​ 4.gid 表示用户组id标识 这里指的是用户的初始组 ​ 5.用户说明信息 ​ 6.用户的home 目录 ​ 7.用户登陆后所能执行的shell脚本 影子文件/etc/shadow​ 文件中存储了关于用户的密码的一些信息 ​ 同样每行表示每个用户的密码信息，每行分为6个字段 ​ 1.用户名称 ​ 2.密码 经过加密后的，被锁定的密码前会加入！！ ​ 3.密码最后一次修改日期 ​ 4.密码的两次修改时间间隔（和3做比较） ​ 5.密码的有效期（和3做比较） ​ 6.密码修改到期前的警告天数（和5做比较） 组织信息文件/etc/group和组密码文件/etc/gshadow​ /etc/group 存储了信息用户组的信息 ​ /etc/gshadow 存储了用户组管理员以及密码的一些信息 ​ 具体详情 可查阅 man 5 gshadow 用户管理相关的文件​ 1.用户的家目录 ​ /home/用户名称 或/root/ ​ 2.用户邮箱目录 ​ /var/spool/mail/用户名称 ​ 3.用户模板目录 ​ /etc/skel 用户管理命令​ 添加用户 useradd [选项] 用户名 ​ 指定修改用户密码 passwd [选项] 用户名 ​ 修改用户信息 usermod [选项] 用户名 ​ 删除用户 userdel [选项] 用户名 ​ 切换用户 su [选项] 用户名 ​ “-” 切换后使用切换用户的环境 ​ “-c” 仅执行一次命令 用户组管理命令​ 添加用户组 groupadd [选项] 组名 ​ 修改用户组 groupmod [选项] 组名 ​ 删除用户组 groupdel [选项] 组名 ​ 把用户加入组中 gpasswd 选项 组名 ​ “-a” 用户名 把用户加入组 ​ “-d”用户名 把用户从组中删除]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux-软件管理篇]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2FLinux-%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E7%AF%87%2F</url>
    <content type="text"><![CDATA[软件包管理简介 总结：Linux 软件安装包分为 ​ 源码包安装 ​ 优点：可控性高，可以自己查看或修改程序的源代码。安装后软件的执行效率高，比厂商提供的二进制包高5% ​ 缺点：需要自己手动编译源码后才可安装，操作难度高。 ​ 二进制包安装 ​ 优点：安装速度块，由于使用的是厂商编译过的二进制包，所有省去了自己对源码的手动编译。直接安装即可。 ​ 缺点：不可以直接查看程序的源代码。安装后软件的执行效率比自己手动编译的的软件包慢5%。并且安装软件存在依赖性问题 ​ 脚本包安装 ​ 优点：脚本包安装类似与Windows下的软件安装界面。它是源码包安装和二进制包安装的中和方式。运行脚本后，脚本会帮助你去编译软件的源代码并安装。 ​ 缺点：单独编写软件脚本 RPM 包管理（二进制包）rpm的命名规则 包名或包全名例子 ​ httpd-2.2.15-15.el6.centos.1.i686.rpm ​ 包名 : httpd ​ 包全名 : httpd-2.2.15-15.el6.centos.1.i686.rpm rpm的依赖性 总结： ​ rpm包的命名规则： ​ 软件包名-软件版本-软件的发布次数.适合的Linux平台.适合的硬件平台.rpm包扩展名 ​ rpm依赖性： ​ 树形依赖 ：如安装软件包a时发现需要安装软件包b,而安装软件包b又需要软件包c. 解决上述的树形依赖问题的方法：先安装软件包c然后依次安装软件包b,软件包a ​ 环形依赖：如安装软件包a时发现需要安装软件包b,而安装软件包b需要安装软件包c,但是安装软件包c却需要软件包a,这样就形成了环形的依赖结构。 环形依赖解决方案：同时安装包a,b,c即可解决此问题。 ​ 模块依赖：模块依赖和软件包依赖不同之处在于，模块所依赖的包，有可能不在系统安装包内。 解决方案：进入 www.rpmfind.net 搜索需要的模块包 包全名和包名的使用介绍 rpm安装升级卸载 总结： 什么时候使用包全名或包名 包全名，在软件没有安装并需要使用的情况下。如软件的安装或更新 包名，在软件已经被安装的情况下。如软件的卸载 rpm实现包安装 在进入安装包目录的情况下 1rpm -ivh 需要安装的包全名（need install package name） rpm实现包升级 在进入安装包目录的情况下 1rpm -Uvh 需要更新的包全名（need update package name） rpm实现包卸载 1rpm -e 需要卸载的包名 （need deleter package name） rpm查询查询是否安装 安装包的详细信息查询 RPM的安装位置查询 根据文件名查询rpm包 查询安装包的依赖性 总结： rpm查询 查询是否安装 1rpm -q 包名 （package name） 系统已经安装的所有安装包 1rpm -qa 安装包的详细信息查询 1rpm -qi 包名 （package name） RPM的安装位置查询 1rpm -ql 包名 （package name） 获取给定文件名属于哪个RPM 1rpm -qf 文件名 （file name） 查询RPM的依赖性 1rpm -qR 包名（package name） rpm包校验 rpm包提取 总结： rpm 包校验 rpm 包提取 /usr/bin/ls 文件提取 1rpm2cpio /mnt/cdrom/Packages/coreutils-8.22-23.el7.x86_64.rpm | cpio -idv ./usr/bin/ls yum在线管理-IP地址配置使用 red heat 的setup命令 本人使用的是contos7，发现使用setup后没有网络配置项，在网上查他们说需要使用yum去安装setup的一些功能项。（未做测试） 那我是怎么配置使自己的系统可以访问外网的呢？我直接修改改network 的配置文件（/etc/sysconfig/network-scripts/ifcfg-ens33）文件，将ONBOOT 设为 true，然后就可以上网了。 网络yum源本人安装的contos已经默认安装并配置了yum源，下面是有关yum源的一些配置属性的解释 使用镜像（mirror） 下载镜像repo配置文件 http://mirrors.aliyun.com/repo/Centos-7.repo 将原repo文件备份为 repo.backup 将下载好的Centos-7.repo 移动到/etc/yum.repos.d/下并改名为CentOS-Base.repo 总结： ​ 1.系统上网配置，使用setup 下的网络配置，配置ip 子网掩码 网关 CSDN 保存即可，设置后记得修改network 的网络配置文件，将ONBOOT 设为true， 之后service network restart 重启即可，然后使用ping命令测试系统是否联网 ​ 2.yum 配置使用contos默认即可 ​ 3.yum mirror设置，上述配置即可 yum命令查询 安装 ​ 注意 当更新时，没有指定包名，yum会更新整个系统中所有软件甚至内核也会被升级。 卸载 yum软件组使用 总结： ​ 系统安装原则：最小化安装，用需要用什么软件，就安装什么软件。最好不要卸载软件。更新软件时要注意指定软件名，不然就会更新整个系统（包括内核）。安装时-y 命令要在安装熟练时使用，一般慎用 yum光盘源搭建 源码包安装管理源码包和rpm包的区别​ 安装之前的区别：概念上的区别 ​ 安装之后的区别：安装位置不同 ​ 由于源码包和rpm 安装包的安装位置不同导致了，应用的启动方式选择面不同 ​ rpm 包安装的软件可以 使用 service 去执行命令，也可以使用 绝对路径 + 命令的方法操作 ​ 源码包 只能通过 绝对路径 + 命令的方法操作 ​ service 操作软件 1service tomcat start ​ 绝对路径+命令方式 1/usr/bin/tomcat start 源码包安装过程 源码包安装流程 下载源码包文件 解压源码包文件到 /usr/local/ 源码文件名 下 进入解压目录阅读 INSTALL 文档，查看如何安装。 使用make 命令编译源码 使用make install 命令安装 INSTALL安装说明文档 README使用说明 make 编译 make install 编译安装 make clean 清空编译 ###脚本安装包]]></content>
  </entry>
  <entry>
    <title><![CDATA[jodconverter]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2Fjodconverter%2F</url>
    <content type="text"><![CDATA[jodconverter入门​ 概念： ​ jodconverter的全称是 java Document Converter ,它可以在不同的办公室格式之间转换文档。它利用了Apache OpenOffice或LibreOffice， ​ JODConverter自动执行OpenOffice / LibreOffice支持的所有转换。支持的转化包括： 文件类型 输入格式 输出格式 文本 DOC，DOCX，ODT，OTT，RTF，TEXT DOC，DOCX，HTML，ODT，OTT，PDF，PNG，RTF，TXT 电子表格 CSV，ODS，OTS，TSV，XLS，XLSX CSV，HTML，ODS，OTS，PDF，PNG，TSV，XLS，XLSX 介绍 ODP，OTP，PPT，PPTX HTML，ODP，OTP，PDF，PNG，PPT，PPTX，SWF 画画 ODG，OTG ODG，OTG，PDF，PNG，SWF 其他 HTML DOC，DOCX，HTML，ODT，OTT，PDF，PNG，RTF，TXT 系统要求要使用JODConverter，您需要： Java运行时环境1.7或更高版本。 Apache OpenOffice或LibreOffice ; 通常建议使用最新的稳定版本。 任何可用于Java和Apache OpenOffice / LibreOffice的操作系统（Windows，Linux，Mac OS X，Solaris，FreeBSD等）。请参阅您计划用于操作系统要求的OOo分发的系统要求。 Apache OpenOffice 系统要求。 LibreOffice 系统要求。 要用作Web应用程序/ Web服务，您还需要一个servlet容器，例如Apache Tomcat。 组件（配置）officeHome此属性设置将用于执行文档转换的办公室安装的office主目录。 processManager当JODConverter需要处理已启动的办公流程时，将使用流程管理器。当JODConverter启动办公室进程时，它必须检索已启动进程的PID，以便以后能够在需要时终止它。 默认值：默认情况下，JODConverter将根据运行JODConverter的操作系统尝试查找最佳进程管理器。但是，如果在类路径中找到，则可以使用任何实现ProcessManager接口的进程管理器。 只有在启用了processManager后才可以使用jodconverter进行文件转换 其余属性请查看此链接https://github.com/sbraconnier/jodconverter/wiki/Configuration 官方Java中使用dome12345678910111213141516171819202122File inputFile = new File("document.doc");File outputFile = new File("document.pdf");// Create an office manager using the default configuration.// The default port is 2002. Note that when an office manager// is installed, it will be the one used by default when// a converter is created.final LocalOfficeManager officeManager = LocalOfficeManager.install(); try &#123; // Start an office process and connect to the started instance (on port 2002). officeManager.start(); // Convert JodConverter .convert(inputFile) .to(outputFile) .execute();&#125; finally &#123; // Stop the office process OfficeUtils.stopQuietly(officeManager);&#125; 本人整合springboot使用]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux-初识]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2FLinux-%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Linux简介Linux 学习方法 坚持使用命令行 遇到问题，不要马上问别人。先自行寻找答案 解决问题的的智慧： 帮助、文档、示例、查找 忘掉Windows思维方式 计划、坚持、专注、练习 Linux系统分区1.什么是磁盘分区： ​ 磁盘分区是使用分区编辑器（partition editor）在磁盘上划分几个逻辑部分，碟片一但划分成数个分区（partition）不同类的目录与文件可以存储进不同的分区。 example： 划分柜子，将一个大柜子划分为3个小柜子。这样可以方便使用者。 分区类型： 主分区：最多只能有4个（一块硬盘的前提条件下） 扩展分区： ​ 最多只能有1个（一块硬盘的前提条件下） ​ 主分区加扩展分区最多有4个（一块硬盘的前提条件下） ​ 不能写入数据，只能包含逻辑分区（一块硬盘的前提条件下） 逻辑分区 2.格式化 ​ 什么是格式化： ​ 格式化 （高级格式化）又称逻辑格式化。它是指根据用户选的的文件系统（FAT16、FAT32、NTFS、EXT3、EXT2、EXT4等）在磁盘的特定区域写入特定数据，在分区中划出一片用于存放文件的分配表、目录表等用于文件管理的磁盘空间。 Linux默认的文件系统：EXT4 关键词： ​ block ​ inode 号 3.硬件设备文件名 4.分区设备文件名 /dev/hda1 代表什么？ /dev 代表了这是系统的设备文件的根目录，hda1中hda表示用户使用的是IDE硬盘，1表示第几个分区（数字标识） IDE硬盘接口： 理论每秒传输133MB SCSI硬盘接口： 理论每秒传输200MB SATA硬盘接口： sata3代理论每秒传输500MB 5.挂载 ​ 必须分区 ​ /(根分区) ​ swap（交换分区、内存2倍） ​ 推荐分区 ​ /boot（启动分区，200MB） 文件系统结构 系统分区流程 ​ 分区 》格式化 》为分区指定设备文件名 》 挂载 密码原则：​ 复杂性 ​ 八位字符以上、大小写字母、数字、符号 ​ 不是单词 ​ 不是用户的相关信息 ​ 易记性 ​ 时效性 安装日志​ /root/install.log 存储了安装在系统中的软件包及其版本信息 ​ /root/install.log.syslog 存储了安装过程中留下来的事件信息 ​ /root/anaconda-ks.cfg 以Kickstrat配置文件的格式记录安装过程中设置的选项信息 linux 关于IP操作的一些命令ifconfig ：查看系统网卡信息 ifconfig eth0 [ip 地址] :临时配置网卡，系统重启后失效 Linux 注意事项​ 严格区分大小写 ​ Linux中所有的内容都是以文件形式保存，包括硬件 ​ 硬盘文件是/dev/sd[a-p] ​ 光盘文件是/dev/sr0等 ​ Linux不靠扩展名区分文件类型 ​ Linux所有存储设备都必须挂载之后用户才能使用,包括硬盘、U盘和光盘 ​ windows下的程序不能直接在Linux中安装和运行 服务器管理和维护建议服务器最好重启操作，不要关机操作 重启时应该关闭服务器 不要在服务器访问高峰运行高负载命令 远程配置防火墙时不要把自己踢出服务器 指定合理的密码规范并定期更新 合理分配权限 定期备份重要数据和日志]]></content>
  </entry>
  <entry>
    <title><![CDATA[jwt]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2Fjwt%2F</url>
    <content type="text"><![CDATA[什么是jwt​ JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。在Java世界中通过JJWT实现JWT创建和验证。 jjwt快速尝鲜 引入坐标 12345&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.6.0&lt;/version&gt;&lt;/dependency&gt; 上面使用的坐标是基于apache2.0 下的jwt实现 使用并测试 生成token 12345678JwtBuilder jwt = Jwts.builder() .setId("123") .setSubject("老王") .setIssuedAt(new Date())//发布时间 .setExpiration(new Date(System.currentTimeMillis()+6000))//到期时间 .signWith(SignatureAlgorithm.HS384,"XXXXX");//设置密钥String compact = jwt.compact();//签约生成tokenSystem.out.println(compact); 解析token 1234Claims cla = Jwts.parser() .setSigningKey("XXXXX")//设置密钥 .parseClaimsJws(key)//设置token .getBody(); 当token认证失败时会抛出ExpiredJwtException异常 自定义claims 生成 1234567891011//为了方便测试，我们将过期时间设置为1分钟long now = System.currentTimeMillis();//当前时间long exp = now + 1000*60;//过期时间为1分钟JwtBuilder builder= Jwts.builder().setId("888").setSubject("小白").setIssuedAt(new Date()).signWith(SignatureAlgorithm.HS256,"itcast").setExpiration(new Date(exp)).claim("roles","admin") //自定义claims存储数据.claim("logo","logo.png");System.out.println( builder.compact() ); 解析 1234567891011121314StringcompactJws="eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODgiLCJzdWIiOiLlsI_nmb0iLCJpYXQiOjE1MjM0MTczMjMsImV4cCI6MTUyMzQxNzM4Mywicm9sZXMiOiJhZG1pbiIsImxvZ28iOiJsb2dvLnBuZyJ9.b11p4g4rE94rqFhcfzdJTPCORikqP_1zJ1MP8KihYTQ";Claims claims =Jwts.parser().setSigningKey("itcast").parseClaimsJws(compactJws).getBody();System.out.println("id:"+claims.getId());System.out.println("subject:"+claims.getSubject());System.out.println("roles:"+claims.get("roles"));System.out.println("logo:"+claims.get("logo"));SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");System.out.println("签发时间:"+sdf.format(claims.getIssuedAt()));System.out.println("过期时间:"+sdf.format(claims.getExpiration()));System.out.println("当前时间:"+sdf.format(new Date()) );]]></content>
  </entry>
  <entry>
    <title><![CDATA[Gradle Wrapper]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2Fgradle-wrapper%2F</url>
    <content type="text"><![CDATA[关于Gradle Wrapper推荐的方式执行任何Gradle构建的帮助下Gradle包装器(总之只是“包装器”)。包装是一个脚本,该脚本调用它宣布版本,必要时预先下载它。因此,开发人员可以用Gradle项目迅速而不必遵循手动安装过程节省贵公司的时间和金钱 你将获得以下好处： 同一版本 减低了版本统一的维护成本，只需在wrapper 文件下声明处修改版本就可以 123task wrapper(type: Wrapper) &#123; gradleVersion = &apos;1.11&apos; //修改此处版本&#125; 使用wrapper 的3中情况创建一个新的项目并加入wrapper 在自己指定的工作空间目录下运行如下命令 1gradle wrapper 创建指令 –gradle-version ：用于指定gradle 的版本 –distribution-type ：用于指定gradle的类型 bin 或 all –gradle-distribution-url : 用于指导gradle的下载路径 –gradle-distribution-sha256-sum ：用于指定编码格式 案例：创建gradle 版本为5.1.1的all类型 1gradle wrapper --gradle-version 5.1.1 --distribution-type all 创建后的目录结构图 123456├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradlew└── gradlew.bat gradle-wrapper.jar wrapper的源文件 gradle-wrapper.properties wrapper的版本等配置属性 gradlew shell脚本工具 gradlew.bat windows 批处理工具 运行已经加入wrapper的项目 在项目目录下运行下列代码 1gradlew.bat build 在已有wrapper的gradle项目中更新gradle的版本为最新。使用前面的命令可进行更新 1gradle wrapper --gradle-version 5.1.1]]></content>
  </entry>
  <entry>
    <title><![CDATA[configuartionProperties注解]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2FConfigurationProperties%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[@configuartionProperties作用​ 用于将properties 文件中的属性或yml属性文件中的属性 放入pojo中 使用案例@configuartionProperties + @Component实体类 123456789101112131415161718192021import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@ConfigurationProperties(prefix = "me.user")@Datapublic class User &#123; private String name; private String password; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", password='" + password + '\'' + '&#125;'; &#125;&#125; 测试方法 123456789101112131415161718192021import com.healthengine.medpro.fileSystem.FileSystemApplication;import com.healthengine.medpro.fileSystem.controller.entity.User;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTest(classes = FileSystemApplication.class)public class ConfigurationProperties &#123; @Autowired private User user; @Test public void configuration()&#123; System.out.println(user); &#125;&#125; 配置文件设置 1234me: user: name: baowengliang password: 123456 测试结果 1User&#123;name=&apos;baowengliang&apos;, password=&apos;123456&apos;&#125; @Bean + @ConfigurationProperties实体类 1234567891011121314151617import lombok.Data;@Datapublic class User &#123; private String name; private String password; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", password='" + password + '\'' + '&#125;'; &#125;&#125; 启动类 12345678910111213@SpringBootApplication()public class FileSystemApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(FileSystemApplication.class,args); &#125; @Bean @ConfigurationProperties(prefix = "me.user") public User user()&#123; return new User(); &#125;&#125; 测试方法 123456789101112131415161718192021import com.healthengine.medpro.fileSystem.FileSystemApplication;import com.healthengine.medpro.fileSystem.controller.entity.User;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTest(classes = FileSystemApplication.class)public class ConfigurationProperties &#123; @Autowired private User user; @Test public void configuration()&#123; System.out.println(user); &#125;&#125; 配置文件设置 1234me: user: name: baowengliang password: 123456 测试结果1User&#123;name=&apos;baowengliang&apos;, password=&apos;123456&apos;&#125; @EnableConfigurationProperties + @ConfigurationProperties实体类 12345678910111213141516171819import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;@Data@ConfigurationProperties(prefix = "me.user")public class User &#123; private String name; private String password; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", password='" + password + '\'' + '&#125;'; &#125;&#125; 启动类 123456789@SpringBootApplication()@EnableConfigurationProperties(User.class)public class FileSystemApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(FileSystemApplication.class,args); &#125; &#125; 配置文件 1234me: user: name: baowengliang password: 123456 测试类 123456789101112131415161718192021import com.healthengine.medpro.fileSystem.FileSystemApplication;import com.healthengine.medpro.fileSystem.controller.entity.User;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTest(classes = FileSystemApplication.class)public class ConfigurationProperties &#123; @Autowired private User user; @Test public void configuration()&#123; System.out.println(user); &#125;&#125; 测试结果 1User&#123;name=&apos;baowengliang&apos;, password=&apos;123456&apos;&#125;]]></content>
  </entry>
</search>
