<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数字-电子-计算机操作系统]]></title>
    <url>%2FMeBlog%2F2020%2F05%2F27%2F%E6%95%B0%E5%AD%97-%E7%94%B5%E5%AD%90-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[操作系统概论操作系统的概念计算机系统knowledge point： 1.计算机系统是一种可以按用户要求接收和存储信息、自动进行数据处理并输出结果信息的系统。 2.广义的计算机系统包含机械式系统和电子式系统。 3.电子式系统可以分为模拟式和数字式计算机系统。本篇博客讨论的是数字电子计算机系统，也可简称为计算机系统 操作系统的定义操作系统的特征研究操作系统的观点操作系统的功能操作系统的体系结构Windows操作系统的体系结构Unix操作系统的体系结构Linux操作系统的体系结构Android操作系统的体系结构操作系统的发展手工操作监控程序多道批处理分时与实时系统Unix通用操作系统个人计算机操作系统Android操作系统操作系统分类批处理操作系统分时系统实时操作系统嵌入式操作系统个人计算机操作系统网络操作系统分布式操作系统操作系统设计操作系统的设计过程操作系统的设计目标操作系统的结构设计操作系统的结构操作系统运行环境处理器中断/异常计算机中相关的硬件部分内存储器存储系统存储器的类型微型计算机中大部分采用半导体存储器，其大致可分为如下两种类型 读写型存储器（RAM）knowledge point： 1.这种类型的存储器也被称作随机访问存储器 2.它可以随时进行读或写的操作 3.RAM的全称（random access memory） 只读型存储器（ROM）knowledge point： 1.一般使用情况下只能读取其中的数据，要想对其进行写的操作需要使用专门的写入机。 2.PROM 是一种可编程的只读存储器，可以使用特殊的PROM写入器对其进行数据的写入。 3.EPROM 也是一种只读存储器，可以使用特殊的紫外光照射将其中的数据清除。使用特殊的EPROM写入器对其进行数据的写入。 4.ROM的全称（read only memory） 存储分块knowledge point： 1.存储的最小单位被称为“二进位”，他包含的信息为0或1。 2.存储的最小编址单位是字节。一个字节等于8个二进位。 3.计算机系统会把存储器中的空间分块，有时块也被称为物理页。块的大小由机器确定。 存储器的层次结构存储器层次化结构的由来： 因为人们对计算机存储器的需求是这样的，速度越快越好、容量越大越好、制造价格越便宜越好。而现实中速度、容量、价格这三者间是存在二律悖反的。有了速度就得牺牲价格和容量，相反同理。 既然不能达到最优，那如何权衡三者使用呢?答案是采用层次化的存储结构。图2-2代表了计算机存储器的层次化结构 存储器的保护内存中的数据是需要被保护的不然会出现资源的破坏从而导致系统奔溃或程序奔溃。 要实现存储保护，必须要有硬件的支持。 界地址寄存器是被广泛使用的一种存储保护技术。下面咱们看看它是如何工作的。 在处理器中设置一对界存储器，分别是上限界存储器和下限界存储器。每当处理器访问内存时，硬件自动将被访问的内存地址与界寄存器进行对比，如果越界就会产生程序中断。如图2-3所示，阐述了界地址寄存器的保护策略运行流程 系统调用]]></content>
  </entry>
  <entry>
    <title><![CDATA[数字电子-计算机操作系统]]></title>
    <url>%2FMeBlog%2F2020%2F05%2F25%2F%E8%AE%A1%E7%AE%97%E6%9C%BA-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[操作系统概论操作系统的概念计算机系统knowledge point： 1.计算机系统是一种可以按用户要求接收和存储信息、自动进行数据处理并输出结果信息的系统。 2.广义的计算机系统包含机械式系统和电子式系统。 3.电子式系统可以分为模拟式和数字式计算机系统。本篇博客讨论的是数字电子计算机系统，也可简称为计算机系统。 操作系统的定义knowledge point： 1.操作系统是计算机系统中的一个系统软件。或者说是一些程序模块的集合。 2.它能有效的管理计算机系统中的硬件和软件资源。也可以理解为，它是计算机暴露的接口，用户通过这些接口可以更好的利用计算机资源。 操作系统的特征并发性 共享性 随机性 研究操作系统的观点软件的观点 资源管理的观点 进程的观点 虚拟机的观点 服务提供者观点 操作系统的功能进程管理 存储管理 文件管理 设备管理 用户接口 操作系统的体系结构Windows操作系统的体系结构Unix操作系统的体系结构Linux操作系统的体系结构Android操作系统的体系结构操作系统的发展手工操作监控程序多道批处理分时与实时系统Unix通用操作系统个人计算机操作系统Android操作系统操作系统分类批处理操作系统分时系统实时操作系统嵌入式操作系统个人计算机操作系统网络操作系统分布式操作系统操作系统设计操作系统的设计过程操作系统的设计目标操作系统的结构设计操作系统的结构]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java 编程语言-基础篇]]></title>
    <url>%2FMeBlog%2F2020%2F05%2F20%2FJava%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Java语言概述Java语言简介Java语言的起源1.java 语言的前身是Oak语言2.Oak是由美国公司 Sun Microsystems 在1991年推出的3.1995年Sun公司将Oak语言改名为Java语言4.2009年Oracle公司将Sun收购,所以迄今为止java的版本更新由Oracle发布.5.Java语言有三大版本,来解决现如今主流方向的编程问题.那就是: a) java 2 Platform standard Edition 简称 j2SE 标准版本,可用于一些桌面程序的开发 b) java 2 Platform Enterprise Edition 简称 j2EE 企业级版本,可以跟tomcat等一些web容器配合开发网站 c) java 2 Platform Micro Edition 简称 j2ME 微型版本,可用于一些小型的计算机系统中,如开发手机的移动应用程序. Java语言的特点语法简单,功能强大,安全可靠1.Java与C++同是面向对象的编程语言,C++的执行效率高于java.但java比C++更易于编程开发2.java语言相比C++来说在web方面更有优势,因为java2EE在web领域目前是主流,一般的企业级网站建设都使用J2EE3.因为jvm具有稳定的可靠性所以java语言是安全可靠的 可跨平台1.java实现跨平台的主要因素是 jvm(java Virtual Machine)2.jvm是一台虚拟机,java通过它可以操纵平台的机器指令集.所以在不同的平台下下载不同的jvm就可实现java语言的跨平台性.个人总结 Java之所以能实现跨平台就是有jvm这个中间过渡层的虚拟机.而别的没有这个过渡层的编译性语言只能依赖固定的平台 解释编译两种运行方式1.JIT (just in time):JIT是一种提高程序运行效率的方法。通常，程序有两种运行方式：静态编译与动态解释。静态编译的程序在执行前全部被翻译为机器码，而动态解释执行的则是一句一句边运行边翻译。2.为什么Java会引入JIT即时解释器?因为java要提高程序的运行效率.大家都知道java语言编写后的文件是.java文件,要想被jvm识别并使用需要经过javac编译成.class 文件也就是所谓的(字节码文件).然后jvm解析字节码文件时原先是逐行解释为平台的机器指令集的,这样做就存在了二次编译解析的过程,java为了提高效率引入JIT将类或类中的一些常用代码指定为热点代码(hot prot code),jvm将这些热点代码转化成于本地平台先关的机器码后并存储起来,下次遇到后直接使用来提高程序的运行效率 支持多线程1.语言级多线程功能 动态执行,上下兼容的API1.java执行代码在运行时是动态载入的,在客户机网络允许的情况下,通过自动更新版本的方式来实现瘦客户机框架的目的.2.Java提供的类库及其API种类很多,所以使用开发我们可以站在居然肩膀上进行,节省了一些不必要的操作. java开发环境的安装于配置本人使用的系统是Ubuntu的,所以使用了apt install 安装了openjdk,安装路径在/usr/lib/jvm下,我创建了软链接到/usr/bin下所以或默认配置到系统的环境变量中.关于系统环境变量可查看Linux-文件配置篇 Java 程序示例Java 应用程序(Java Application)1.Java程序是由类构成的,程序的入口方法是main()2.Java程序文件扩展名是.java,编译后生成的字节码文件的扩展名是.class123456789class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println("Hello World!"); for (int i = 0;i &lt; args.length;i++)&#123; System.out.println("args["+i+"]:"+args[i]); &#125; &#125;&#125; 3.一个文件中只能有一个公共类,该类的名字即使文件的名字4.执行程序时,程序名之后输入的内容称为命令行参数,这些参数将会放入main(String[] args)中的args字符串数组中5.Java语言区分大小写 Java 小应用程序(Java Applet)Java 中的面向对象技术面向对象技术1.面向对象是一种软件开发的方法.在面向对象程序设计方法出现之前,软件界广泛流行的是面向过程的设计方法2.面向对象技术相比面向过程而言,可以使程序变得更简单易于理解.还有就是可以更大化的实现代码的重用3.面向对象方法学,可以简单理解为.一个能使分析,设计和实现更接近人们的认识的学科4.面向对象方法学主要包括3个方面 1.面向对象分析(object-oriented Analysis)简称OOA 2.面向对象设计(object-oriented Design)简称OOD 3.面向对象编程(object-oriented Programming)简称OOP OOP1.一个类的实例可以称为对象或实例2.对象是类的一个具象,类是对象的一个抽象3.OOP技术把问题看成是相互作用的事物的集合,也就是对象的集合.对象具有两个特性,一是状态,二是行为.状态是指对象本身的信息也就是属性,行为是实现对对象的操作也就是方法4.OOP三大核心概念:封装、继承、多态 封装：封装体现的特点是将对象的属性和方法实现的细节隐藏起来，并报露出使用的入口 继承：将一个类中数据和方法保留，并加上自己特殊的数据和方法，从而构成一个新类。继承体现的是一种层次关系 多态：在一个或多个类中，可以让多个方法使用同一个名字。多态可以保证对不同数据类型进行同等的操作 数据和表达式基本语法元素空白、注释及语句空白在java程序中，换行符及回车符等都可以表示一行的结束且留有空白的部分都表示空白 注释注释不能插在一个标识符或关键字的中间 单行注释 //多行注释 /*使用/*表示注释的开始，*/表示注释的结束位置 一般这种注释用于解释方法中的逻辑说明或方法说明 文档注释 /**以/** 开始，*/结束一般这种注释用于说明公共的类或方法其中注释有一下参数：@param 参数@return 输出(返回值)@throws 异常抛出 语句语句是java程序运行中的最小执行单元 程序的各语句之间需要使用；分隔 语句分为单语句及复合语句。单语句就是通常意义下的一条语句，复合语句是块（使用{}包裹起来的内容） 1234567//复合语句&#123;int a = 1;int b = 2;&#125;//单语句int a = 3; 关键字abstract boolean brack byte casecatch char class const continue defaultdo double else extends false finalfinally flost for future generic gotoif implements import inner instanceof intinterface long native new null operatorouter package private protected public restreturn short static strictfp super switchsynchronized this throw throws transient truetry var void volatile while 标识符在java编程语言中，标识符由字母、下划线_、美元符号$、字母等构成 数子不能做为标识符的首个字母 标识符可以用在类上、接口上、方法上、变量上 Java编程规范1.缩进2.变量的大小写3.常量的大小写3.方法名的应用4.合理的注解和空格 基本数据类型基本数据类型整数型 整型常量默认使用int 整型量可用十进制、八进制或十六进制形式表示，以1~9开头的整数为十进制的表示形式。以0开头的数为八进制的表示形式。以0x或0X开头的数为十六进制的表示形式。 浮点数型float表示单精度浮点数类型double表示双精度浮点数类型浮点数类型的常量默认情况下使用double 字符型 char单个字符使用char来表示，一个char表示一个Unicode字符。char类型的常量必须使用一对‘’括起来 布尔型 booleanjava 中boolean的值只有true or false 。 true or false 使用小写表示，计算机内部使用8位二进制表示 复合数据类型类类型数组一般数组指的是一个对象 接口类型表达式简介：表达式由运算符和操作数组成。表达式用来运算得出结果 java运算按功能可划分为：算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和条件运算符、数组下标运算符 操作数可以用来做操作数的有以下元素： 常量简介：常量可以简单理解为拥有单一不变唯一值引用 example： 12345System.out.println(23.59);System.out.println(-1247.1f);System.out.println(true);System.out.println("this is a String");System.out.println('a'); 变量简介：变量是存储数据的基本单元，变量在使用之前需要先声明。使用时必须要为其初始化值 1234567891011double d1;d1 = 23.59;float f1 = -1247.1f;boolean b1 = true;String s1 = "This is a String";char c1 = 'a';System.out.println(d1);System.out.println(f1);System.out.println(b1);System.out.println(s1);System.out.println(c1); 方法内声明的变量称为：自动变量、局部变量、临时变量、或栈变量 类中定义的变量称为：类成员变量 方法内声明的变量是不存在默认值的，而类中声明的变量在类的初始化时会为其初始化默认值 ​ 类成员变量：各基本类型的默认值 类型 初始值 类型 初始值 byte 0 double 0.0 short 0 char ‘\u0000’ int 0 boolean false long 0l 所有引用类型 null float 0.0f 123456789 int xTest = (int)(Math.random()*100),yValue,zVar; boolean flag; int iValue1 = 1,iValue2 = -4; float fValue = 9.997f - 5f; if(xTest&gt;50)&#123; yValue = 9; &#125;// zVar = yValue + xTest; //这里会出现异常，因为yValue有可能不能被赋值// System.out.println(zVar); 变量的作用域 可以正常执行 1234567891011121314151617class Customer&#123; private String name; public static void main(String[] args)&#123; Customer customer = new Customer(); &#123; String name = "Tom David"; customer.name = name; System.out.println("this name is:"+customer.name); &#125; String name = "John";//由于上面代码块执行完后，代码块中的变量会被释放也就不存了.所以这里可以声明name变量 customer.name = name; System.out.println("this name is:"+customer.name); &#125;&#125; 不可以正常执行 1234567891011121314151617class Customer&#123; private String name; public static void main(String[] args)&#123; Customer customer = new Customer(); String name = "John"; &#123; String name = "Tom David";//存在的变量不能被重复声明 customer.name = name; System.out.println("this name is:"+customer.name); &#125; System.out.println("this name is:"+customer.name); &#125;&#125; 数学函数由于Math类下的数学函数的返回值是基本数据类型或引用类型所以它们也可以被当做操作数来看待。 如下列举一些方法： Math.sin(); Math.cos(); 运算符算术运算符算术运算符如: 符号 表示 + 加法运算 - 减法运算 * 乘法运算 / 除法运算 % 取模运算（取余数） ++ 加1 – 减1 这里需要说明下 ++i 和i++的区别，++i在i被使用前加1,i++在i被使用后加1.–与++类似。 Java数据类型自动转换规则: byte short char int long float double 排在前面的可以自动转换为后面的类型，如果要想将后面的类型转换为前面的类型需要使用强制类型转换（注意强制类型转换有可能损失精度，不建议使用） 不同类型数据进行运算时，java会将类型根据Java数据类型自动转换规则将类型统一，然后进行相应的运算。 关系运算符 符号 表示 &gt; 大于 &gt;= 大于且等于 &lt; 小于 &lt;= 小于且等于 == 等于 != 不等于 逻辑运算符 符号 表示 &#38; 与 &#124; 或 &#38;&#38; 短路与 &#124;&#124; 短路或 上表中的短路表示当判断的左边不满足整个逻辑运算符的规定时就会停止右边的逻辑运算并返回左边的逻辑值。如&amp;&amp;当左边是false时整个逻辑式的结果为false，因为&amp;&amp;是与只有两边都为true时才会返回true 位运算符位运算符是用来对二进制位进行操作的。位运算符只能对整型和字符串型数据进行操作 ​ 拥有算术意义的位运算符 符号 表示 &gt;&gt; 右移x位就表示除以2的x次方 12345System.out.println(128&gt;&gt;1);System.out.println(258&gt;&gt;5);//表示258除以2的5次方System.out.println(258/32);System.out.println(-256&gt;&gt;4);System.out.println(-256&gt;&gt;&gt;4); 赋值运算符​ 拥有算术意义的赋值运算符 符号 表示 += 如x +=2 同 x = x + 2 -= 如x -= 2 同 x = x - 2 *= 如x =2 同 x = x 2 /= 如x /=2 同 x = x / 2 %= 如x %=2 同 x = x % 2 &gt;&gt;= 如 x &gt;&gt;=2 同 x = x &gt;&gt; 2 条件运算符（三元运算符） 符号 表示 ？ ： 如x = condition?1:2 ，当condition为true时x值为1，相反为false时x值为2 123456boolean condition = true;int x = condition?1:2;System.out.println("When condition is true,x is:"+x);condition = false;x = condition?1:2;System.out.println("When condition is false,x is:"+x); 点运算符（.）、new运算符(new )、下标运算符([])点用算符用来调用对象的变量值或使用方法等 new运算符用来创建一个类的实例（对象） 下标运算符用来获取序列中某个位置的值。 实例运算符（instanceof）用于判断当前实例是否属于某个类或接口 123Father expression = new Expression();System.out.println(expression instanceof HelloWorld);System.out.println(expression instanceof Object); 注意 instanceof只能在对象和要判断的类之间存在继承或实现同一接口时做运算。不然会有语法错误提示 流程控制语句java程序的结构简介：一个java程序是由一个或多个.java文件组成的，.java文件被称为源文件。源文件可以是一个或多个类或接口，但是类中只能有一个公共类也就是public修饰类，并且源文件名要和公共类名一致。 java程序结构中的注意项： package：包语句，每个文件中只能拥有一个包语句，并且此语句必须在可执行代码的第一行。 import：引入语句，如果有import语句的话必须放在所有类定义的前面。 公共类（具有public定义的类）：每个源文件中只能包含一个。 类定义：每个源文件中可以包含多个，但公共类只能有一个。 接口定义：每个源文件中接口可以有一个或多个。 java包（package）简介：包是类的容器，程序设计人员利用包来划分名字空间，避免类名冲突。使用包的目的是将源文件有效的组织起来。 注意事项： 包层次必须与java开发系统的文件系统结构相同。 包名中全部使用小写。 一个包可以包含多个包或多个类。 代码案例（example）： 1package com.spider.dome 引入语句简介：其作用就是将指定的资源引入当前类中，其实不使用引入语句直接使用其资源的全限定名称（报名.资源名）也是可以使用的。 注意事项： 引入语句须放在所有类定义的前面。 引入的类必须具有访问权限才可以正常使用。 当引入的同时引入两个有歧义的类时，直接使用全称类名。 代码案例（example）： 1234//引入当包下的全部import com.spider.dome.*;//引入指定类import com.spider.dome.Customer; 123456Cat cat = new Cat();chapter3.com.spider.Dog spiderDog = new chapter3.com.spider.Dog();chapter3.com.spider.dome.Dog domeDog = new chapter3.com.spider.dome.Dog("钢镚");cat.setDomeDog(domeDog);cat.setSpiderDog(spiderDog);System.out.println(cat); 流程控制赋值语句简介：把一个值赋值给一个变量这样的语句就称为赋值语句 注意事项： 有的表达式可以作为一条赋值语句，但是不是所有语句都是表达式 以下3条语句中，前两条为赋值语句，最后一条为表达式 123Customer customer = new Customer();x = 12;x++; 分支语句简介：分支在java程序中分为2种 if 和 switch if (单重分支)的语法形式如下： if(条件表达式){ ​ 语句1； } if else 的语法形式如下： if(条件表达式){ ​ 语句1； }else{ ​ 语句2； } 案例代码(example): 1234567891011121314151617181920 private static void ifOrSwitchLearn(int firstVal,int secondVal)&#123;// if(firstVal == 0)&#123;// if(secondVal == 1)&#123;// firstVal ++;// &#125;else&#123;// firstVal --;// &#125;// &#125; if(firstVal == 0)&#123; if(secondVal == 1)&#123; firstVal ++; &#125; &#125;else &#123; firstVal --; &#125; System.out.println("firstVal is: "+firstVal); &#125; switch 语句(多重分支)的语法形式如下： switch （表达式）{ ​ case c1: ​ 语句组1； ​ break； ​ case c2: ​ 语句组2； ​ break； … ​ case ck: ​ 语句组k; ​ break; default: ​ 语句组; ​ break; } switch 语句中的break是可选项，程序运行到break处时会跳出当前switch语句块。没有遇到时会向下执行。 123456789101112131415161718192021int firstVal = 1; switch(firstVal)&#123; case 1: System.out.println(firstVal); case 2: System.out.println(2); case 3: System.out.println(3); &#125;//程序运行结果是 1 2 3int firstVal = 1; switch(firstVal)&#123; case 1: System.out.println(firstVal); case 2: System.out.println(2); break; case 3: System.out.println(3); &#125;//程序运行结果是 1 2 if else if 语句： if else if 类似与 switch 每一项加了break的做法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 if(firstVal==0)&#123; System.out.print(0); &#125;else if(firstVal == 1)&#123; System.out.print(1); &#125;else if(firstVal == 2)&#123; System.out.print(2); &#125;else if(firstVal == 3)&#123; System.out.print(3); &#125;else&#123; System.out.print(firstVal); &#125;//等同于switch(firstVal)&#123; case 0: System.out.print(0); break; case 1: System.out.print(1); break; case 2: System.out.print(2); break; case 3: System.out.print(3); break; default: System.out.print(firstVal); &#125; private static void dayInMonth(int month)&#123; if(!(month&gt;=1&amp;&amp;month&lt;=12))&#123; return; &#125; if(month == 2||month == 4||month == 6||month == 9||month == 11)&#123; System.out.println("this "+month+" month of 30 day."); &#125;else&#123; System.out.println("this "+month+" month of 31 day."); &#125; &#125; public static void main(String[] args)&#123; Calendar calendar = Calendar.getInstance(); int month = calendar.get(Calendar.MONTH)+1; dayInMonth(month); System.out.println(calendar.get(Calendar.DAY_OF_MONTH)); char c = "str".charAt(0); &#125; 循环语句简介：循环语句控制程序流程多次执行一段代码。java中提供了三种循环语句分别是 for wile do. for语句for 语句语法形式如下： for(初始语句；条件表达式；迭代语句){ ​ 循环体语句； } 注意事项： 初始语句和迭代语句中可以含有多个语句，各语句间使用;做分离。括号内的3个部分是可选的，当条件表达式为空时默认值为true。所以会导致代码块重复一直运行下去。 12345678private static void forAndWileAndDoLearn()&#123; int sumi = 0,sumj = 0; for(int i=0, j=0;j&lt;10;j++,i++)&#123; sumi +=i; sumj +=j; &#125; System.out.println("sumi is :"+sumi+"\n"+"sumj is :"+sumj);&#125; while语句while 语句语法形式如下： while（条件表达式）{ ​ 循环体语句； } 1234567891011private static void forAndWileAndDoLearn()&#123; int sumi = 0,sumj = 0; int i =0,j = 0; while(j&lt;10)&#123; sumi +=i; sumj +=j; i++; j++; &#125; System.out.println("sumi is :"+sumi+"\n"+"sumj is :"+sumj); &#125; do 语句do 语句语法形式如下： do{ ​ 循环体语句； }while（条件表达式）; 1234567891011private static void forAndWileAndDoLearn()&#123; int sumi = 0,sumj = 0; int i =0,j = 0; do&#123; sumi +=i; sumj +=j; i++; j++; &#125;while(j&lt;10); System.out.println("sumi is :"+sumi+"\n"+"sumj is :"+sumj); &#125; 注意事项： do语句与while语句大致相同，不同之处在于do语句是先执行循环体语句然后做条件判断。 跳转语句标号简介：标号可以放在任意语句之前，通常与for、while或do配合使用。 break简介：break 用于跳出当前语句块 continue简介：跳过当前循环 123456789101112131415161718192021 private static void learnOfBreakAndContinue()&#123;// for(int i=0;i&lt;10;i++)&#123;// out2:for (int ii=0;ii&lt;10;ii++)&#123;// if(ii&gt;i)&#123;// break out2;// &#125;// System.out.print("* ");// &#125;// System.out.println();// &#125; out1:for(int i=0;i&lt;10;i++)&#123; out2:for (int ii=0;ii&lt;10;ii++)&#123; if(ii&gt;i)&#123; System.out.println(); continue out1; &#125; System.out.print("* "); &#125; &#125; &#125; Scanner NumberFormate DecimalFormate1234567891011121314151617181920212223 Scanner scanner = new Scanner(System.in); int age; double weight,height,hmi; System.out.println("place input your age!"); age = scanner.nextInt(); System.out.println("place input your weight(kg)"); weight = scanner.nextDouble(); System.out.println("place input your height(m)"); height = scanner.nextDouble(); hmi = weight/(height*height); DecimalFormat decimalFormat = new DecimalFormat("0.##"); System.out.println("your hmi is: "+decimalFormat.format(hmi)); // Double myNumber = 12345.123456789;// Double test = 1.2345;// String myString = NumberFormat.getInstance().format(myNumber);// System.out.println("default format: "+myString);// myString = NumberFormat.getCurrencyInstance().format(myNumber);// System.out.println("Currency format: "+myString);// myString = NumberFormat.getNumberInstance().format(myNumber);// System.out.println("Number format: "+myString);// myString = NumberFormat.getPercentInstance().format(test);// System.out.println("percent format: "+myString); 异常处理在java中将程序运行可能遇到的错误分为2类，一类是非致命性的被称之为异常（expection），另一类是致命性的被称为错误（error） 异常是可以通过cache来处理的而错误则不可以。 异常处理时需要考虑的问题有，如何处理异常、异常是由谁来处理、异常对程序构成的影响是否在可控范围 异常分类受检异常（Checked Expection）简介：程序执行期间发生的严重事件的后果。例如FileNotFoundException 运行时异常（Runtime Exception）简介：通常程序中逻辑错误的结果。例如：ClassCastException 异常处理注意事项： 在不清楚如何处理异常情况下，抛出异常是一个不错的方法。 处理异常时，尽量使用finally，不要嵌套cache嵌套 使用了System.exit()方法后会导致finally不能被正常执行，因为程序已经被退出。 面向对象程序设计类和对象类的定义简介：类的定义也就是类的声明。简单来说分别是数据成员变量和成员方法。下面是类的语法书写格式 修饰符 class 类名 [extends 父类名]{ ​ 修饰符 变量类型 变量名； ​ 修饰符 返回值类型 方法名( 参数列表){ ​ 方法体； } } java中的访问权限修饰符表： 类型 无修饰符(public) private protected public 同一类 yes yes yes yes 同一包中的子类 yes no yes yes 同一包中的非子类 yes no yes yes 不同包中的子类 no no yes yes 不同包中的非子类 no no no yes 总结点： 类定义时，类头与类体在同一个源文件中，并且每个源文件只能拥有一个公共类，且源文件名就是那个公共类名。 类可以指明父类也可以不指定父类，如果指定父类则只能指定一个父类。因为java是单继承体制。 Object类是java中唯一一个没有父类的类，而其余的类都继承与Object类 class定义的大括号后没有；符号 构造方法概述：构造方法是一个特殊的类成员方法，它被用来创建生成对象。当系统识别到关键字new后会去执行指定的构造方法来创建对象。 构造方法注意点： 构造方法不能被继承，但构造方法可以重写。 构造方法没有返回值类型。 一个类如果没有显示声明构造方法，系统会为当前类生成一个无参的构造方法。但是如果显示声明了构造方法系统则不会给出默认的无参构造方法。 构造方法尽量为其类中的成员变量初始化自己预期的值。 构造方法的重载构造方法重载时可以使用关键字this来替代本类中的其他构造方法。 案例（example） 1234567891011121314151617public class Student&#123; String name; int age; public Student(String name,int age)&#123; this.name = name; this.age = age; &#125; public Student(String name)&#123; this(this.name,20); &#125; public Student()&#123; this("Unkonwn"); &#125;&#125; this关键字不仅可以用来指代本类中的构造方法，还可以指代本类中的其他元素它被看成是当前类的运行时对象。 上例中的this.name 如果参数名和类成员变量名不冲突时可以省略this 关键字。 对象的创建和初始化总结点： 在java中使用构造方法是生成实例对象的唯一途径，这个过程称为对象的实例化。 实例化对象时如果对象的成员变量没有显示声明值时，java会默认为其初始化值。如下表所示 名称 默认值 数值变量 0 布尔变量 false 引用变量 null 定义方法书写语法： 修饰符 返回类型 方法名(参数列表) { ​ 方法体（块) } 方法定义的注意事项： 方法名必须是一个合法的标识符 返回值类型必须和方法声明的返回类型一致 参数列表中每个元素之间使用逗号间隔 传给方法的值称为实参，语法声明中参数列表中的参数称为形参数 方法的重载方法的重载简单的说就是同一个方法名拥有不同的参数列表 注意事项： 方法的重载与参数的个数，参数的顺序有关，但和返回值类型无关 方法的重载只存在于同一个类中 静态成员简介：java中静态成员是不依赖于对象内容的。也就是说静态的成员和对象无关。 不同对象的成员，其内存地址是不同的。但是如果类中包含静态成员，则系统只在类定义时为静态成员分配内存。此时还没有创建对象（没有对类进行实例化）以后生成该类的实例时，将不再为静态成员分配内存，不同的对象静态成员是共享的。 静态变量在java中静态成员变量是唯一能为类中所有对象共享变量的方法。 静态方法注意事项： 静态方法中不能使用this，因为静态成员是不依赖于对象的。 一个静态方法中只能使用其内部定义的参数或静态变量 静态方法不能被重写 包装类简介：java中的包装类是用来将基本类型转换成引用类型操作的实现。 基本数据类型 包装类 byte Byte short Short int Integer long Long float Float double Double char Char boolean Boolean void Void 注意 Void 类不能被实例化 自动装箱 example： 12// Integer a =10;// System.out.println(a); 自动拆箱 123// Integer a =10;// int b = a;// System.out.println(b); 数组和字符串数组简介：数组是用来表示一些相同数据类型的元素的集合。 注意事项（warning） 数据有序，数据的存入和取出是有序的 下标可用，获取数据可以使用下标取出 可声明多种数据类型，可以是基本数据类型，也可以是引用数据类型 数组在使用前必须要声明，先声明后使用。 数组在声明时并不会为数组分配内存，而是存储数组引用的变量。当数组赋值时内存才会分配内存空间。 数组的声明案例example 123456//方式1char s[];int intArray[];//方式2char[] s;int[] intArray; 静态数组定义（错误，java中不存在）1int intArray[5]; 创建数组简介：数组初始化的过程就是数组的创建过程 注意事项： 数组初始化后长度就会被固定，就像是Python中的tuple。 静态初始化案例example 12int intArray[] = &#123;1,2,3,4&#125;;double heights[] = &#123;4.5,23.6,84.124,78.2,61.5&#125;; 动态初始化案例example 123456String names[];names = new String[4];names[0] = "Tom";names[1] = "Jen";names[2] = "Simon";names[3] = "Georgianna"; 注意事项： ps = new Point[4]; 只是创建可以容纳4个Point的数组，但并未创建了4个Point对象 动态初始化时要注意数组的边界。不能越界赋值 数组可以存储不同于所声明的类，但存储的类型必须是它的祖先类。如下： 123Object[] points;points = new Point[100]; 以上的声明及其初始化是合法的但是如下声明相反却是错误的： 123Point[] points;points = new Object[100]; 访问数组元素123456789String names[];names = new String[4];names[0] = "Tom";names[1] = "Jen";names[2] = "Simon";names[3] = "Georgianna";//访问素组中的下标为0的元素也就是数组中的第一个元素String name = names[0]; 多维数组简介：多维数组可以理解为数组的嵌套 例如二位数组就是一个多维数组，它的表示方式如下 123int[][] intArray;int intArray[][];int[] intArray[]; 静态初始化1int[][] intArray = &#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;; 动态初始化直接分配1int[][] a = new int[2][3]; 按维分配12345678910//矩形多维数组int[][] a = new int[2][];for(int i=0;i&lt;a.length;i++)&#123; a[i] = new int[3];&#125;//非矩形多维数组int[][] a = new int[2][];a[0] = new int[3];a[1] = new int[2]; 多维数组的引用12int[][] intArray = &#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;;int a = intArray[0][1]; 如何解决数组的固定长度问题因为我们平时使用的都是数组的引用，所以我们可以通过改变引用指向的数组来解决这一问题。 案例example 12345public void changeLengthOfArray(int[] array)&#123; //将当前的数组长度加1 int length = array.length; array = new int [length+1];&#125; 数组的一些常用方法System.arraycopy java.util.Arrays 下的一些静态方法 字符串简介：java中的字符串是由有限个字符组成的序列对象。说到字符串不得不说String 和StringBuffer 注意事项（warning）： string 用来操作不会被修改的字符串。 StringBuffer 用来操作可变的字符串。 string 比StringBuffer 所占用的内存空间要小。StringBuffer除自身字符串占用空间之外还有16个字符大小的缓存区。 String常量 1"Hello world!" 变量 1String s = new String("Hello World"); StringBuffer1StringBuffer sb = new StringBuffer("Hello World"); StringBuilder1StringBuilder sb = new StringBuilder("Hello World"); String、StringBuffer、StringBuilder总结：（1）如果要操作少量的数据用 String （2）多线程操作字符串缓冲区下操作大量数据 StringBuffer （3）单线程操作字符串缓冲区下操作大量数据 StringBuilder。 字符串的判断== 、compareTo()、equals()、equalsIgnoreCase()、regionMatches() 注意事项： 判断时应该先从内存中的地址值去判断，这样可以达到断言的效果。使用 == 判断就是变量的地址值 vector简介：简单的说可以理解为一个动态数组的实现类 注意事项： vector中只能保存对象类型，所以不能操作基本数据类型。 案例example 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class MyVector extends Vector&#123; public MyVector()&#123; super(1,1); &#125; public void addInt(int i)&#123; addElement(new Integer(i)); &#125; public void addFloat(float f)&#123; addElement(new Float(f)); &#125; public void addString(String s)&#123; addElement(s); &#125; public void addCharArray(char[] c)&#123; addElement(c); &#125; public void printVector()&#123; int length = size(); System.out.println("Number of Vector element is: "+length+" and they are:"); for(int i=0;i&lt;length;i++)&#123; Object o = elementAt(i); if( o instanceof char[])&#123; System.out.println(String.copyValueOf((char[])o)); &#125;else &#123; System.out.println(o); &#125; &#125; &#125;&#125;public class MyControl &#123; public static void main(String[] args)&#123; MyVector vector = new MyVector(); int digit = 5; float real = 3.14f; char[] letters =&#123;'a','b','c','d'&#125;; String s = new String("Hi there!"); vector.addInt(digit); vector.addFloat(real); vector.addString(s); vector.addCharArray(letters); vector.printVector(); &#125;&#125; 继承与多态子类简介：子类是继承父类的衍生类。 子类在程序设计上体现了继承的特点，除使用了面向对象继承的特性外，它还实现了代码的复用性。 语法： 修饰符 class 子类名 extends 父类名{ } 父类的称呼： 超类、基类 is a关系继承的关系体现使用is a 可以很贴切的描述出。 案例example： 如员工（employee）和经理（manager）之间的关系就可以使用is a 来描述。 The manager is an employee of the company has a关系模块的概念可以使用 has a 来描述比较贴切。 案例example： Cars has engines and wheels 发动机和轮胎之间是没有关联的，但是它们都与汽车有联系。所以可以被看做是汽车的模块。 Object 类object在java中是所有类的超类 object中的一些常用的方法： public final class getClass(); 获取当前对象的所属类信息。 public String toString(); 获取当前对象的输出信息。 public boolean equals(Object o); 对象对比时会参看此方法的返回值。 单继承多重继承关系类似于一个网络。如果子类的多个父类中有同名的方法和属性，那么就容易造成子类实例的混乱。 java使用单继承规避了这一缺点，同时通过实现多个接口也可以间接的实现多重继承的优势。 虽然继承可以保留父类中的成员方法和成员变量，但是子类不能继承父类的构造方法。要想使用父类的构造方法可以使用super关键字 案例example 123456789101112131415161718192021222324class Employee&#123; public String name; public String employeeNumber; public String getDetails()&#123; return "Name: "+name+"\n employeeNumber: "+employeeNumber; &#125;&#125;class Manager extends Employee&#123; public String department; public Manager(String name,String department)&#123; super();//使用父类的无参构造方法，如果想使用有参的话可以super(参数列表)；这样调用 super.name = name; this.department = department; &#125;&#125; @Override public String getDetails() &#123; return "Name: "+name+"\nDepartment: "+department; &#125;&#125; 子类不能直接访问其父类中定义的私有成员 example： 12345678910111213141516171819202122public class A extends B&#123; public int a = 1; public void tryVariables()&#123; System.out.println("a: "+a); System.out.println("super a: "+super.a);// super 可以访问父类中允许访问的成员属性// System.out.println("b: "+b); System.out.println("b: "+getB()); System.out.println("c: "+c); &#125;&#125;class B&#123; public int a = 10; private int b = 20; protected int c = 30; public int getB()&#123; return b; &#125;&#125; 对象转型（Casting）简介：和大多数面向对象的语言一样，java允许使用对象的父类类型做引用类型（静态类型），子类对象的实例做值（动态类型）。 example： 1B a = new A(); 但是相反子类类型做引用类型，父类对象做值就会出错是不可以的 example： 1A b = new B(); 方法覆盖与多态方法覆盖（override）简介：方法的覆盖也被称为：override、方法重写、隐藏。它只出现在子父类中。并且要求方法名参数列表和返回值一致。 注意事项： 子类方法不能比父类方法的访问权限更严格。 覆盖方法所抛出的异常不能比原方法多。 它只出现在子父类中 调用父类的构造方法出于安全考虑，java对于对象的初始化要求是非常严格的。比如，java要求一个父类对象要在子类运行前完成初始化。 虽然不能继承父类中的构造方法，但使用super关键字可以调用父类的构造方法 注意事项： 在构造方法中使用super关键字调用父类的构造方法。 默认情况下子类的构造方法中会调用父类的无参构造方法。 super调用父类构造方法时要放在方法的第一行 多态简介: java中多态是一个非常重要的概念。有了多态，能够允许同一条方法在不同的上下文环境中做不同的事情。 重载方法可以看做是多态的一种形式。 父子类间的override也是多态的一种表现形式。 如 父类类型 a = new 子类类型 ，java 在这种情况下执行override方法,执行的是子类对象中的方法（运行时类型），而不是引用类型（父类/编译时类型）中的方法。 静态类型：引用类型，是在编译时确定下来的。 example： 1SuperClass superc; //静态类型 动态类型：运行时某一时刻引用所指向对象的类型，它会随着进程的改变而改变。 1SuperClass superc = new SuperClass(); //中的 new SuperClass() 对象是动态类型 动态绑定：调用稍后可能被覆盖的方法的这种处理方式，称为动态绑定。 静态绑定：在编译过程中能确定调用方法的处理方式，称为静态绑定。 终极类与抽象类终极java中有一个关键字final表示终极，它可以修饰类、方法、变量。 当final修饰类时它被称为终极类，这时类不能被继承。 当final修饰方法时它被称为终极方法，此时方法不能被覆盖（override）。 当final修饰变量时它被称为终极变量，此时变量的值不能被修改。 终极类语法： final public class 类名{ } 123final public class FinalClass&#123;&#125; 终极方法语法： final 权限修饰符 返回值类型 方法名（参数列表）{ } 123final public void finalMethod()&#123; &#125; 终极变量语法： final 访问权限修饰符 类型 变量名 = 值； 1final int iFinal = 10; 抽象java中使用abstract 关键字来表示抽象，它可以修饰类、方法。 注意事项： abstract修饰类时，它不能被直接创建对象，而是可以通过其子类来创建对象。因为它的子类实现了它所包含的抽象方法。 abstract 修饰方法，此时的方法是抽象方法所以不需要写方法体。 有抽象方法的一定是抽象类，抽象类不一定都是抽象方法。 抽象类不能直接创建对象，但是可以定义一个抽象类型的引用变量。 抽象类语法： abstract public class 类名{ } 1234567891011abstract public class AbClass&#123; public int a = 10; private int b = 20; protected int c = 30; public int getB()&#123; return b; &#125;&#125; 抽象方法abstract 权限修饰符 返回值类型 方法名（参数列表); 1234abstract public class AbClass&#123; abstract public void abMethod(int a);&#125; 接口简介：接口是体现抽象的另一种形式，可将其想象为一个“纯”的抽象类。 语法： 修饰符 interface 接口名{ } 注意事项： 接口中的的变量只能是终极变量。 接口中的方法只能是抽象方法。 在java接口的定义中默认缺省final public abstract 关键字。如下例子中是一样的。 1234interface Shape2D&#123; double pi = 3.14; double area();&#125; 等同于 1234public interface Shape2D&#123; public double pi = 3.14; public double area();&#125; 输入和输出流数据流的基本概念数据流的来源： 所有的程序都离不开信息的输入输出。比如从键盘上输入一个字符，从文件中读取一行文字。显示器上的文字输出等这都涉及到了信息的输入输出。在java中把这些不同类型的输入或输出源抽象为流（Stream）。 数据流（Data Stream） 数据流是指一组有序的、有起点和终点的字节集合。例如使用键盘写数据到文件中，此操作可以使用数据流来完成。 java.io包下的文件提供了流基础的使用支持。其中最常用的分为 （InputStream ，OutputStream)和（Reader，Writer）inputStream outputStream 用来处理字节流，Reader Writer 用来处理字符流。 输入数据流简介：输入数据流是指只能读取不能写的数据流，用于向计算机内输入数据。 java.io包下有关输入数据流的类都直接或间接继承于InputStream抽象类。 InputStream抽象类中提供的数据主要操作方法如下： int read(); int read(byte[] b); int read(byte[] b,int off,int length); void close(); int avaliable(); long skip(long l); boolean marksupported(); void mark(int markaresa); void reset(); 使用输入数据流时的注意事项： 尽量使用以系统支持的最大容量的块为单位的BufferedInputStream类进行数据输入。 输出数据流简介：输出数据流是指，能将计算机内的数据输出到指定的数据源中，但是不能读取数据源中的数据。用于计算机内的数据输出。 与输入数据流InputStraem流类似，java.io包下的输出数据流实现类都直接或间接继承于OutputStream. OutputStream 抽象类中提供了如下数据流的操作方法： void write(int i); void write(byte[] b); void write(byte[] b ,int off ,int length); void close(); void flush(); 使用输出数据流时的注意事项： 尽量使用以系统支持的最大容量的块为单位的BufferedOutputStream类进行数据输出。 在输入完数据后调用flush，将内存中缓存的内容输入到目标源。然后关闭流。 基本字节类型的数据流文件数据流FileInputStream FileOutputStream 案例example： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class FileOutputStreamTest &#123; public static void learnFileOutputStream1()&#123; FileOutputStream fOut = null; try &#123; fOut = new FileOutputStream("myFile.dat"); fOut.write('H'); fOut.write(69); fOut.write(76); fOut.write('L'); fOut.write('O'); fOut.write('!'); fOut.flush(); fOut.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; fOut.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void learnFileInputStream()&#123; FileInputStream fInput = null; try &#123; fInput = new FileInputStream("myFile.dat"); while (fInput.available()&gt;0)&#123; System.out.print(fInput.read()+"\t"); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally&#123; try &#123; fInput.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args)&#123; learnFileInputStream(); &#125;&#125; 过滤器数据流简介：过滤器（filter）流，它是数据流的一个装饰流。如：BufferedInputStream BufferedOutputStream 等。 缓存区数据流BufferedInputStream BufferedOutputStream 构造方法： 1234public BufferedInputStream(InputStream var1)// 使用默认的缓存区8192创建 public BufferedInputStream(InputStream var1, int var2)//使用指定的var2的值为缓存区创建 public BufferedOutputStream(InputStream var1)// 使用默认的缓存区8192创建 public BufferedOutputStream(InputStream var1, int var2)//使用指定的var2的值为缓存区创建 java基本类型（Data）数据流DataInputStream DataOutputStream 构造方法： 12public DataInputStream(InputStream var1) public DataOutputStream(OutputStream var1) 123456789101112131415161718192021222324252627282930313233343536373839404142 public static void learnDataOutputStream()&#123; DataOutputStream dOut = null; try &#123; dOut = new DataOutputStream(new FileOutputStream("dataFile.dat"));// dOut.writeBoolean(false);// dOut.writeBoolean(true);// dOut.writeChar('H'); dOut.writeInt(19); dOut.flush(); dOut.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; dOut.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void learnDataInputStream()&#123; DataInputStream dInput = null; try &#123; dInput = new DataInputStream(new FileInputStream("dataFile.dat")); while (dInput.available()&gt;0)&#123; System.out.print(dInput.readInt()+"\t"); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally&#123; try &#123; dInput.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; DataInputStream or DataOutputStream 使用注意事项： 这两个类都是用来存储java基本数据类型的。 写入的是什么类型，读取的时候就使用对应的类型获取。 对象流简介：主要用来保存某一时态时的对象状态 ObjectInputStream ObjectOutputStream 注意事项： 被转化为流的对象类必须是被标记为序列化的类。也就是实现了Serializable接口的类。 serialversionUID的值在实现Serializable接口后，自己生成，因为反序列化时会判断此值，如果不手动生成的话。当类的内容有所变动时，系统默认生成的值会和序列化时的值出现偏差。当有偏差时反序列化就不能正常执行。 ObjectOutputStram 将对象转化成流时只能保存变量的值，并没有保存方法内容。静态成员变量也不会被保存 ObjectOutputStram 将对象转化成流时变量的访问权限是无效的。如果想忽略某个成员变量可以使用transient关键字修饰 当一个成员变量引用一个类时，只要类实现了Serializable接口是可以自动嵌套序列化的。所以这个序列化过程可以递归执行 序列化的操作对数据来说是不安全的，因为访问权限修饰符是无效的 案例example： 1234567891011121314151617181920public class Student implements Serializable &#123; private static final long serialVersionUID = 3040035028056125404L; public transient String name; final int age = 18; public String studentId ; public Student(String name)&#123; this.name = name; &#125; public void studyMath()&#123; System.out.println("my name is "+name); System.out.println("Good good Study day day up"); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839 public static void studyObjectInputStream()&#123; ObjectInputStream oin = null; try &#123; oin = new ObjectInputStream(new FileInputStream("objectFile.ser")); Student s = (Student) oin.readObject(); s.studyMath();// System.out.println("your name:"+s.name); System.out.println("your age:"+s.age); System.out.println("your studentId:"+s.studentId); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally&#123; try &#123; oin.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void studyObjectOutputStream()&#123; ObjectOutputStream oOut = null; try &#123; oOut = new ObjectOutputStream(new FileOutputStream("objectFile.ser")); oOut.writeObject(new Student("Tom")); oOut.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally&#123; try &#123; oOut.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 基本字符类型的数据流Reader and Writer. java.io包中的Reader和Writer的抽象类是所有字符流处理的超类. java同其他程序设计（programming）语言使用的字符集不同。java采用Unicode 而大多数老式编程语言如c采用ASCII. ASCII 使用一个字节（8bit）表示一个字符，而Unicode使用两个字节（16bit）表示一个字符. InputStreamReader字符流输入处理实现类，它可以设置处理字符的字符集 构造方法： 1public InputStreamReader(InputStream var1, String var2) OutputStreamWriter字符流输出处理实现类，它可以设置处理字符的字符集 构造方法： 1public OutputStreamWriter(OutputStream var1, String var2) BufferedReader带缓存的读者类 BufferedWriter带缓存的写者类 文件处理java中的文件处理主要使用java.io.File类 123456789101112public static void studyFile()&#123; File f = new File("src/main/java/Chapter7/Student.java"); System.out.println("The file is exists? --&gt;"+f.exists()); System.out.println("The file can write --&gt;"+f.canWrite()); System.out.println("The file can read --&gt;"+f.canRead()); System.out.println("The file is a file --&gt;"+f.isFile()); System.out.println("The file is a directory --&gt;"+f.isDirectory()); System.out.println("The file is absolute path --&gt;"+f.isAbsolute()); System.out.println("The file's name is --&gt;"+f.getName()); System.out.println("The file's path is --&gt;"+f.getPath()); System.out.println("The file's absolute path is --&gt;"+f.getAbsolutePath());&#125; RandomAccessFile指定位置的访问文件类 1234567891011121314151617181920public static void studyRandomAccessFile()&#123; RandomAccessFile raf = null; try &#123; raf = new RandomAccessFile("src/main/java/Chapter7/Student.java","rw"); raf.seek(10); System.out.println("point site:"+raf.getFilePointer()); System.out.println("context is :"+raf.readLine()); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; raf.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 图形界面设计Awt与Swingknowledge point: 1.图形用户界面（Graphical user interface ）简称GUI。 2.java.awt 或 javax.swing包含了多种用于创建图形用户界面的组件类 3.设计用户图形界面的步骤，选取组件——》设计布局——》响应事件 4.awt 与swing组件最大的不同是swing组件在实现时不包含任何本地代码，因此swing组件可以不受硬件平台的限制。所以swing组件也被称为”轻量级”组件，而包含本地代码的awt被称为”重量级”组件。 5.当重量级组件与轻量级组件一同使用时，如果组件区域有重叠，则”重量级”组件总是显示在最上面。 6.组件是构成图形用户界面的基本元素。如JButton、JTextField等。 7.组件可以划分为容器组件和非容器组件。 容器knowledge point： 1.容器组件是指可以包含其他组件的组件。 2.容器可以分为顶层容器和一般容器。 3.显示在屏幕上的所有非容器组件必须包含在某个容器中，有些容器是可以嵌套的，在这个嵌套层次的最外层，必须是一个顶层容器。 4.Java为所有容器定义了父类Container。 5.Swing 提供了4种顶层容器，分别为JFrame、JApplet、JDialog、JWindow。 6.关于JFrame 的example： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package chapter8;import javax.swing.*;import javax.swing.border.Border;import java.awt.*;/** * @className JFrameDome * @Descirption * @Author WengLiangBao * @Date 2020/5/11 上午11:29 * @Vsersion 1.0 */public class JFrameDome &#123; public static void studyJFrame1()&#123; JFrame frame = new JFrame("JFrame Dome"); JButton button = new JButton("Press me"); frame.getContentPane().add(button, BorderLayout.CENTER); frame.pack(); frame.setVisible(true); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; public static void studyJFrame2()&#123; JFrame frame = new JFrame("JFrame Dome"); JButton button = new JButton("Press me"); JPanel contentPane = new JPanel(); contentPane.setLayout(new BorderLayout()); frame.setContentPane(contentPane); contentPane.add(button,BorderLayout.CENTER); frame.pack(); frame.setVisible(true); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; public static void studyJFrame3()&#123; JFrame frame = new JFrame("Frame with Panel"); Container contentPane = frame.getContentPane(); contentPane.setBackground(Color.CYAN); JPanel panel = new JPanel(); panel.setBackground(Color.YELLOW); JButton button = new JButton("Press me"); panel.add(button); contentPane.add(panel,BorderLayout.SOUTH); frame.setSize(300,200); frame.setVisible(true); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; public static void studyJFrame4()&#123; JFrame frame = new JFrame("Frame with Panel and scrollPane"); frame.setSize(200,200); Container contentPane = frame.getContentPane(); contentPane.setBackground(Color.CYAN); JPanel mainPanel = new JPanel(); mainPanel.setBackground(Color.YELLOW); mainPanel.setSize(1000,600); //button JButton button = new JButton("Press me"); mainPanel.add(button); //ScrollPane JScrollPane scrollPane = new JScrollPane(contentPane); scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS); scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS); contentPane.add(scrollPane,BorderLayout.SOUTH); frame.setVisible(true); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; public static void studyJLabel()&#123; JFrame frame = new JFrame("JFrame with JLabel"); Container contentPane = frame.getContentPane(); JLabel label = new JLabel("This is label title"); contentPane.add(label,BorderLayout.CENTER); frame.pack(); frame.setVisible(true); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; public static void main(String[] args)&#123; studyJFrame1(); &#125;&#125; 内容窗格knowledge point： 1.获取内容窗格的2种方式： ​ a).JFrame下的getContentPane() ​ b).new JPanel,然后将新创建的JPanel通过JFrame的setContentPane放入。 面板knowledge point： 1.JPanel普通面板 ，JScrollPane滚动面板 2.面板不能单独存在，它需要被放入到顶层容器中，并且它自身是可以嵌套的。 3.关于面板的example： 1234567891011121314151617181920212223JFrame frame = new JFrame("Frame with Panel and scrollPane");frame.setSize(200,200);Container contentPane = frame.getContentPane();contentPane.setBackground(Color.CYAN);JPanel mainPanel = new JPanel();mainPanel.setBackground(Color.YELLOW);mainPanel.setSize(1000,600);//buttonJButton button = new JButton("Press me");mainPanel.add(button);//ScrollPaneJScrollPane scrollPane = new JScrollPane(contentPane);scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);contentPane.add(scrollPane,BorderLayout.SOUTH);frame.setVisible(true);frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 标签及按钮标签knowledge point： 1.JLable 标签类。 example： 12345678JFrame frame = new JFrame("JFrame with JLabel"); Container contentPane = frame.getContentPane(); JLabel label = new JLabel("This is label title"); contentPane.add(label,BorderLayout.CENTER); frame.pack(); frame.setVisible(true); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 按钮普通按钮knowledge point： JButton 123456789JFrame frame = new JFrame("JFrame Dome");JButton button = new JButton("Press me");JPanel contentPane = new JPanel();contentPane.setLayout(new BorderLayout());frame.setContentPane(contentPane);contentPane.add(button,BorderLayout.CENTER);frame.pack();frame.setVisible(true);frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 切换按钮knowledge point: 1.JToggle example: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package chapter8;import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;/** * @className JButtonExample * @Descirption * @Author WengLiangBao * @Date 2020/5/11 下午2:56 * @Vsersion 1.0 */public class JButtonExample extends WindowAdapter implements ActionListener &#123; JFrame f; JToggleButton b; JToggleButton b2; JToggleButton b3; JTextField tf; int tag = 0; public static void main(String[] args)&#123; JButtonExample be = new JButtonExample(); be.go(); &#125; private void go() &#123; f = new JFrame("JFrame Example"); b = new JToggleButton("press",false); b.addActionListener(this); tf = new JTextField(); f.getContentPane().add(tf,BorderLayout.CENTER); f.addWindowListener(this); f.setSize(300,150); f.setVisible(true); b2 = new JToggleButton("装饰",false); b2.setEnabled(false); b3 = new JToggleButton("装饰",false); b3.setEnabled(false); JPanel buttonPane = new JPanel(); buttonPane.add(b); buttonPane.add(b2); buttonPane.add(b3); f.getContentPane().add(buttonPane, BorderLayout.NORTH); &#125; public void pressStatus()&#123; tf.setText("You have pressed the Button!"); tag = 1; b.setSelected(true); b.setText("Spring"); &#125; public void springStatus()&#123; tf.setText("You do another time!"); tag = 0; b.setSelected(false); b.setText("Press"); &#125; public void actionPerformed(ActionEvent actionEvent) &#123; if(tag==0)&#123; pressStatus(); &#125;else &#123; springStatus(); &#125; &#125; @Override public void windowClosing(WindowEvent windowEvent) &#123; System.exit(0); &#125;&#125; 复选按钮knowledge option: 1.JCheckBox 单选按钮knowledge option: 1.JRadioButton 2.需要加入按钮组从而保证只有一个选项被选中 example: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206package chapter8;import javax.swing.*;import javax.swing.border.Border;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.ItemEvent;import java.awt.event.ItemListener;/** * @className TowStateButtonDome * @Descirption * @Author WengLiangBao * @Date 2020/5/11 下午3:38 * @Vsersion 1.0 */public class TowStateButtonDome implements ItemListener, ActionListener &#123; JFrame frame; JButton clearButton; JCheckBox cb1; JCheckBox cb2; JCheckBox cb3; JCheckBox cb4; JCheckBox cb5; JCheckBox cb6; JRadioButton rb1; JRadioButton rb2; JRadioButton rb3; JRadioButton rb4; JRadioButton rb5; JRadioButton rb6; JTextArea ta; public TowStateButtonDome()&#123; this.frame = new JFrame("Two states Button Dome"); this.cb1 = new JCheckBox("JCheckBox 1"); this.cb2 = new JCheckBox("JCheckBox 2"); this.cb3 = new JCheckBox("JCheckBox 3"); this.cb4 = new JCheckBox("JCheckBox 4"); this.cb5 = new JCheckBox("JCheckBox 5"); this.cb6 = new JCheckBox("JCheckBox 6"); this.rb1 = new JRadioButton("JRadioButton 1"); this.rb2 = new JRadioButton("JRadioButton 2"); this.rb3 = new JRadioButton("JRadioButton 3"); this.rb4 = new JRadioButton("JRadioButton 4"); this.rb5 = new JRadioButton("JRadioButton 5"); this.rb6 = new JRadioButton("JRadioButton 6"); this.ta = new JTextArea(); this.clearButton = new JButton("clear"); &#125; public static void main(String[] args)&#123; TowStateButtonDome tbd = new TowStateButtonDome(); tbd.go(); &#125; private void go() &#123; //panel JPanel p1 = new JPanel(); JPanel p2 = new JPanel(); JPanel p3 = new JPanel(); JPanel p4 = new JPanel(); JPanel p5 = new JPanel(); JPanel pa = new JPanel(); JPanel pb = new JPanel(); JPanel topPane = new JPanel(); p1.add(cb1); p1.add(cb2); p1.add(cb3); Border etched = BorderFactory.createEtchedBorder(); Border border = BorderFactory.createTitledBorder(etched,"JCheckBox"); p1.setBorder(border); p2.add(cb4); p2.add(cb5); p2.add(cb6); border = BorderFactory.createTitledBorder(etched,"JCheckBox Group"); p2.setBorder(border); ButtonGroup group1 = new ButtonGroup(); group1.add(cb4); group1.add(cb5); group1.add(cb6); p3.add(rb1); p3.add(rb2); p3.add(rb3); border = BorderFactory.createTitledBorder(etched,"JRadioButton"); p3.setBorder(border); p4.add(rb4); p4.add(rb5); p4.add(rb6); border = BorderFactory.createTitledBorder(etched,"JRadioButton Group"); p4.setBorder(border); ButtonGroup group2 = new ButtonGroup(); group2.add(rb4); group2.add(rb5); group2.add(rb6); JScrollPane jp = new JScrollPane(ta); p5.setLayout(new BorderLayout()); p5.add(jp); border = BorderFactory.createTitledBorder(etched,"Results"); p5.setBorder(border); cb1.addItemListener(this); cb2.addItemListener(this); cb3.addItemListener(this); cb4.addItemListener(this); cb5.addItemListener(this); cb6.addItemListener(this); rb1.addActionListener(this); rb2.addActionListener(this); rb3.addActionListener(this); rb4.addActionListener(this); rb5.addActionListener(this); rb6.addActionListener(this); clearButton.addActionListener(this); pa.setLayout(new GridLayout(0,1)); pa.add(p1); pa.add(p2); pb.setLayout(new GridLayout(0,1)); pb.add(p3); pb.add(p4); topPane.add(this.clearButton); Container contentPane = frame.getContentPane(); contentPane.setLayout(new GridLayout(0,1)); contentPane.add(topPane); contentPane.add(pa); contentPane.add(pb); contentPane.add(p5); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.pack(); frame.setVisible(true); &#125; public void itemStateChanged(ItemEvent itemEvent) &#123; JCheckBox cb = (JCheckBox) itemEvent.getSource(); if(cb == cb1)&#123; ta.append("\n JCheckBox button 1 "+cb1.isSelected()); &#125;else if(cb == cb2)&#123; ta.append("\n JCheckBox button 2 "+cb2.isSelected()); &#125;else if(cb == cb3)&#123; ta.append("\n JCheckBox button 3 "+cb3.isSelected()); &#125;else if(cb == cb4)&#123; ta.append("\n JCheckBox button 4 "+cb4.isSelected()); &#125;else if(cb == cb5)&#123; ta.append("\n JCheckBox button 5 "+cb5.isSelected()); &#125;else if(cb == cb6)&#123; ta.append("\n JCheckBox button 6 "+cb6.isSelected()); &#125; &#125; public void actionPerformed(ActionEvent actionEvent) &#123; if(actionEvent.getSource() instanceof JRadioButton)&#123; JRadioButton rb = (JRadioButton) actionEvent.getSource(); if(rb == rb1)&#123; ta.append("\n You selected RadioButton 1 "+rb1.isSelected()); &#125;else if(rb == rb2)&#123; ta.append("\n You selected RadioButton 2 "+rb2.isSelected()); &#125;else if(rb == rb3)&#123; ta.append("\n You selected RadioButton 3 "+rb3.isSelected()); &#125;else if(rb == rb4)&#123; ta.append("\n You selected RadioButton 4 "+rb4.isSelected()); &#125;else if(rb == rb5)&#123; ta.append("\n You selected RadioButton 5 "+rb5.isSelected()); &#125;else if(rb == rb6)&#123; ta.append("\n You selected RadioButton 6 "+rb6.isSelected()); &#125; &#125;else if(actionEvent.getSource() instanceof JButton)&#123; JButton b = (JButton) actionEvent.getSource(); if(b == clearButton)&#123; ta.setText(""); &#125; &#125; &#125;&#125; 布局管理器knowledge option： 1.布局用来管理容器中各组件的位置分布。 流式布局（Flow layout）knowledge option: 1.JPanel 的默认布局方式就是流式布局 流式布局如下代码所示 12345678910111213141516171819202122232425262728293031323334353637package chapter8;import java.awt.*;import javax.swing.*;public class FlowLayoutDemo&#123; private JFrame frame; private JButton button1,button2,button3; public FlowLayoutDemo()&#123; this.frame = new JFrame("Flow Layout"); this.button1 = new JButton("ok"); this.button2 = new JButton("open"); this.button3 = new JButton("close"); &#125; public static void main(String[] args)&#123; FlowLayoutDemo fld = new FlowLayoutDemo(); fld.go(); &#125; public void go()&#123; Container contentPane = frame.getContentPane(); contentPane.setLayout(new FlowLayout()); contentPane.add(button1); contentPane.add(button2); contentPane.add(button3); frame.setSize(200,100); frame.setVisible(true); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125;&#125; 边界布局（Border layout）knowledge option： 1.内容窗口的默认布局为Border layout borderlayout布局如下代码所示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package chapter8;import java.awt.*;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import javax.swing.*;public class BorderLayoutDemo extends WindowAdapter &#123; private JFrame frame; private JButton button1,button2,button3,button4,button5; public BorderLayoutDemo()&#123; this.frame = new JFrame("Border Layout"); this.button1 = new JButton("button1"); this.button2 = new JButton("button2"); this.button3 = new JButton("button3"); this.button4 = new JButton("button4"); this.button5 = new JButton("button5"); &#125; public static void main(String[] args)&#123; BorderLayoutDemo bld = new BorderLayoutDemo(); bld.go(); &#125; public void go()&#123; Container contentPane = frame.getContentPane(); contentPane.add(button1,BorderLayout.EAST); contentPane.add(button2,BorderLayout.SOUTH); contentPane.add(button3,BorderLayout.WEST); contentPane.add(button4,BorderLayout.NORTH); contentPane.add(button4,BorderLayout.CENTER); frame.setSize(350,200); frame.setVisible(true); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; @Override public void windowClosing(WindowEvent windowEvent) &#123; super.windowClosing(windowEvent); System.exit(0); &#125;&#125; 网格布局（Grid layout）knowledge option: Gridlayout 是一种网格式的布局管理器，它将容器空间划分成若干行乘若干列的网格，组件依次放入其中，每个组件占一格。 example： 12345678910111213141516171819202122232425262728293031323334353637package chapter8;import java.awt.*;import javax.swing.*;public class GirdLayoutDemo extends JFrame&#123; private JButton b1,b2,b3,b4,b5,b6; GirdLayoutDemo()&#123; setTitle("Grid example"); Container contentPane = getContentPane(); contentPane.setPreferredSize(new Dimension(400,350)); contentPane.setLayout(new GridLayout(3,2)); b1 = new JButton("grid_1"); b2 = new JButton("grid_2"); b3 = new JButton("grid_3"); b4 = new JButton("grid_4"); b5 = new JButton("grid_5"); b6 = new JButton("grid_6"); contentPane.add(b1); contentPane.add(b2); contentPane.add(b3); contentPane.add(b4); contentPane.add(b5); contentPane.add(b6); pack(); setVisible(true); &#125; public static void main(String[] args)&#123; GirdLayoutDemo gld = new GirdLayoutDemo(); gld.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125;&#125; 卡片布局 (Card layout)knowledge point: card layout 是一种卡片式布局管理器，它将容器中的组件处理为一系列的卡片，每一时刻显示其中的一张。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package chapter8;import java.awt.*;import java.awt.event.*;import javax.swing.*;public class CardLayoutDemo extends MouseAdapter&#123; JPanel p1,p2,p3; JLabel l1,l2,l3; CardLayout myCard; JFrame frame; Container contentPane; public static void main(String[] args)&#123; CardLayoutDemo that = new CardLayoutDemo(); that.go(); that.rotation(); &#125; public void go()&#123; frame = new JFrame("Card Test"); contentPane = frame.getContentPane(); myCard = new CardLayout(); contentPane.setLayout(myCard); p1 = new JPanel(); p2 = new JPanel(); p3 = new JPanel(); l1 = new JLabel("This is the first JPanel"); p1.add(l1); p1.setBackground(Color.green); l2 = new JLabel("This is the second JPanel"); p2.add(l2); p2.setBackground(Color.yellow); l3 = new JLabel("This is the thrid JPanel"); p3.add(l3); p3.setBackground(Color.magenta); p1.addMouseListener(this); p2.addMouseListener(this); p3.addMouseListener(this); contentPane.add(p1,"First"); contentPane.add(p2,"Second"); contentPane.add(p3,"Third"); myCard.show(contentPane,"First"); frame.setSize(300,200); frame.setVisible(true); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; public void rotation()&#123; while(true)&#123; System.out.println("start"); myCard.next(contentPane); try &#123; Thread.sleep(1000l); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public void mouseClicked(MouseEvent e)&#123; myCard.next(contentPane); &#125;&#125; 盒子布局（Box layout）knowledge point： boxLayout 是一种特殊的布局管理器，它将容器中的组件按照水平方向组成一行，垂直方向组成一列。当组成行时，组件与组件间可以设定不同的宽度，当组成列时组件与组件间可以有不同的高度。 example： 12345678910111213141516171819202122232425262728293031323334package chapter8;import java.awt.*;import javax.swing.*;public class BoxLayoutDemo&#123; private JFrame frame; private JPanel pv,ph; public static void main(String[] args)&#123; BoxLayoutDemo that = new BoxLayoutDemo(); that.go(); &#125; void go()&#123; frame = new JFrame("Box Layout example"); Container contentPane = frame.getContentPane(); pv = new JPanel(); pv.setLayout(new BoxLayout(pv,BoxLayout.Y_AXIS)); pv.add(new JLabel("First")); pv.add(new JLabel("Second")); pv.add(new JLabel("Thrid")); contentPane.add(pv,BorderLayout.CENTER); ph = new JPanel(); ph.setLayout(new BoxLayout(ph,BoxLayout.X_AXIS)); ph.add(new JButton("yes")); ph.add(new JButton("no")); ph.add(new JButton("cancel")); contentPane.add(ph,BorderLayout.SOUTH); frame.pack(); frame.setVisible(true); &#125;&#125; 空布局knowledge point: 空布局就是不使用布局，通过组件中的setBounds方法来设定组件的位置和大小。 example： 12345678910111213141516171819202122232425262728293031323334package chapter8;import java.awt.*;import javax.swing.*;public class NullLayoutDemo&#123; private JFrame frame; private JButton b1,b2,b3; public static void main(String[] args)&#123; NullLayoutDemo that = new NullLayoutDemo(); that.go(); &#125; void go()&#123; frame = new JFrame("Null Layout example"); Container contentPane = frame.getContentPane(); contentPane.setLayout(null); b1 = new JButton("yes"); b2 = new JButton("no"); b3 = new JButton("cancel"); contentPane.add(b1); contentPane.add(b2); contentPane.add(b3); b1.setBounds(30,15,75,20); b2.setBounds(60,60,75,50); b3.setBounds(160,20,75,30); frame.setSize(300,200); frame.setVisible(true); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125;&#125; 事件处理knowledge point： 用户事件：程序里用户的操作称为用户事件。 事件处理：对用户事件的响应称为事件处理 事件的种类 事件类型 组件 接口名称 方法及说明 action event JButton、JCheckBox、JComboBox、JMenuItem、JRadioButton ActionListener actionPerformed(Action Event)单机按钮、选择菜单 项目或在文本框中按enter键时 事件适配器knowledge point： 适配器主要是针对接口使用的优化，它实现了多个接接口，但是方法体内是空的，自己使用时只需要继承它并重写需要使用的方法。 swing组件组合框（JComboBox）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package chapter9;import javax.swing.*;import javax.swing.border.Border;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;/** * @className JComboBoxDemo * @Descirption * @Author WengLiangBao * @Date 2020/5/18 下午3:14 * @Vsersion 1.0 */public class JComboBoxDemo implements ActionListener &#123; JFrame frame; JComboBox&lt;String&gt; jcb1,jcb2; JTextArea textArea; public JComboBoxDemo()&#123; frame = new JFrame("JComboBox DEmo"); String[] list = &#123;"one","tow","three","four","five"&#125;; jcb1 = new JComboBox&lt;String&gt;(list); jcb2 = new JComboBox&lt;String&gt;(); jcb2.addItem("six"); jcb2.addItem("seven"); jcb2.addItem("eight"); jcb2.addItem("nine"); jcb2.addItem("ten"); jcb2.setEnabled(true); textArea = new JTextArea(); &#125; public static void main(String[] args)&#123; JComboBoxDemo m = new JComboBoxDemo(); m.go(); &#125; private void go() &#123; JPanel p1 = new JPanel(); JPanel p2 = new JPanel(); JPanel p3 = new JPanel(); JPanel p4 = new JPanel(); p1.add(jcb1); jcb1.setSelectedIndex(3); Border etchedBorder = BorderFactory.createEtchedBorder(); Border border = BorderFactory.createTitledBorder(etchedBorder,"uneditable jCombobox"); p1.setBorder(border); p2.add(jcb2); p2.setBorder(BorderFactory.createTitledBorder(etchedBorder,"editable jComboBox")); JScrollPane jp = new JScrollPane(textArea); p3.add(jp); p3.setBorder(BorderFactory.createTitledBorder(etchedBorder,"result")); jcb1.addActionListener(this); jcb2.addActionListener(this); p4.setLayout(new GridLayout(0,1)); p4.add(p1); p4.add(p2); Container contentPane = frame.getContentPane(); contentPane.setLayout(new GridLayout(0,1)); contentPane.add(p3); contentPane.add(p4); frame.setSize(300,400); frame.setVisible(true); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; public void actionPerformed(ActionEvent actionEvent) &#123; JComboBox jcb = (JComboBox) actionEvent.getSource(); if(jcb == jcb1)&#123; jcb2.insertItemAt((String) jcb1.getSelectedItem(),0); textArea.append("\n item "+jcb1.getSelectedItem()+" inserted"); &#125;else if(jcb == jcb2)&#123; textArea.append("\n item "+jcb2.getSelectedItem()+" inserted"); jcb2.addItem((String) jcb2.getSelectedItem()); &#125; &#125;&#125; 列表（JList）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package chapter9;import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;/** * @className JListDemo * @Descirption * @Author WengLiangBao * @Date 2020/5/18 下午4:56 * @Vsersion 1.0 */public class JListDemo implements ActionListener &#123; JFrame frame; JList list; DefaultListModel listModel; JPanel panel; JTextField textField; JButton button; public JListDemo()&#123; frame = new JFrame("JList Demo"); listModel = new DefaultListModel(); listModel.addElement("one"); listModel.addElement("two"); listModel.addElement("three"); listModel.addElement("four"); list = new JList(listModel); panel = new JPanel(); textField = new JTextField(15); button = new JButton("add new item"); &#125; public static void main(String[] args)&#123; new JListDemo().go(); &#125; private void go() &#123; button.addActionListener(this); JScrollPane jsp = new JScrollPane(list, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS); Container contentPane = frame.getContentPane(); contentPane.add(jsp); panel.add(textField); panel.add(button); contentPane.add(panel, BorderLayout.SOUTH); frame.pack(); frame.setVisible(true); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; public void actionPerformed(ActionEvent actionEvent) &#123; listModel.addElement(textField.getText()); &#125;&#125; 文本域（JTextField）和 文本区(JTextArea)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package chapter9;import javax.swing.*;import javax.swing.border.Border;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;/** * @className JTextAreaDemo * @Descirption * @Author WengLiangBao * @Date 2020/5/18 下午4:25 * @Vsersion 1.0 */public class JTextAreaDemo implements ActionListener &#123; JFrame frame; JTextArea textArea1,textArea2; JButton copy,clear; public JTextAreaDemo()&#123; frame = new JFrame("JTextArea Demo"); textArea1 = new JTextArea(3,15); textArea2 = new JTextArea(7,20); copy = new JButton("copy"); clear = new JButton("clear"); &#125; public static void main(String[] args)&#123; JTextAreaDemo m = new JTextAreaDemo(); m.go(); &#125; private void go() &#123; textArea1.setSelectionColor(Color.RED); textArea2.setEnabled(false); JScrollPane jsp1 = new JScrollPane(textArea1,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS); JScrollPane jsp2 = new JScrollPane(textArea2,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS); copy.addActionListener(this); clear.addActionListener(this); JPanel panel1 = new JPanel(); JPanel panel2 = new JPanel(); Border etchedBase = BorderFactory.createEtchedBorder(); panel1.setBorder(BorderFactory.createTitledBorder(etchedBase,"输入区")); panel2.setBorder(BorderFactory.createTitledBorder(etchedBase,"复制区")); panel1.add(jsp1); panel1.add(copy); panel2.add(jsp2); panel2.add(clear); Container contentPane = frame.getContentPane(); contentPane.add(panel1,BorderLayout.CENTER); contentPane.add(panel2, BorderLayout.SOUTH); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.pack(); frame.setVisible(true); &#125; public void actionPerformed(ActionEvent actionEvent) &#123; JButton button = (JButton) actionEvent.getSource(); if(button == copy)&#123; if(textArea1.getSelectedText()!=null)&#123; textArea2.append(textArea1.getSelectedText()+"\n"); &#125;else&#123; textArea2.append(textArea1.getText()+"\n"); &#125; &#125;else if(button ==clear)&#123; textArea2.setText(""); &#125; &#125;&#125; 菜单栏（JMenuBar）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138package chapter9;import javax.swing.*;import java.awt.*;import java.awt.event.*;import java.security.Key;/** * @className MenuDemo * @Descirption * @Author WengLiangBao * @Date 2020/5/18 上午10:15 * @Vsersion 1.0 */public class MenuDemo implements ItemListener, ActionListener &#123; JFrame frame; JTextField ft; JMenuBar menuBar; JDialog backgroundDialog; public MenuDemo()&#123; this.frame = new JFrame("Menu Demo"); this.ft = new JTextField(); this.menuBar = new JMenuBar(); &#125; public static void main(String[] args)&#123; MenuDemo md = new MenuDemo(); md.go(); &#125; private void go() &#123; JMenu menu,submenu; //menu file menu = new JMenu("File"); frame.setJMenuBar(menuBar); menu.setMnemonic(KeyEvent.VK_F); menu.add(menu); menuBar.add(menu); //menu item open JMenuItem menuItem = new JMenuItem("open"); menuItem.setMnemonic(KeyEvent.VK_O); menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_1,ActionEvent.ALT_MASK)); menuItem.addActionListener(this); menu.add(menuItem); //menu item save menuItem = new JMenuItem("save",KeyEvent.VK_S); menuItem.addActionListener(this); menuItem.setEnabled(false); menu.add(menuItem); //menu item close menuItem = new JMenuItem("close",KeyEvent.VK_C); menuItem.addActionListener(this); menu.add(menuItem); menu.add(new JSeparator()); //menu item exit menuItem = new JMenuItem("Exit",KeyEvent.VK_E); menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_2,ActionEvent.ALT_MASK)); menuItem.addActionListener(this); menu.add(menuItem); //menu option menu = new JMenu("Option"); menuBar.add(menu); menu.add("Font..."); //menu item color submenu = new JMenu("Color..."); menu.add(submenu); //menu item foreground menuItem = new JMenuItem("Foreground"); menuItem.addActionListener(this); menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_2,ActionEvent.ALT_MASK)); submenu.add(menuItem); //menu item background initialBackground(submenu,menu); //check box menu JCheckBoxMenuItem cm = new JCheckBoxMenuItem("Always on Top"); cm.addItemListener(this); menu.add(cm); menu.addSeparator(); JRadioButtonMenuItem rm = new JRadioButtonMenuItem("Small",true); rm.addItemListener(this); menu.add(rm); ButtonGroup group = new ButtonGroup(); group.add(rm); rm = new JRadioButtonMenuItem("Large"); rm.addItemListener(this); menu.add(rm); group.add(rm); //help of menu menu = new JMenu("help"); menuBar.add(menu); // menu item about menuItem = new JMenuItem("about",new ImageIcon("duckWaveRed.gif")); menuItem.addActionListener(this); menu.add(menuItem); ft.setEnabled(false); Container contentPane = frame.getContentPane(); contentPane.add(ft, BorderLayout.SOUTH); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setSize(300,200); frame.setVisible(true); &#125; private void initialBackground(JMenuItem submenu,JMenu menu) &#123; JMenuItem menuItem = new JMenuItem("background"); menuItem.addActionListener(this); menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_3,ActionEvent.ALT_MASK)); submenu.add(menuItem); menu.add(new JSeparator()); backgroundDialog = MyDialogFactory.getDialog(frame); &#125; public void actionPerformed(ActionEvent actionEvent) &#123; ft.setText(actionEvent.getActionCommand()); String menuName = actionEvent.getActionCommand(); if (menuName == "Exit")&#123; System.exit(0); &#125;else if(menuName == "background")&#123; backgroundDialog.setVisible(true); &#125; &#125; public void itemStateChanged(ItemEvent itemEvent) &#123; int state = itemEvent.getStateChange(); JMenuItem menuItem = (JMenuItem) itemEvent.getSource(); if (state == ItemEvent.SELECTED)&#123; ft.setText(menuItem.getText()+"Selected"); &#125;else if(state == ItemEvent.DESELECTED)&#123; ft.setText(menuItem.getText()+"deselected"); &#125; &#125;&#125; 对话框(JDialog)123456789101112131415161718192021222324252627282930313233343536373839404142434445package chapter9;import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;/** * @className JDialogDemo * @Descirption * @Author WengLiangBao * @Date 2020/5/18 下午1:57 * @Vsersion 1.0 */public class JDialogDemo implements ActionListener &#123; JFrame frame; JDialog dialog; JButton button; public JDialogDemo()&#123; frame = new JFrame("JDialog Demo"); dialog = new JDialog(frame,"Dialog",true); dialog.setSize(600,400); button = new JButton("Show Dialog"); &#125; public static void main(String[] args)&#123; JDialogDemo jd = new JDialogDemo(); jd.go(); &#125; private void go() &#123; dialog.getContentPane().add(new Label("hello, I'm a Dialog")); button.addActionListener(this); frame.getContentPane().add(button, BorderLayout.SOUTH); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setSize(200,150); frame.setVisible(true); &#125; public void actionPerformed(ActionEvent actionEvent) &#123; dialog.setVisible(true); &#125;&#125; JFileChooser12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package chapter9;import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.io.File;/** * @className JFileChooserDemo * @Descirption * @Author WengLiangBao * @Date 2020/5/18 下午2:35 * @Vsersion 1.0 */public class JFileChooserDemo implements ActionListener &#123; JFrame frame; JFileChooser fc; JTextField textField; JButton openButton,saveButton,deletedButton; public JFileChooserDemo()&#123; frame = new JFrame("JFile chooser demo"); fc = new JFileChooser(); textField = new JTextField(); openButton = new JButton("Open a file"); saveButton = new JButton("Save file"); deletedButton = new JButton("Deleted file"); &#125; public static void main(String[] args)&#123; JFileChooserDemo m = new JFileChooserDemo(); m.go(); &#125; public void go()&#123; openButton.addActionListener(this); saveButton.addActionListener(this); deletedButton.addActionListener(this); JPanel jp = new JPanel(); jp.add(openButton); jp.add(saveButton); jp.add(deletedButton); Container contentPane = frame.getContentPane(); contentPane.add(textField, BorderLayout.CENTER); contentPane.add(jp, BorderLayout.SOUTH); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setSize(300,200); frame.setVisible(true); &#125; public void actionPerformed(ActionEvent actionEvent) &#123; Object source = actionEvent.getSource(); if(source instanceof JButton)&#123; JButton button = (JButton) source; if(button == openButton)&#123; int select = fc.showOpenDialog(frame); if(select == JFileChooser.APPROVE_OPTION)&#123; File file =fc.getSelectedFile(); textField.setText("Opening: "+file.getName()); &#125;else &#123; textField.setText("Open command cancelled by user"); &#125; &#125;else if(button == saveButton)&#123; int select = fc.showSaveDialog(frame); if(select == JFileChooser.APPROVE_OPTION)&#123; File file = fc.getSelectedFile(); textField.setText("Saving: "+file.getName()); &#125;else&#123; textField.setText("Save command cancelled by user"); &#125; &#125;else if(button == deletedButton)&#123; int select = fc.showDialog(frame, "删除"); if(select == JFileChooser.APPROVE_OPTION)&#123; File file = fc.getSelectedFile(); textField.setText("deleting : "+file.getName()); &#125;else&#123; textField.setText("Delete command cancelled by user"); &#125; &#125; &#125; &#125;&#125; 多线程线程的理论知识线程的概念knowledge point: 1.进程可以大致描述为，占用系统资源的一个程序。 2.线程是进程中的产物。 3.多个线程共享进程中的资源。而多个进程未必共享指定的系统资源。 4.进程是有入口和出口的，而线程则没有，它需要依附于进程中的主线程或其余线程启动。 5.线程间的切换速度高于进程间的切换速度。 6.多线程程序可以充分利用系统资源，特别是CUP的使用效率。从而提高程序的整体执行效率 7.Java中的线程执行顺序是抢占式的，而不是时间碎片式。 线程的结构knowledge point： java中线程由以下3部分组成： 1.虚拟CPU，封装在java.lang.Thread 类中，它控制着整个线程的运行。 2.执行代码，传递给Thread类，有Thread类控制按序执行。 3.处理的数据，传递给Thread类，是在代码执行过程中所要处理的数据。 线程的状态knowledge point： 线程的状态分为： 1.新建 ：线程对象刚刚创建，还没有启动。此时还处于不可运行状态。此时刚创建的线程处于新建状态，但已有了相应的内存空间以及其他资源。 2.可运行状态：此时的线程已经启动，处于线程的run()方法之中。这种情况下的线程可能正在运行，也可能没有运行。只要CPU一空闲，马上就会运行。可以运行但没有在运行的线程都排在一个队列中，这个队列称为就绪队列。可运行状态中，正在运行的线程处于运行状态，等待运行的线程处于就绪状态。一般的，单CPU情况下，最多只有一个线程处于运行状态，其余队列中的等待的线程处于就绪状态。 3.死亡：线程死亡的原因有两个，1是run方法中最后一个语句执行完毕，2是当线程遇到异常退出时便进入了死亡状态。 4.阻塞：阻塞状态时的线程不能进入等待队列，需要消除阻塞原因才可以进入等待队列,因被抢占而阻塞的线程会被放置队列的尾部 5.中断线程：程序中使用Thread下的interrupt方法来终止线程。它不仅可以终止平常线程而且还可以终止blocked线程 线程实践线程的创建knowledge point： 1.通过继承Thread类并重写run方法来实现 2.通过实现Runnable,并将其放入Thread类中实现 评价：第一种方法方便灵活，当时局限于Java的单继承。第二种方法可以弥补第一种方法的缺陷。 线程的启动通过创建线程对象然后调用其start方法 线程的调度knowledge point: 1.Java中，线程的调度通常是抢占式的，而不是时间碎片式。 2.java线程调度采用的优先策略规则： 优先级高的先执行，优先级低的后执行。 每一个线程都必须被分配一个优先级，默认时子类继承父类的优先级。 同优先级的线程按“先进先出”的规则执行。 3.Thread类与线程有关的静态变量，如下： MAX_PRIORITY 最大优先级，值为10. MIN_PRIORITY 最小优先级，值为1. NORM_PRIORITY 默认优先级，值为5. 4.Thread类中有关优先级的几个常用方法如下： setPriority(int newPriority) getPriority() yield（） 线程的结束knowledge point： 自然死亡：线程体run方法内的代码执行完毕。 强迫死亡：因异常而终止的情况下。 interrupt 可以中断线程的执行 挂起线程knowledge point： sleep wait notify notifyAll join 线程的互斥互斥的由来： 通常情况下，一些运行的线程需要共享一些数据。此时，每个线程就必须要考虑与它一起共享数据的其他线程的状态与行为，否则就不能保证共享数据的一致性。因而也不能保证程序的正确性。 举例说明： 假设有一个MyStack类，类中的index是多个线程要操作的公共资源。如果不加对象互斥锁 可以发现，输出的信息中出现了线程并发修改index的情况。 总结：导致上述案例出现问题的原因是“对公共资源操作的不完整性”而产生的。 如何解决上述问题呢？答案是使用对象互斥锁 java中实现对象互斥锁的方法： 使用关键字volatile 来声明一个共享数据（变量） 使用关键字synchronized来声明操作共享数据的一个方法或一个代码块 使用synchronized的代码区也称为临界区 knowledge point： 实现线程互斥时，run方法内操作的内容需要是多个线程共享的，static修饰可实现。如果其中的内容是属于每个线程对象的，则不能实现线程的互斥。也就是说想要被互斥的代码块必须是多个线程共享的内容。 sleep 方法不会释放锁。而wait()会释放锁 example： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package chapter10;/** * @className Stack * @Descirption * @Author WengLiangBao * @Date 2020/5/20 上午11:10 * @Vsersion 1.0 */public class MyStack &#123; static int index = 0; public static void main(String[] args)&#123; for(int i =0;i&lt;10;i++)&#123; Thread s = new Thread(new Containers(),"thread 1"); Thread s1 = new Thread(new Containers(),"thread 2"); s.start(); s1.start(); &#125; &#125; public void changeIndex()&#123; synchronized(this)&#123; System.out.println(Thread.currentThread().getName()+"index: "+index); try &#123; Thread.sleep(1000l); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; index++; &#125; &#125;&#125;class Containers implements Runnable&#123; public static MyStack myStack = new MyStack(); public void run() &#123; System.out.println("Mystack DI is:"+myStack); myStack.changeIndex(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package chapter10;/** * @className MyStack2 * @Descirption * @Author WengLiangBao * @Date 2020/5/20 下午2:25 * @Vsersion 1.0 */public class MyStack2 extends Thread &#123; static int index = 0; public static synchronized void changeIndex()&#123; System.out.println("index: "+index); try &#123; Thread.sleep(1000l); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; index++; &#125; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); changeIndex(); &#125; public static void main(String[] args)&#123; for(int i=0;i&lt;10;i++)&#123; MyStack2 m = new MyStack2(); m.start(); &#125; &#125;&#125;class Runnable&#123; static int index = 0; public void changeIndex()&#123; synchronized (this)&#123; System.out.println(Thread.currentThread().getName()+"index: "+index); try &#123; Thread.sleep(1000l); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; index++; &#125; &#125;&#125; 线程的同步线程同步的由来： 主要是为了实现线程间的交互。 案例说明： 如，现在我们有3个类 生产者（producer）消费者（consumer）容器（Container），现在有一个需求，操作流程是这样的。生产者需要生产10个盘子（plate）到容器中，而消费者需要消费容器中的盘子。运行条件是1个消费者 2个生产者1个容器。要求用程序来模拟这个情景 knowledge point： java中的每个对象实例都有2个线程队列和它相连。第一个是用来排列等待锁定标志的线程。第二个用来实现wait()和notify/notifyAll的交互机制 wait、notify、notifyAll 只能在synchronized代码块中使用。 1234567891011121314151617181920212223242526272829303132333435package chapter10;/** * @className ThreadStudy * @Descirption * @Author WengLiangBao * @Date 2020/5/20 下午3:53 * @Vsersion 1.0 */public class ThreadStudy &#123; public static Container container = new Container(); public static int totalPlate = 10; public void run()&#123; while (totalPlate&gt;0)&#123; Producer p1 = new Producer("producer 1号"); Consumer c1 = new Consumer("consumer 1号"); p1.start(); c1.start(); try &#123; Thread.sleep(1000l); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.exit(0); &#125; public static void main(String[] ars)&#123; new ThreadStudy().run(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243package chapter10;/** * @className Producer * @Descirption * @Author WengLiangBao * @Date 2020/5/20 下午3:55 * @Vsersion 1.0 */public class Producer extends Thread &#123; static int pNo = 1; public Producer(String s) &#123; super(); setName(s); &#125; public static void method1() &#123; if(ThreadStudy.totalPlate&lt;=0||pNo&gt;10)&#123; return; &#125; //此处锁不能是对象本身,如果是对象本身wait等待后者不能被唤醒,所以使用container当前消费者和生产者中间交互的容器. synchronized (ThreadStudy.container) &#123; System.out.println(currentThread().getName() + " in start run"); System.out.println("生产了一个盘子,盘子号：" + pNo); ThreadStudy.container.pushPlate(String.valueOf(pNo)); pNo++; ThreadStudy.container.notifyAll(); try &#123; ThreadStudy.container.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void run() &#123; method1(); &#125;&#125; 1234567891011121314151617181920212223package chapter10;import java.util.Vector;/** * @className Container * @Descirption * @Author WengLiangBao * @Date 2020/5/19 下午1:34 * @Vsersion 1.0 */public class Container extends Vector &#123; public void pushPlate(String plate)&#123; this.add(plate); &#125; public String getPlate()&#123; String result = (String) firstElement(); remove(0); return result; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344package chapter10;/** * @className Consumer * @Descirption * @Author WengLiangBao * @Date 2020/5/20 下午3:55 * @Vsersion 1.0 */public class Consumer extends Thread &#123; public Consumer(String s) &#123; super(); setName(s); &#125; public static void method1() &#123; //此处锁不能是对象本身,如果是对象本身wait等待后者不能被唤醒,所以使用container当前消费者和生产者中间交互的容器. if(ThreadStudy.totalPlate&lt;=0)&#123; return; &#125; synchronized (ThreadStudy.container) &#123; Container container = ThreadStudy.container; System.out.println(currentThread().getName() + " in start run"); if (container.size() &gt; 0) &#123; System.out.println("消费了一个盘子，盘子号：" + container.getPlate()); ThreadStudy.totalPlate--; &#125; else &#123; System.out.println("没有盘子回去歇会吧！"); &#125; ThreadStudy.container.notifyAll(); try &#123; ThreadStudy.container.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void run() &#123; method1(); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[English-语法]]></title>
    <url>%2FMeBlog%2F2020%2F05%2F08%2FEnglish-%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[主语定义: 一个句子所要描述的对象就是主语. 比如我是中国人中的我就是主语 定语简介：修饰或限定名词的词语叫做定语。也就是说定语只跟名词有关系 chinese example： 注：下划线部分为定语 我的书 美丽善良的姑娘 昨天晚上你买的书 前置定语简介：放在名词前面的定语叫做前置定语 English example： 注：下划线部分为定语 my book your house Her house His house Its house Our house Their house 名词(n)定义:世界万物的名称可以称为名词 普通名词可数名词不可数名词专有名词数词(num)代词简介： 代词是为了避免重复使用名词时用来替代名词的词语。 代词的分类（9类）： 人称代词简介：人称代词就是代替人或有生命的名词，如我你它 主格： I You She He It We They 我 你 她 他 它 我们 他们/她们/它们 宾格： Me You Her Him It Us Them 我 你 她 他 它 我们 他们/她们/它们 English example: 1234567891011121314151617181920212223She is happyThey are excitedWe learn FrenchI like musicHe is a studentThey are teachersIt is cheap做宾格的例子 exampleI like herI support themHe teaches us EnglishThey belive me 人称代词的作用可以做主语（主格）、宾语(宾格)、表语 主格和宾格都可以作表语如： Who is it It is me/I 物主代词简介：表示所有关系的代词叫物主代词 形容词性物主代词 My Your Her His Its Our Their 我的 你的/你们的 她的 他的 它的 我们的 他们的/她们的/它们的 名词性物主代词 Mine Yours Hers His Its Ours Theirs 我的 你的/你们的 她的 他的 它的 我们的 他们的/她们的/它们的 形容词性物主代词和名词性物主代词的区分:Chinese example: 注：下划线部分为定语 1.这是我的书 其中的”我的”在中文里是定语，修饰名词”书”。所以这里的”我的”翻译成英语就是一个形容词性物主代词 This is my book 2.你的书比我的贵，这里的”我的”在中文的含义是”我的书”实际上是指”书”，它属于名词的意义。所以这里的我的翻译成英语就是一个名词性物主代词 Your books is more expensive than mine 形容词性物主代词的用法​ 做前置定语，所以它的后面会跟一个名词 English example： 注：下划线部分为定语 My house Your house Her house His house Its house Our house Their house Her boyfriend Your cars My water 注意事项：做前置定语时，中间不能加数词、冠词 English example: My two books My the book My a book 名词性物主代词的用法名词性物主代词相当于一个名词，所以可以作主语、表语、宾语。但是只能在前面提到或者避免重复的时候使用。 English example： Tom： My car is very good Tony: Mine is better Tom: My car is very good Tony: I want yours Tom : Whose is this house? Tony: It is hers My computer is better then yours 注意：名词性物主代词不能做定语 反身代词相互代词指示代词 单数 复数 This 这个（作主语be动词用is） These 这些（作主语be动词用are） That 那个（作主语be动词用is） Those 那些（作主语be动词用are） 上表中的这些单词就是指示代词的全部，它们可以作：主语、宾语、表语、定语。其中作主语和定语最常见。 作定语举例（example） This house. This computer. That boy. That company. These houses. Those houses. 作主语举例（example） This is my book. Those are her pencils. That is her sister. These are his books. 作宾语举例（example） I want this. I like that. I will buy These. 作表语举例（example） It is this. 不定代词疑问代词连接代词关系代词]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu系统]]></title>
    <url>%2FMeBlog%2F2020%2F04%2F21%2FUbuntu%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[自安装程序的图标显示进入 ～/.local/share/applications/目录，在此目录下创建一个程序名称.desktop的文件可以在应用显示程序中加入此程序 example： 123456789101112131415(base) spiderbao@spiderbao-CW65S:~$ cd ~/.local/share/applications/(base) spiderbao@spiderbao-CW65S:~/.local/share/applications$ lsAnaconda.desktop jetbrains-idea-1.desktop jetbrains-idea.desktop jetbrains-pycharm.desktop jetbrains-toolbox.desktop jetbrains-webstorm.desktop mimeapps.list mimeinfo.cache Typora.desktop(base) spiderbao@spiderbao-CW65S:~/.local/share/applications$ (base) spiderbao@spiderbao-CW65S:~/.local/share/applications$ cat Anaconda.desktop [Desktop Entry]Encoding=UTF-8Name=AnacondaComment=AnacondaExec=/home/spiderbao/anaconda3/bin/anaconda-navigatorIcon=anaconda_icon_128x128Terminal=falseType=ApplicationCategories=GNOME;GTK;Utility;TextEditor;Name[zh_CN]=anaconda icon的位置 在/usr/share/pixmaps下 example： 1234567(base) spiderbao@spiderbao-CW65S:/usr/share/pixmaps$ pwd/usr/share/pixmaps(base) spiderbao@spiderbao-CW65S:/usr/share/pixmaps$ ls -l ananaconda_icon_128x128.png anki.png anki.xpm (base) spiderbao@spiderbao-CW65S:/usr/share/pixmaps$ ls -l anaconda_icon_128x128.png -rw-rw-r-- 1 spiderbao spiderbao 4212 4月 21 09:30 anaconda_icon_128x128.png(base) spiderbao@spiderbao-CW65S:/usr/share/pixmaps$]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux-命令篇]]></title>
    <url>%2FMeBlog%2F2020%2F04%2F21%2FLinux-%E5%91%BD%E4%BB%A4%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Linux 常用命令命令提示符1[root@bogon ~]# 如上所示： [] ：是centos的提示分隔符，没有特殊的意义 root ：表示当前的登录用户 @ ：表示分隔符号，没有特殊的意义 bogon : 表示当前系统的简写 ～ ：表示当前用户所在的目录，～就是当前用户的家(home)目录 # : 命令提示符，可以标识当前登录用户的权限等级，普通用户使用$标识，超级管理员用#标识 命令格式 选项存在2种格式 1.长格式选项 如：--all 2.短格式选项 如：-a 目录处理命令 使用 -a 时会看到有的文件名前有.此时表示此文件为隐藏文件。 使用-l 查看详细信息 上面1表示此文件的链接计数 上面的root 表示文件的所有者，也就是文件的创建人或负责人，一个文件只能有一个所有者 上面表示文件的所属组，一个文件只能拥有一个所有组 在-l 后追加h -lh 表示人性化显示，使文件的大小更直观、 ls -i 可以获取文件的I节点或获取文件的id号 cd - 回到上次操作的目录 cd ~ 回到当前用户的根目录 cd 回到当前用户的根目录 tree 命令以目录树的方式显示文件结构信息 使用tree 时可能会遇到command not found ,这时就需要安装此命令 本人使用的是centos 7 的系统 发现使用yum 无法获取tree的安装包 所以只能使用源码包安装，于是在ftp://mama.indstate.edu/linux/tree/ 下载了 源码包 在/usr/local/src 下使用make 编译了源码包 文件处理命令 cat 适用于查看简短文件内容，如shell脚本 less 进入后使用 /关键字 可进行反白关键字高亮显示，同时按N键可以跳到下一个关键字，在高亮的关键字后加入！可以取消高亮效果 硬链接的生成命令 1ln /tmp/china/changzhi /root/china.hard 硬链接 共享文件的inode ,但是文件夹不能创建硬链接。 权限管理命令权限分为了三类 r w s 读 写 执行 其他权限管理命令 文件搜索命令find -name 加通配符可实现模糊搜索文件 通配符 * 表示多个字符 通配符 ？表示单个字符 其他搜索命令 此查询基于文件资料库所以，查询时对比find占用系统资源较少。 存在缺陷无法查询tmp目录下的文件 不能实时查询，如果刚创建的数据没有录入文件资料库时。会导致无法查询到文件。此时使用命令 1updatedb 然后再次使用 locate可查找到文件 帮助命令 帮助命令类型 1表示命令，5表示配置文件 命令名称：whatis NAME whatis - 在 whatis 数据库里查找完整的单词 总览 (SYNOPSIS) whatis keyword … 描述 (DESCRIPTION) whatis 命令在一些特定的包含系统命令的简短描述的数据库文件里查找关键字， 然后把 结果送到标准输出。 查找的内容必须完全匹配关键字的才会输出。 whatis 数据库文件是用 /usr/sbin/makewhatis 命令建立的。 参见 (SEE ALSO) apropos(1), man(1). [中文版维护人] 唐友 &#116;&#x6f;&#110;&#121;&#x5f;&#x74;&#121;&#64;&#x32;&#54;&#x33;&#46;&#x6e;&#x65;&#116; [中文版最新更新] 2001/9/8 [中国Linux论坛man手册页翻译计划] http://cmpp.linuxforum.net 命令名称：apropos NAME apropos - 在 whatis 数据库中查找字符串 总览 (SYNOPSIS) apropos keyword … 描述 (DESCRIPTION) apropos 命令在一些特定的包含系统命令的简短描述的数据库文件里查找关键字， 然后把 结果送到标准输出。 参见 (SEE ALSO) whatis(1), man(1). [中文版维护人] 唐友 &#116;&#111;&#110;&#x79;&#95;&#x74;&#121;&#64;&#50;&#x36;&#x33;&#x2e;&#x6e;&#x65;&#x74; [中文版最新更新] 2001/9/20 [中国Linux论坛man手册页翻译计划] http://cmpp.linuxforum.net 用户管理命令 压缩和解压命令压缩格式gz zip rar 其中 zip 是windos和Linux 都支持的压缩格式 压缩解压命令使用 gzip的缺陷就是目前只能压缩文件，并且压缩后是不保留源文件的。 tar 格式表示打包 unzip 解压文件时出现乱码如何解决，使用命令 unzip -O CP936 压缩包名称 即可。其中-O表示知道文件的编码集，CP936是IBM code page 中的第936页也就是咋们俗称的GBK。 rar 格式的文件解压或压缩12345#安装rar shell脚本 sudo apt install rarrar x 文件名进行解压更多信息使用 man rar 网络命令 mail 命令操作时需要使用CTRL+D 才可生效，如执邮件的删除功能，需要除了使用delete命令后还需使用 CTRL+D才可。 mail 进入使用界面后， h表示查看列表，d表示删除指定的邮件 挂载命令 开关机命令 修改系统默认运行级别代码 1init 2 查看系统存储信息1/proc/meminfo 工具版本切换java jdk版本切换1jdk 版本切换：sudo update-alternatives --config java 查看系统进程1ps aux |grep java nohup 和&amp;nohup简介：nohup 命令运行由 Command参数和任何相关的 Arg参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; （ 表示“and”的符号）到命令的尾部。 nohup 是 no hang up 的缩写，就是不挂断的意思。 nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。 在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中。 关键词：0 – stdin (standard input)，1 – stdout (standard output)，2 – stderr (standard error) ； 案例： 12nohup python MM3Spider.py &gt; python_info.log 2&gt;&amp;1 上面的案例表示以不挂断的形式执行MM3Spider.py文件 并将标准异常流（standard error）输入到标准输出流中，并且将标准输出流的信息输入 python_info.log文件中 &amp;简介：后台执行某段命令 nohup 和 &amp;的区别&amp;是指在后台运行，但当用户推出(挂起)的时候，命令自动也跟着退出，nohup ： 不挂断的运行，注意并没有后台运行的功能，，就是指，用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响他的运行，注意了nohup没有后台运行的意思；&amp;才是后台运行 通常我们组合使用如下 12nohup python MM3Spider.py &gt; python_info.log 2&gt;&amp;1 &amp; uname简介： print system information -a, –all print all information, in the following order, except omit -p and -i if unknown: 1uname -a]]></content>
  </entry>
  <entry>
    <title><![CDATA[bash-初识]]></title>
    <url>%2FMeBlog%2F2020%2F04%2F21%2Fbash-%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[什么是bash简单的说，bash是一个命令解释工具 命令的语法以及规范变量变量和java中的变量所表示的含义大致相同，都是用一个引用表示地址值中的数据。 待验证：bash的变量只能存储文本。 变量的赋值方式和Java中变量赋值类似。下面列举几个例子，看后自会明白。 $var=word 注意等号的左右不能留有空格 $var=’hello word’ $var=”hello word”上面两种都可以表示文本中包含空格的输入。不同之处在于，双引号中可以掺入变量，系统会放入变量引用的值。而单引号却只能打印所有输入的文本内容，变量引用也会当做文本。 $v1=word$var=”hello ${v1}test” ${}中放入的变量可以中缺的被标识并识别，如果不使用${} 表达式的含义将会变为引用v1!的变量此时不会输出 hello Wordtest 而是 hello $now=date 注意中可以使用命令。查看now echo $now 这时会输出时间 $date=$now 变量之间也可以互相传值 $read name 这时Linux会等待用户输入，输入完成后会把输入的值赋值给name 数学运算bash中的数学计算类似上学时的数学运算，只要吧运算表达式写入$(())中即可 加法运算 $((3+2)) 减法运算 $((3-2)) 乘法运算 $((3*2)) 除法运算 $((3/2)) 求余运算 $((2%3)) 乘方运算 $((2**3)) 返回代码Linux命令执行完后会放回一个值，返回0表示这段命令执行成功$? 可以查看当前命令执行的结果 ；的使用命令中使用；可以在一行命令中执行多个命令。如ls;$? 表示打印目录信息并回响命令返回值 短路与或短路与，在多个命令中，后面命令的执行与否取决于之前命令的返回值，当返回值为0时之后的命令才会执行 如： rm dome.file &amp;&amp; echo “remove dome.file sucess” 当删除过文件dome.file后会输出文本信息，失败后则不输出。 短路或，短路或正好是短路与的反向解释。当之前的命令失败后后面的命令才会执行，否则不执行 如：rm dome.file &amp;&amp; echo “remove dome.file fail” 当没有删除文件dome.file后会输出文本信息，否则不会输出任何信息。 bash scriptfirst bash file12345678#!/bin/bashuser=`whoami`echo &quot;Information of $&#123;user&#125; computer&quot; &gt;&gt; loglscpu &gt;&gt; loguname -a &gt;&gt; logfree -h &gt;&gt; log 这是一个简单的bash脚本，刚刚解释了什么是bash他是一个命令解释器，所以bash脚步就是集多条bash命令的一个文本。这样做的好处是我们可以记录使用命令的逻辑，并多次复用。 bash中传入参数bash 中的参数使用 $0 $1 …表示 使用例子： 测试流程 1编辑bashscript 2运行 3显示结果 1 编辑script12345#!/bin/bashecho $0echo $1echo $2 2 运行1spiderbao@spiderbao-CW65S:~/my-bash$ ./test_arg.bash hello word 3.显示结果123./test_arg.bashhelloword 函数个人认为函数是对bash脚本的一次封装，通过内部定义函数可以将命令功能分块包装。从而达到脚本内函数的复用 无参函数示例测试流程 1编写脚本 2运行 3展示结果 1 编写脚本12345678910#!/bin/bashfunction meInfo()&#123; date &gt;&gt; log lscpu &gt;&gt; log uname -a &gt;&gt; log free -h &gt;&gt; log&#125;meInfo 2 运行 1spiderbao@spiderbao-CW65S:~/my-bash$ ./test_function.bash 3 显示结果12345678spiderbao@spiderbao-CW65S:~/my-bash$ cat log 2019年 08月 26日 星期一 13:52:10 CSTxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 带参函数示例测试流程 1编写脚本 2运行 3展示结果 1.编写脚本12345678910#!/bin/bashfunction meInfo()&#123; date &gt;&gt; $1 echo &apos;hello&apos; &gt;&gt; $1 echo &apos;word&apos; &gt;&gt; $1&#125;meInfo melogmeInfo melog2 2 运行 1spiderbao@spiderbao-CW65S:~/my-bash$ ./test_function.bash 3 显示结果12345678spiderbao@spiderbao-CW65S:~/my-bash$ cat melog2019年 08月 26日 星期一 14:14:37 CSThellowordspiderbao@spiderbao-CW65S:~/my-bash$ cat melog22019年 08月 26日 星期一 14:14:37 CSThelloword 跨脚本函数调用首先跨脚本函数调用是基于脚本之上的操作，从此也可以看出函数封装的好处。 跨脚本函数调用主要使用source关键字 测试流程 1编写脚本 2 运行 3 展示结果 1 编写脚本 test_function.bash12345678910#!/bin/bashfunction meInfo()&#123; date &gt;&gt; $1 echo &apos;hello&apos; &gt;&gt; $1 echo &apos;word&apos; &gt;&gt; $1&#125;meInfo melogmeInfo melog2 app.bash123456#!/bin/bashsource test_function.bashmeInfo melog3meInfo log 2 运行 1spiderbao@spiderbao-CW65S:~/my-bash$ ./app.bash 3 展示结果 12345678910spiderbao@spiderbao-CW65S:~/my-bash$ cat melog melog2 melog32019年 08月 26日 星期一 14:30:22 CSThelloword2019年 08月 26日 星期一 14:30:22 CSThelloword2019年 08月 26日 星期一 14:30:22 CSThelloword 可以看到source 引入的test_function.bash 脚本被执行了一遍，注意是整个脚本不单是脚本中的一个函数而是整个脚本。 逻辑判断逻辑判断为的是判断一个函数式运行的真假或一个命令的真假 案例12spiderbao@spiderbao-CW65S:~/my-bash$ test 3 -gt 2 ;echo $?0 因为3大于2（-gt表示大于）所以命令的返回值为0 关于数值的判断符大于 -gt小于 -lt等于 -eq不等于 -ne大于等于 -ge小于等于 -le 关于文本的判断符文本相同 =文本不相同 !=文本按字典排序一个文本在另一个文本之前 &gt;文本按字典排序一个文本在另一个文本之后 &lt; 关于文件判断符检查文件是否存在 -e检查文件是否存在并且是普通文件 -f检查目录是否存在 -d检查软连接是否存在 -l检查文件是否可读 -r检查文件是否可写 -w检查文件是否可以执行 -x 与或非&amp;&amp; || ! 注意 &amp;&amp; || ! 不能联合使用 选择结构ifif 选择结构，类似java中的流程控制语句if 案例1234567#!/bin/bashuser=`whoami`if [ $user = &apos;root&apos; ]then echo &quot;你是超级用户！&quot;fi 需要注意语法格式 if elseif else ,类似java中的流程控制语句 if else 案例 123456789#!/bin/bashuser=`whoami`if [ $user = &apos;root&apos; ]then echo &quot;你是超级用户！&quot;else echo &quot;你不是超级用户！&quot;fi 需要注意语法格式 if else 嵌套使用，类似java流程控制语句中的if else if else 案例 1234567891011121314151617#!/bin/bashuser=`whoami`if [ $user = &apos;root&apos; ]then echo &quot;你是超级用户！&quot;else if [ $user = &apos;laowang&apos; ]then echo &quot;你是老王用户！&quot;else if [ $user = &apos;spiderbao&apos; ]then echo &apos;你是spidermen的朋友spiderbao!&apos;else echo &apos;我也不知道你是谁！&apos;fififi 格式样式模仿Java的if else if else ，唯一不同处在于结尾fi使用了多少个if就需要添加多少个fi来结尾。毕竟这是一个嵌套语句。 casecase 类似java流程控制语句中的switch 案例123456789101112131415161718#!/bin/bashuser=`whoami`case $user in root) echo &quot;你是超级管理员用户！&quot; ;; laowang) echo &quot;你是老王用户！&quot; ;; spiderbao) echo &apos;你是spiderbao用户！&apos; ;; *) echo &apos;我也不知道你是谁！&apos; ;;esac 需要注意的是 ）中可以填写文本以及通配符通配符 表示任意个数的任意字符? 表示一个字符的任意字符[] 类似正则表达式中的[]，表示可选范围内的字符，另外[]只占一个字符位 。例如[1-5][a-x] 1a,2b 均匹配]]></content>
  </entry>
  <entry>
    <title><![CDATA[python-入门篇]]></title>
    <url>%2FMeBlog%2F2020%2F04%2F17%2Fpython-%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[python的来源​ python是著名的“Guido van Rossum”在1989年圣诞节期间开发的编程语言 现在，全世界差不多有600多种编程语言，但流行的编程语言也就那么20来种。如果你听说过TIOBE排行榜，你就能知道编程语言的大致流行程度。tiobe的官方数据链接如下： https://www.tiobe.com/tiobe-index/ 总的来说，这几种编程语言各有千秋。C语言是可以用来编写操作系统的贴近硬件的语言，所以，C语言适合开发那些追求运行速度、充分发挥硬件性能的程序。而Python是用来编写应用程序的高级编程语言。 当你用一种语言开始作真正的软件开发时，你除了编写代码外，还需要很多基本的已经写好的现成的东西，来帮助你加快开发进度。比如说，要编写一个电子邮件客户端，如果先从最底层开始编写网络协议相关的代码，那估计一年半载也开发不出来。高级编程语言通常都会提供一个比较完善的基础代码库，让你能直接调用，比如，针对电子邮件协议的SMTP库，针对桌面环境的GUI库，在这些已有的代码库的基础上开发，一个电子邮件客户端几天就能开发出来。 Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（batteries included）”。用Python开发，许多功能不必从零编写，直接使用现成的即可。 除了内置的库外，Python还有大量的第三方库，也就是别人开发的，供你直接使用的东西。当然，如果你开发的代码通过很好的封装，也可以作为第三方库给别人使用。 许多大型网站就是用Python开发的，例如YouTube、Instagram，还有国内的豆瓣。很多大公司，包括Google、Yahoo等，甚至NASA（美国航空航天局）都大量地使用Python。 python 的优点 life is short,you need Python –Bruce Eckel 龟叔给Python的定位是“优雅”、“明确”、“简单”，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。 总的来说，Python的哲学就是简单优雅，尽量写容易看明白的代码，尽量写少的代码。如果一个资深程序员向你炫耀他写的晦涩难懂、动不动就几万行的代码，你可以尽情地嘲笑他。 那Python适合开发哪些类型的应用呢？ 首选是网络应用，包括网站、后台服务等等； 其次是许多日常需要的小工具，包括系统管理员需要的脚本任务等等； 另外就是把其他语言开发的程序再包装起来，方便使用。 Python的缺点 任何编程语言都有缺点，Python也不例外。优点说过了，那Python有哪些缺点呢？ 第一个缺点就是运行速度慢，和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。 但是大量的应用程序不需要这么快的运行速度，因为用户根本感觉不出来。例如开发一个下载MP3的网络应用程序，C程序的运行时间需要0.001秒，而Python程序的运行时间需要0.1秒，慢了100倍，但由于网络更慢，需要等待1秒，你想，用户能感觉到1.001秒和1.1秒的区别吗？这就好比F1赛车和普通的出租车在北京三环路上行驶的道理一样，虽然F1赛车理论时速高达400公里，但由于三环路堵车的时速只有20公里，因此，作为乘客，你感觉的时速永远是20公里。 python交互模式 使用当前系统的命令模式，输入python3即可进入交互模式，输入exit()可退出python交互式模式。 交互式模式可以直接显示代码运行的结果。但是之前输入的代码退出交互式模式后不能存到硬盘中 命令行执行.py文件 命令行模式下，进入要执行的.py文件同目录下，输入python3 文件名即可运行 变量的命名规则（标识符） 变量名只能包含字母，数字和下划线，且不能以数字打头； 变量名不能包含空格； 不能将Python 关键字和函数名作为变量名使用； 慎用小写字母i和大写字母O，容易看成数字1和数字0； Python 的命名是大小写敏感的，也就是说a和A对于解释器而言，是两个不同的名字； 占位符（place holder） %d %.2f %.1f %s %d 表示十进制整数占位符 %.2f 表示浮点数保留到2位小数点后 %.1f 表示浮点数保留到1位小数点后 %s 表示字符串 进制 二进制 （binary）123a = 0b111 #7#二进制的形式表示7a = bin(7) 十进制 （decimal） 十六进制 （hexadecimal）123a = 0xff #255#十六进制的形式表示255hex(255) 占位符表示进制1print("%x" %(255)) #使用16进制的形式表示255 注释多行注释 “””单行注释 # 列表 list list 列表类似Java中的列表list都是类构成 下标的使用如: list[1]、list[-1] 列表的追加如：list.append() 列表的删除如： del list[x] 直接删除指定索引处的元素 list.pop(x) 弹出指定索引处的元素并返回 list.remove(x) 删除首个指定元素 列表的排序： list.sort() 列表拷贝 list.copy() 此拷贝不是深层拷贝，如果想要深层拷贝使用copy.deepcopy 数值列表123print("output of range(10):")for i in range(5): print(i) 列表的快速生成123matrix = [[0]*8]*10cubes = [x**3 + 100 for x in range(1,11)]variables = [x+y for x in 'abc' for y in '0123'] 切片(slice)123numbers = [x for x in range(10)]print("numbers[3:9]:",numbers[3:9]) 切片会生成一个新的list返回，并不是直接操作原有的list 切片可以对str类型的数据使用 妙用切片1234567numbers = [x for x in range(10)]numbersCopy = numbers[:]numbersReversed = numbers[::-1]print("numbers[:3:-2] is:",numbers[:3:2])print("numbers[:3:-2] is:",numbers[:3:-2]) 将切片的参数划分为[x:y:z] 当z为正数时 x默认为0,y默认为最后一个元素不包含、 当z为负数时 x默认为最后一个值，y默认为第一个值并且包含 数据类型元组（tuple）元组是只读的列表当只有一个数时需要加，如下1print((1,)) byte字节字节的作用：用来存储数据方便数据的交流，如字节流 字节的存储Python： little 高位字节存高地址big 高位字节存低地址 Intel ARM little endian Motorola big endian 将数据以二进制字节的方式存储example： 123456789101112131415161718192021222324import structimport matplotlib.pyplot as plt# writelData = [11,18.234,10.342,3.2342,13]with open('secondData.dat','wb') as d: for i in lData: d.write(struct.pack("&lt;f",i))# readdata = Nonewith open('secondData.dat','rb') as d: data = d.read()iSampleCount = len(data)//4 #解包的时候是按照4个字节的大小来进行的，所以要求4的倍数，因为Python使用/的结果是flot所以使用//。另外数据的总长度len(data)肯定是能被4整除。print(len(data))lCurveData = []for i in range(iSampleCount): fValue, = struct.unpack('&lt;f',data[i*4:i*4+4]) lCurveData.append(fValue)print(lCurveData)plt.plot(lCurveData)plt.show() bytearray1234buffer = bytearray(b'asdajhskfahs')buffer[1] = ord('B')print(buffer) 可以修改的byte 数组 序列 （sequence）拥有的共同点：都可以使用索引、切片，并且拥有顺序 如 list tuple str byte bytearray 只读类型int float str bytes boolean tuple 可修改类型list bytearray dict 名字绑定 (name binding)概念名词： 名字（name） 对象(object) 绑定(binding) 例子：q=2 解释就是 将 name q 绑定到 object 2 上 == is12345678a = 3b = 3.0print("a==b:",a==b)print("a is b:",a is b)print("a:",id(a),"b:",id(b)) 序列解包(sequence unpack) x,y,z = ‘x’,’y’,’z’ print(x,y,z) x,y = y,x print(x,y) numbers = 1,2,3 print(type(numbers),numbers) a,b,c = numbers print(a,b,c) d,e,f = 4,5,6 print(d,e,f) g,h,i = ‘789’ print(g,h,i) j,k,l = b’\x10\x20\x30’ print(j,k,l) 序列解包，首先解包的对象必须是序列,其次解包时两边数据必须保持一致,不然会报错如下 j,k= b’\x10\x20\x30’ number1,number2 = 1,2,3 print(j,k) 解包元素赋值序列 lstr = “Lenoardo di ser Piero Da Vinci”.split() first,*middle,last = lstr print(‘first:’,first,”- middle:”,middle,”- last:”,last) print(‘first id is:’,id(first),”lstr[1] id is:”,id(lstr[1])) 链式赋值x = y = 2 布尔型非空即真,非零即真 for 可迭代对象 iterable object1234s = ""for x in "asdafasg": s += x +"-"print(s) for else 当for 条件不成立时会触发else 的代码块并执行123456789101112131415for x in names: if x.endswith("Bach"): print(" I found a Bach:",x) breakelse: print("No Bach been found.")matrix = [[x+1+y for x in range(5)] for y in range(6)]for r in range(6): for c in range(5): matrix[r][c] *= 2for r in matrix: print(r) while loop12345678sum = i = 0while i&lt;=100: sum += i i += 1print("sum of (1,2...,100) = ",sum)names = ["Peter Anderson","Frank Bush","Tom Henry","Jack Lee","Dorothy Henry"] 带下标的遍历 enumerate12345names = ['Tom','Andy','Alex','Dorothy']print(list(enumerate(names)))for idx,name in enumerate(names): print(name +" is %s,id is %s" % (name,idx)) 反向遍历12345for x in reversed(names): print(x)print(names)# reversed会生成一个新的序列并将原有的值反向存储# list本身的reverse会将当前序列的值反向存储 del123456x = "Anything"y = xdel yprint(x) exec 执行代码无返回1234567exec("print('This string was print in exec function')")scopeTemp = &#123;&#125;scopeTemp['x'] = 30scopeTemp['y'] = 20exec("sum = x+y",scopeTemp)print("sum = ",scopeTemp["sum"]) eval evaluation 评估 执行代码有返回12r = eval("3+2-5")print(r) 字符串格式化123456789101112131415161718192021222324252627282930313233343536373839import ossText = "Mary have &#123;&#125; lambs,they are &#123;n1&#125;,&#123;n2&#125; and &#123;&#125;.".format(3,'cot',n2='happy',n1='nauty')print(sText)dora = &#123;"name":"Dora","id":17,"age":32,"gender":"mate","title":"hello"&#125;sDoraHtml = """ &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Employee &#123;name&#125;'s information&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; Employee &#123;name&#125;'s Information&lt;/h1&gt; &lt;table border="1" width="100%"&gt; &lt;tr&gt; &lt;td&gt;ID:&lt;/td&gt; &lt;td&gt;&#123;id&#125;&lt;/td&gt; &lt;td&gt;Name:&lt;/td&gt; &lt;td&gt;&#123;name&#125;&lt;/td&gt; &lt;td&gt;Age:&lt;/td&gt; &lt;td&gt;&#123;age&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Gender:&lt;/td&gt; &lt;td&gt;&#123;gender&#125;&lt;/td&gt; &lt;td&gt;Title:&lt;/td&gt; &lt;td&gt;&#123;title&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; """t = open("dora.html",'w')t.write(sDoraHtml.format_map(dora))t.close()os.system("google-chrome dora.html") dict key 必须是可哈希类型 hashable Type 可哈希类型 int float str tuple 不可哈希类型 dict list12345678910111213141516171819202122232425262728293031323334doroth = dict(name="Dorothy",id = "10003",age = 26)print(doroth)d = dict.fromkeys(['id','name','age'],"unknown")d1 = &#123;&#125;.fromkeys(['id','name','age'],"unknown")print(d)print(d1)dora = &#123;"name":"Dora","id":17,"age":32,"gender":"mate","title":"hello"&#125;# print(dora['salary'])print(dora.get("salary",1000))sTitle = dora.pop('title')print(sTitle)print(dora)dora = &#123;'id':10003,'age':32,'title':'Salas'&#125;dora2 = &#123;'id':10004,'title':'CEO','gender':'female'&#125;dora.update(dora2)print(dora)for i in dora: print(i,end=",")for i in dora.keys(): print(i,end=",")for key,value in dora.items(): print(key,"-",value) 函数与抽象Python实现使用函数的案例1234567891011def costCompute(iStart,iEnd): """ 计算客户电费，每度电10元 :param iStart: 起始度数 :param iEnd: 最终度数 :return: 电费 """ iCousume = iEnd - iStart return iCousume * 10print(costCompute(100,230)) 默认参数（default parameter）1234567def greeting(n,gender="male"): n = n.title() s = "Mr " if gender == 'male' else "Miss" print("Hi,",s,n)sName = "alan turning"greeting(sName) 非只读类型的参数12345678910def initPerson(person,id,name,age,gender,title): assert type(person) == dict person['id'] = id person['name'] = name person['age'] = age person['gender'] = gender person['title'] = titledora = &#123;&#125;initPerson(dora,'10003','dora chen',32,'female','sales') 关键字参数调用12345678910def initPerson(person,id,name,age,gender,title): assert type(person) == dict person['id'] = id person['name'] = name person['age'] = age person['gender'] = gender person['title'] = titleinitPerson(person=dora,id='10003',name='dora chen',age=32,gender='female',title='sales')print(dora) 任意数量参数12345678910111213141516171819202122232425262728293031def myPrint(title,*contents): print(title,":") for i in contents: print("\t",i)myPrint("Read-only data type:","int","float",'tuple','str','bytes')def myprint(title,**contents): print(title,":") for k,v in contents.items(): print("\t",k+":",v)myprint("dora",name="Dora chen",age=32)def initPerson(person,id,name,age,gender,title): assert type(person) == dict person['id'] = id person['name'] = name person['age'] = age person['gender'] = gender person['title'] = titledora = &#123;&#125;tDora = ('10003','dora chen',32,'female','sales')initPerson(dora,*tDora)print(dora)dDora = &#123;'id':"10003",'name':'dora chen','age':32,'gender':'female','title':'sales'&#125;initPerson(dora,**dDora)print(dora) python 全局作用域实现方式1234567import pprintx =1y =2scope = vars()pprint.pprint(scope)scope['x'] = 3print(x) 递归 阶乘（factorial）总结不要在大规模的计算中使用递归1234567def factorial(n): if n==1: return 1 else: return n*(factorial(n-1))print("6!=",factorial(6)) 面向对象 程序设计语言 1990年前 结构化编程 structured programming 1990年后 面向对象程序语言 object oriented programming 面向对象关键术语： 类型 type or class 对象 object or instance 属性 attribute or data member 方法 method or function example：1234567891011from enum import Enumclass Person: passclass Gender(Enum): mate = 1 female = 0print(range.__doc__) 文件的读写example： 123456789101112131415# writef = open('datafile.txt','w')f.write("This is a file which is writable in text mode.\n")f.close()# readf = open('datafile.txt','r')sLine1 = f.readline()print(sLine1)f.close()# 安全使用流的简洁方式with open('datafile.txt','r') as f: sLine1 = f.readline() print(sLine1) 标准输入 标准输出 错误流example: 12345678910111213141516import sysiInput = open('standardInput.txt','w')iInput.write('Alas\n')iInput.write('27\n')iInput.close()sys.stdout = open('standardOut.txt','w')sys.stdin = open('standardInput.txt','r')sys.stderr = open('standardError.txt','w')name = input('Water are you Name?')age = input('How old are you')print('This is %s she %s old' %(name,age))raise Exception("Exception infomatoin") 管道重定向1cat title.txt | python wordCount.py 结构化文本文件 ini jsonexample: 12345678910import jsondora = "&#123;'name':'Dora','no':'2018173','age':26,'married':false,'scores':[&#123;'c++':76&#125;,&#123;'Data structure':99.5&#125;]&#125;"# writeiDora = open('dora.json','w')json.dump(dora,iDora)# readdora = json.load(open('dora.json','r'))print(dora) 异常、警告异常勾子 ：当系统发生异常时会执行一个指定的函数12345678910111213141516171819202122232425import sys,tracebackfrom datetime import datetimedef userExceptHook(exceptType,value,traceBack): fError = open('except_error.log', 'w') traceList = traceback.format_tb(traceBack) html = str(datetime.now())+'\n' html += repr(exceptType)+'\n' html += repr(value) + '\n' for i in traceList: html += i+"\n" print(html,file=sys.stderr) print(html,file=fError) fError.close()sys.excepthook = userExceptHooksFirst = input("first number")sSecond = input("second number")try: print(int(sFirst)/int(sSecond))except Exception as e: raise 类的序列化 迭代器和生成器函数类的序列化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Fibonacci: def __init__(self): self.seq = [0,1,1] self.maxKey = 1000 def computeTo(self,key): for i in range(len(self.seq),key +1): v = self.seq[i-1]+self.seq[i-2] self.seq.append(v) def __getitem__(self, item): if not isinstance(item, int): raise TypeError('type of item need int') if not(item&gt;=0 and item&lt;self.maxKey): raise IndexError("sequence max length is 1000,you's item &gt; max length") if item&gt;len(self.seq): self.computeTo(item) return self.seq[item] def __setitem__(self, key, value): if not isinstance(key, int): raise TypeError('type of key need int') if not(key&gt;=0 and key&lt;self.maxKey): raise IndexError("sequence max length is 1000,you's key &gt; max length") if key &gt; len(self.seq): self.computeTo(key) self.seq[key] = value def __len__(self): return self.maxKeyf = Fibonacci()print("f[20]:",f[20])f[10] = "熊孩子"for i in range(1,21): print(f[i],end=",")print("----------------------------------------------------------------------------------")class Fibonacci(list): def __init__(self,*arg): super().__init__(*arg) self.iCounter = 0 def __getitem__(self, item): self.iCounter += 1 return super().__getitem__(item)f = Fibonacci(range(100))print('f[20]',f[20])f[19] = "熊孩子"print('f[19]',f[19])print(f) 创建可迭代类 迭代器和序列的对比 迭代器,由于是当系统调用next方法时才会生成相应的数据所以在系统资源占用损耗节省方面优于序列,但是不能像序列那样可以随意指定下标取值,并且只能迭代一次.推荐需要依次获取一次数据时使用 序列,由于系统执行后会在系统内部一次性创建完成序列所以系统资源占用损耗节省方面劣于迭代器,但是它可以获取指定下标的值.推荐在重复或指定获取数据的情况下使用 1234567891011121314151617181920212223242526272829class Fibonacci: def __init__(self,arg): self.a = 1 self.b = 1 self.index = 0 self.length = arg def __iter__(self): return self def __next__(self): result = None if not isinstance(self.index,int): raise TypeError elif self.index &gt;= self.length or self.index&lt;0: raise StopIteration if self.index in(0,1): result = 1 else: result = self.a + self.b self.a,self.b = self.b,result self.index += 1 return resultf = Fibonacci(10)print(list(f))for i in f: print(i,end=",") 生成器函数12345678910111213141516171819202122def fibonacciGenerator(len): if not isinstance(len,int): raise TypeError a,b =1,1 for i in range(1,len+1): if i in (1,2): yield 1 else: c = a + b a,b = b,c yield cf = fibonacciGenerator(10)print(list(f))for i in f: print(i,end=",")f = [i**2 for i in range(10)] #列表推导f2 = (i**2 for i in range(10)) print(type(f),f)print(type(f2),list(f))]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux-文件配置篇]]></title>
    <url>%2FMeBlog%2F2020%2F04%2F03%2Flinux-%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E7%AF%87%2F</url>
    <content type="text"><![CDATA[系统环境/etc/profile 文件/etc/profile 文件属于一个系统的全局变量123456789101112131415161718192021222324if [ "$&#123;PS1-&#125;" ]; then if [ "$&#123;BASH-&#125;" ] &amp;&amp; [ "$BASH" != "/bin/sh" ]; then # The file bash.bashrc already sets the default PS1. # PS1='\h:\w\$ ' if [ -f /etc/bash.bashrc ]; then . /etc/bash.bashrc fi else if [ "`id -u`" -eq 0 ]; then PS1='# ' else PS1='$ ' fi fifiif [ -d /etc/profile.d ]; then for i in /etc/profile.d/*.sh; do if [ -r $i ]; then . $i fi done unset ifi Linux是一个多用户操作系统。用户登录或切换（即Login shell 启动）时都有一个专用的运行环境，但首先执行 /etc/profile 。而Non-login shell不会调用这个脚本。各用户的默认环境（一组环境变量的定义）一般相同。用户也可以自行配置运行环境，即修改相应的系统环境变量。 在 /etc/profile 文件中设置的变量是全局变量。而 .bashrc文件（在用户的家目录下）则只对当前用户有用 使用 source 命令更新环境变量。source /etc/profile 或者 ./profile，执行一下文件。但不能用 sh /etc/profile。sh 是在子 shell 进程中执行的，即使PATH改变了也不会反应到当前环境中。而 source 是在当前 shell 进程中执行的，所以我们能看到PATH的改变 4.在profile文件添加或修改的内容需要注销系统才能生效。同名的环境变量，后写入的起作用]]></content>
  </entry>
  <entry>
    <title><![CDATA[PC计算机常识]]></title>
    <url>%2FMeBlog%2F2020%2F03%2F18%2Fpc%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E7%9A%84%E5%B8%B8%E8%AF%86%2F</url>
    <content type="text"><![CDATA[计算机是如何记录时间的名词：RTC RTC （real time clock）实时时钟 计算机断电期间，RTC芯片由锂电池供电； RTC在内部或外部晶体振荡器驱动下以固定节拍增加内部计数器的值； 计算机开机后，CPU通过scl/sda串行线读取RTC的计数值； RTC计数值表从格林尼治时间1970年1月1日零时起；]]></content>
  </entry>
  <entry>
    <title><![CDATA[spring4 读后笔记]]></title>
    <url>%2FMeBlog%2F2020%2F02%2F03%2Fspring4%2F</url>
    <content type="text"><![CDATA[spring作者spring 的作者叫做 Rob johnson 最初创建的目标spring 创建的初期主要是为了解决企业级应用开发的复杂性 spring 的根本使命简化JAVA开发 支撑spring 使命实现的4个关键策略基于pojo的轻量级和最小侵入性编程通过依赖注入和面相接口实现松耦合基于切面和惯例进行声明式编程通过切面和模板减少样板式代码 pojo示例代码12345public class HelloWordBean&#123; public String sayHello()&#123; return "hello word!"; &#125;&#125; 构造器模式将一个事物运行的流程确定，用一个类表示，如上面的braveKnight类将事物中多变的部分抽取出来，如执行的任务quest 这样做的好处代码将松耦合这样一来我们不用发愁骑士每次执行一个新的任务就需要重新创建一个骑士，而只需要新建一个需要执行的任务类并且实现quest接口即可 DI(dependency injection)自动装配github 上查看 https://github.com/slothjun/Spring4BookProject/tree/master/src/main/java/dome4 Java注解声明式装配github 上查看 https://github.com/slothjun/Spring4BookProject/tree/master/src/main/java/dome5 xml装配beanC命名空间中的标签无法装配集合。 代码：github 上查看 https://github.com/slothjun/Spring4BookProject/tree/master/src/main/java/dome6 导入和混合装配代码：github 上查看 https://github.com/slothjun/Spring4BookProject/tree/master/src/main/java/dome7 注解混合xml或注解@import 将别的配置引入当前配置中@importResource 将xml配置引入当前配置中 xml混合注解或xml 标签可将别的xml配置导入当前配置中 标签可以将JavaConfig配置以bean的方式导入 profile条件化装配配置使用profile 可以实现程序在不同配置下切换并运行 基于注解下的使用1234567891011121314@Configuration@Profile("MagicExists")public class MagicExistsConfig &#123;&#125;``` ##### 基于xml下的使用```xml&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:c="http://www.springframework.org/schema/c" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" profile="MagicExists"&gt; 激活并使用条件配置下的配置1234567891011121314151617@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = MagicExistsConfig.class)public class Dome8Test &#123; @ActiveProfiles("MagicExists") public static class MagicExistsTest&#123; @Autowired private MagicBean magicBean; @Test public void test1()&#123; Assert.assertNotNull(magicBean); &#125; &#125;&#125; 关于条件化配置装配dome可到如下网址查看 https://github.com/slothjun/Spring4BookProject/tree/master/src/main/java/dome8 条件化bean基于注解实现（@conditional）1.在bean声明上加入@condition注解12345@Bean@Conditional(MagicExistsCondition.class)public MagicBean magicBean()&#123; return new MagicBean();&#125; 2.编写MagicExistsCondition条件判定类1234567891011121314/** * @className MagicExistsCondition * @Descirption 判断Magic存在 * @Author WengLiangBao * @Date 2020/1/8 上午10:22 * @Vsersion 1.0 */public class MagicExistsCondition implements Condition &#123; public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123; Environment env = conditionContext.getEnvironment(); return env.containsProperty("magic"); &#125;&#125; 3.测试@conditional注解会根据条件判定类中的matches方法返回的结果来装配当前被声明的bean代码 https://github.com/slothjun/Spring4BookProject/tree/master/src/main/java/dome8 处理自动装配歧义Primary指定每次都首选的bean（个人不太推荐，因为它不够灵活）1234@Component@Primary //指定首选bean解决方案public class Cake implements Dessert &#123;&#125; Qualifier使用限定符指定要装配的bean 根据bean的ID装配123@Autowired@Qualifier("cake")//限定符解决方案private Dessert dessert; 根据自定义限定符注解装配1.创建自定义限定符注解123456789101112/** * @className Cold * @Descirption * @Author WengLiangBao * @Date 2020/1/14 下午1:07 * @Vsersion 1.0 */@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface Cold &#123;&#125; 2.在bean的声明处使用注解1234@Component@Coldpublic class IceCream implements Dessert &#123;&#125; 3.自动注入处使用注解123@Autowired@Cold //自定义限定符注解private Dessert dessert; 代码：github 上查看 https://github.com/slothjun/Spring4BookProject/tree/master/src/main/java/dome9 spring 是通过什么装载这些配置后的类的spring通过应用上下文来实现应用装载配置spring提供了多种上下文的实现，也就是说spring可以通过多种不同的方式来实现应用类的装载和配置 关于dependency injection 的更过信息可以查看《dependency injection》总结 关于依赖注入和面相接口编程，本事阐述的核心思想是基于 装饰器模式+spring的多样化配置方式+spring 装载配置的核心接口（application context） AOP面向切面spring实现AOP的的方式1.spring 本身提供的aop方案是基于代理实现，这种方案只能做到方法级别的把控无法对类的创建构造函数等操作2.可以引入aspectJ方案替代，但是学习成本比较高。此方案可以做到细粒度的把控 注解实现主要操控的内容有1.5种通知（前置通知，后置通知，返回通知，异常通知，环绕通知）其中环绕通知可以通过ProceedingJoinPoint 参数类实现前后返异四中通知。2.带参通知3.为接口添加新的接口代码案例 ：https://github.com/slothjun/Spring4BookProject/tree/master/src/main/java/dome12https://github.com/slothjun/Spring4BookProject/tree/master/src/main/java/dome13https://github.com/slothjun/Spring4BookProject/tree/master/src/main/java/dome14 xml实现基于XML配置 sping 容器（基于IOC思想）spring 容器负责创建，装配，配置bean。并管理bean的整个生命周期 spring 自带的容器实现总体可归纳为2种类型 bean工厂（由org.springframework.beans.factory.BeanFactory定义）提供基本的DI支持 应用上下文（由org.springframework.context.ApplicationContext定义）基于BeanFactory构建，提供应用框架级别的服务AnnotationConfigApplicationContext 从一个或多个基于java配置类中加载spring应用上下文AnnotationConfigWebApplicationContext 从一个或多个基于java的配置类中加载SpringWeb应用上下文ClassPathXmlApplicationContext 从类路径下的一个或多个xml配置文件中加载spring应用上下文FileSystemXmlapplicationContext 从文件系统中的一个或多个xml配置文件中加载spring应用上下文XmlWebApplicationContext 从Web应用下的一个或多个xml配置文件中加载应用上下文 bean的生命周期 bean 的作用域spring默认bean的作用域是单例的。 scope的4大作用域Singleton 单例：在整个应用中只创建一次beanPrototype 原型：每次注入或根据spring上下文获取时，都会创建新的bean实例Session 会话：在web应用中为每次会话创建一个bean的实例Request 请求：在web应用中为每次请求创建一个bean的实例 使用Scope注解指定作用域 传统项目1234@Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public class PrototypeCart implements ShoppingCart &#123;&#125; 1&lt;bean id="prototypeCart" class="dome10.PrototypeCart" scope="Prototype"/&gt; web项目在为web项目指定bean的作用域时需要注意bean构建时依赖传递的问题问题举例： 如有一个购物车bean需的作用域需要被指定为Session级别。当spring的上下文创建时发现购物车bean是的作用域是购物车级别的所以不能被创建。 如何解决此问题，答案是通过代理的手段解决 对于bean是以接口的方式注入 (基于java代理)1234@Component@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE,proxyMode = ScopedProxyMode.INTERFACES)public class PrototypeCart implements ShoppingCart &#123;&#125; 123&lt;bean id="prototypeCart" class="dome10.PrototypeCart" scope="Session"&gt; &lt;aop:scoped-proxy proxy-target-class="false"/&gt;&lt;/bean&gt; 对于bean是以类的方式注入（基于CGLib代理）1234@Component@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE,proxyMode = ScopedProxyMode.TARGET_CLASS)public class PrototypeCart implements ShoppingCart &#123;&#125; 123&lt;bean id="prototypeCart" class="dome10.PrototypeCart" scope="Session"&gt; &lt;aop:scoped-proxy/&gt;&lt;/bean&gt; springMVC​ 运行流程图 dispatcher Servlet 前端控制器（front Controller）核心 快速尝鲜： 基于spring 搭建spring mvc1.将DispatcherServlet 注册到web容器中 在 Servlet 3. 0 环境 中， 容器 会在 类 路径 中 查找 实现 javax. servlet. ServletContainerInitializer 接口 的 类， 如果 能 发现 的 话， 就会 用 它来 配置 Servlet 容器。 ​ Spring 提供 了 这个 接口 的 实现， 名为 SpringServletContainerInitializer。 12@HandlesTypes(&#123;WebApplicationInitializer.class&#125;)public class SpringServletContainerInitializer implements ServletContainerInitializer ​ 其中的HandlesTypes 是什么？ 1.Tomcat的主机容器在添加子容器时，会通过解析.xml并通过类加载器加载@HandlesTypes注解的类 2.读取@HandlesTypes注解值值。并放入ServletContainerInitializers对应的Set集合中 3.在ApplicationContext内部启动时会通知ServletContainerInitializers的onStart方法（）。这个onStart方法的第一个参数就是@HandlesTypes注解的值值指定的类集合 4.在Spring应用中，对ServletContainerInitializers的实现就是SpringServletContainerInitializer，注解指定的类就是WebApplicationInitializer。 通过上面解读过程我们知道，如果要想使用基于servlet3.0支持注解申明servlet。使用spring框架时的关注点就在WebApplicationInitializer接口中。 如果个人有能力或者有兴趣的化可以自己通过实现WebApplicationInitializer接口来注册servlet。但是一般我们只需要使用spring进行过一些封装的AbstractAnnotationConfigDispatcherServletInitializer抽象类即可。 123456789101112131415161718192021222324252627282930313233343536373839package org.springframework.web.servlet.support;import org.springframework.lang.Nullable;import org.springframework.util.ObjectUtils;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;public abstract class AbstractAnnotationConfigDispatcherServletInitializer extends AbstractDispatcherServletInitializer &#123; public AbstractAnnotationConfigDispatcherServletInitializer() &#123; &#125; @Nullable protected WebApplicationContext createRootApplicationContext() &#123; Class&lt;?&gt;[] configClasses = this.getRootConfigClasses(); if (!ObjectUtils.isEmpty(configClasses)) &#123; AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext(); context.register(configClasses); return context; &#125; else &#123; return null; &#125; &#125; protected WebApplicationContext createServletApplicationContext() &#123; AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext(); Class&lt;?&gt;[] configClasses = this.getServletConfigClasses(); if (!ObjectUtils.isEmpty(configClasses)) &#123; context.register(configClasses); &#125; return context; &#125; @Nullable protected abstract Class&lt;?&gt;[] getRootConfigClasses(); @Nullable protected abstract Class&lt;?&gt;[] getServletConfigClasses();&#125; 使用 AbstractAnnotationConfigDispatcherServletInitializer注册容器并初始化上下文 123456789101112131415161718192021222324package com.healthengine.medpro.common.config;import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;public class ServletConfigAchieve extends AbstractAnnotationConfigDispatcherServletInitializer &#123; //用来配置ContextLoaderListener 的上下文 @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[0]; &#125; //用来配置springMvc 中Dispatcher Servlet 上下文 @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[0]; &#125; //配置容器请求的映射路径 @Override protected String[] getServletMappings() &#123; return new String[0]; &#125;&#125; 配置Filter方式1：基于Disparther Servlet 配置​ 123456789101112131415161718192021222324252627282930313233343536package com.healthengine.medpro.common.config;import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;import javax.servlet.Filter;import javax.servlet.MultipartConfigElement;import javax.servlet.ServletContext;import javax.servlet.ServletRegistration;public class ServletConfigAchieve extends AbstractAnnotationConfigDispatcherServletInitializer &#123; //用来配置ContextLoaderListener 的上下文 @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[0]; &#125; //用来配置springMvc 中Dispatcher Servlet 上下文 @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[0]; &#125; //配置容器请求的映射路径 @Override protected String[] getServletMappings() &#123; return new String[0]; &#125; //设置filter @Override protected Filter[] getServletFilters() &#123; return //自己定义的filter 类（数组） &#125;&#125; 方式2：自行实现处理Multipart格式的内容信息​ 1.配置类 12345678910111213141516171819202122232425262728293031323334353637package com.healthengine.medpro.common.config;import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;import javax.servlet.Filter;import javax.servlet.MultipartConfigElement;import javax.servlet.ServletContext;import javax.servlet.ServletRegistration;public class ServletConfigAchieve extends AbstractAnnotationConfigDispatcherServletInitializer &#123; //用来配置ContextLoaderListener 的上下文 @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[0]; &#125; //用来配置springMvc 中Dispatcher Servlet 上下文 @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[0]; &#125; //配置容器请求的映射路径 @Override protected String[] getServletMappings() &#123; return new String[0]; &#125; //自定义注册 @Override protected void customizeRegistration(ServletRegistration.Dynamic registration) &#123; //Multipart 配置设置 registration.setMultipartConfig(new MultipartConfigElement("temp/medpro/")); &#125;&#125; 2.配置MultipartResolver Bean MultipartResolver 是springframework.web提供用于处理Multipart的接口规范 ​ 1.CommonsMultipartResolver： 使用 Jakarta Commons FileUpload 解析 multipart 请求； ​ 2.StandardServletMultipartResolver： 依赖于 Servlet 3. 0 对 multipart 请求 的 支持（ 始于 Spring 3. 1）。 123@Bean public MultipartResolver multipartResolver() throws IOException &#123; return new StandardServletMultipartResolver();&#125; 3.测试代码 12345678@GetMappingpublic void multipartHandle(MultipartFile multipartFile) throws IOException &#123; String originalFilename = multipartFile.getOriginalFilename(); byte[] bytes = multipartFile.getBytes(); String contentType = multipartFile.getContentType(); InputStream inputStream = multipartFile.getInputStream(); String name = multipartFile.getName();&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[JNDI-转载]]></title>
    <url>%2FMeBlog%2F2020%2F01%2F07%2FJNDI-%E8%BD%AC%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[JNDI是 Java 命名与目录接口（Java Naming and Directory Interface），在J2EE规范中是重要的规范之一，不少专家认为，没有透彻理解JNDI的意义和作用，就没有真正掌握J2EE特别是EJB的知识。那么，JNDI到底起什么作用？ 要了解JNDI的作用，我们可以从“如果不用JNDI我们怎样做？用了JNDI后我们又将怎样做？”这个问题来探讨。 没有JNDI的做法：程序员开发时，知道要开发访问MySQL数据库的应用，于是将一个对 MySQL JDBC 驱动程序类的引用进行了编码，并通过使用适当的 JDBC URL 连接到数据库。就像以下代码这样： Java codeConnection conn=null;try { Class.forName(“com.mysql.jdbc.Driver”, true, Thread.currentThread().getContextClassLoader()); conn=DriverManager.getConnection(“jdbc:mysql://MyDBServer?user=xxx&amp;password=xxx”); …… conn.close();} catch(Exception e) { e.printStackTrace();} finally { if(conn!=null) { try { conn.close(); } catch(SQLException e) {} }} 这是传统的做法，也是以前非Java程序员（如Delphi、VB等）常见的做法。这种做法一般在小规模的开发过程中不会产生问题，只要程序员熟悉Java语言、了解JDBC技术和MySQL，可以很快开发出相应的应用程序。 没有JNDI的做法存在的问题：1、数据库服务器名称MyDBServer 、用户名和口令都可能需要改变，由此引发JDBC URL需要修改；2、数据库可能改用别的产品，如改用DB2或者Oracle，引发JDBC驱动程序包和类名需要修改；3、随着实际使用终端的增加，原配置的连接池参数可能需要调整；4、…… 解决办法：程序员应该不需要关心“具体的数据库后台是什么？JDBC驱动程序是什么？JDBC URL格式是什么？访问数据库的用户名和口令是什么？”等等这些问题，程序员编写的程序应该没有对 JDBC 驱动程序的引用，没有服务器名称，没有用户名称或口令 —— 甚至没有数据库池或连接管理。而是把这些问题交给J2EE容器来配置和管理，程序员只需要对这些配置和管理进行引用即可。 由此，就有了JNDI。 用了JNDI之后的做法：首先，在在J2EE容器中配置JNDI参数，定义一个数据源，也就是JDBC引用参数，给这个数据源设置一个名称；然后，在程序中，通过数据源名称引用数据源从而访问后台数据库。具体操作如下（以JBoss为例）：1、配置数据源在JBoss 的 D:/jboss420GA/docs/examples/jca 文件夹下面，有很多不同数据库引用的数据源定义模板。将其中的 mysql-ds.xml 文件Copy到你使用的服务器下，如 D:/jboss420GA/server/default/deploy。修改 mysql-ds.xml 文件的内容，使之能通过JDBC正确访问你的MySQL数据库，如下： &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; MySqlDS jdbc:mysql://localhost:3306/lw com.mysql.jdbc.Driver root rootpasswordorg.jboss.resource.adapter.jdbc.vendor.MySQLExceptionSorter mySQL 这里，定义了一个名为MySqlDS的数据源，其参数包括JDBC的URL，驱动类名，用户名及密码等。 2、在程序中引用数据源：Java codeConnection conn=null;try { Context ctx = new InitialContext(); Object datasourceRef = ctx.lookup(“java:MySqlDS”); //引用数据源 DataSource ds = (Datasource) datasourceRef; conn = ds.getConnection(); …… c.close();} catch(Exception e) { e.printStackTrace();} finally { if(conn!=null) { try { conn.close(); } catch(SQLException e) {} }} 直接使用JDBC或者通过JNDI引用数据源的编程代码量相差无几，但是现在的程序可以不用关心具体JDBC参数了。在系统部署后，如果数据库的相关参数变更，只需要重新配置 mysql-ds.xml 修改其中的JDBC参数，只要保证数据源的名称不变，那么程序源代码就无需修改。 由此可见，JNDI避免了程序与数据库之间的紧耦合，使应用更加易于配置、易于部署。 总结：J2EE 规范要求所有 J2EE 容器都要提供 JNDI 规范的实现。JNDI 在 J2EE 中的角色就是“交换机” —— J2EE 组件在运行时间接地查找其他组件、资源或服务的通用机制。在多数情况下，提供 JNDI 供应者的容器可以充当有限的数据存储，这样管理员就可以设置应用程序的执行属性，并让其他应用程序引用这些属性（Java 管理扩展（Java Management Extensions，JMX）也可以用作这个目的）。JNDI 在 J2EE 应用程序中的主要角色就是提供间接层，这样组件就可以发现所需要的资源，而不用了解这些间接性。 在 J2EE 中，JNDI 是把 J2EE 应用程序合在一起的粘合剂，JNDI 提供的间接寻址允许跨企业交付可伸缩的、功能强大且很灵活的应用程序。这是 J2EE 的承诺，而且经过一些计划和预先考虑，这个承诺是完全可以实现的。 说白了就是把资源取个名字，再根据名字来找资源。 //===============================================================================================================首先我们来回顾一下简单的问题，列在下面第一点。1.我们知道，Java 的运行从 static main 开始，为什么一定要从 static 方法开始呢？2.在我们知道这个世界上的另外一个地方有一个对象存在而且服务器也会在我们开始工作前为我们准备好，那么我该怎么找到它呢？如果这个对象是我这个类创建的，那么当然简单，直接用对象的引用就能调用它的方法，那如果这个对象不是我创建的，我想主动调用它的方法这似乎在任何编程语言中都不可能，记得写一个方法那是被别人调用的不是主动调用别人。 就像你找人一样，如果他还没有和你建立联系的话(建立联系就是保存一份对象的引用，如果两个对象彼此没有创建另外一个而且也没有被中间的第三方建立这种关系问题就出现了)，请问你如何和他打交道？现实中是：a. 我们拨通 114 Java 中：Context ctx = new InitialContext();b. 请问哪里有通马桶的？114 答，xxx… 为您转接中，请稍候。 Java 中：DataSource ds = (DataSource) ctx.lookup(“便民服务公司”);c. 过了一会儿，人来了，你说：师付，请帮我通马桶吧。 Java 中: ds.getConnection(); 上面的话，我没有回答你什么是 JNDI, 但是我回答了为什么我们需要 JNDI. 希望你在概念上了解了它存在的必要性。 下面的话，给你一点指导如何更好的理解 JNDI 实现：1.一个对象如果它在另外一个地方(可能与当前运行的程序不在同一个 VM / 同一进程中), 对象怎么可能从一个 VM 中发送到另外一个 VM 中呢？像 LDAP 这种，对象的状态还需要持久地保存的话(重启服务器进程后它还在)，又该怎么办呢？请看 JNDI StateFactory, 它用一种方法把一个对象转换成某种方式保存下来，就像我们把一个 Entity 对象保存下来时，我们会用 SQL 来做一样。 2.有一个对象上次已经保存了状态，现在服务器重启了，上次的对象肯定不在内存里面，我们怎么恢复上次的状态呢？请看 JNDI ObjectFactory. 它读取一些上次保存的状态信息，来创建并初始化一个对象。比如：我们配置了一个 XML，它是某个 JDBC 数据源的配置数据，Application Server 启动时读取这个信息(相当于上次的状态),然后重启对象。 3.企业应用这么复杂，面向接口编程，那如何用一种简单的方式来配置新的实现类呢？Java 的做法是：已经定义了 SPI (Service Provider Interface). 包括以下几点： 接口准备好了，如：StateFactory / ObjectFactory. 配置：先搜索 JRE 下面的某个 jndiprovider.properties 文件当作默认实现，再查找用户 classpath 根路径下 /jndi.properties. 另外还有 System.getProperties() 和在创建 InitialContext 给一个 hashtable 作为参数，这三个参数, 有优先级的关系，越是后面具体的参数优先级越高，越前面越通用型的参数优先级越低。这一点，请看 JDK ResourceManager 这个类的源码。 实现类与初始化它们是如何自动完成的呢？这个你需要看 Context 接口里面的常量，以及拿 Sun LDAP InitialContextFactory 运行样例来看 Context 接口的常量一个样本参数值，一般我们很重要的是 InitialContextFactory 这个参数，但也有时候也有其他参数要配置，比如：pkgs, 它是说，我们给一个包名，JNDI 管理器要查找实现时用这个包名列表当成包名，类名就是 协议名 + 固定的后缀：比如： ldap://localhost:389, 它会用一个’包名前缀.协议名.协议名 + URLContextFactory’ 作为类名来搜索一个类，如果它存在就把它当成实现类，如果没找到再尝试另外一个包名前缀。你可以看 com.sun.jndi.url 名，下面有例子看，比如说 ldap:// 的情况就是 找一个类 com.sun.jndi.url.ldap.ldapURLContextFactory，如果是 dns://www.163.com/xxx 就找个 com.sun.jndi.url.dns.dnsURLContextFactory。这是 URL context factory 也就是当你使用 ctx.lookup(“java:xxxx/yyy”) 这种带协议前缀的时候。 另外你也可以类比地看 com.sun.www.protocol 包里面的类，它是另外不一个与 JNDI 不相关的 URLStreamHandler 处理的规则，与些设计和配置几乎完全相同。我以前写过一个 jdbc:oracle:username/password:@localhost:1521:training/[select A from C where DEL_IND = 0] , 在 java 程序中输入这个 URL 我们可以把数据库里面的数据读取出来，效果就根你输入 file:/C:/boot.ini 读取了这个文件内容一样，办法就是我写了一个支持 jdbc 协议的 URLStreamHandler 在命令行配置一个使用它，其他的应用程序类就能自动处理，它们都不知道我是从数据库里面读取的数据。 J2EE 1.3 开始，资源的管理由应用服务器单独来管理和配置，这与 J2EE 1.2 不同，在 J2EE 1.2 中我们直接在应用程序中配置我们要用的资源。J2EE 1.3 中我们配置一个数据源在服务器上，我们在应用程序中只需要说明我们配置的资源的引用就行了，比如我们只在 web.xml 或 ejb-jar.xml 配置 而不是 data source 本身。这有什么好处？比如：我们定义了两个 training 的数据源：jdbc/training/db2. jdbc/oracle/db2. 一个是开发环境，一个是 UAT 环境，现在开发时我们建立一个 指向jdbc/training/db2，那么就用 db2 数据库，UAT 测试时我们建立另外一个 指向 jdbc/training/oracle, 就会使用 oracle 数据库，而这本身不需要修改代码，只是修改了 web.xml / ejb-jar.xml ,而且现在连接到数据的用户名和密码不再是应用程序开发本身的事情，因为你不需要配置资源也就不需要知道它的登录名和密码，而是由管理员在服务器上配置数据源，这里注意，开发人员做他代码部分的事情，服务器管理员负责配置资源源，J2EE component provider 和 Deployer 两个角色的职责分开了，虽然现实中 deployer 都是委托给了开发人员，但 J2EE 规范是分开来描述的。 5.上面说了半天，目的是什么呢？这是我的痛苦经历，第一次写 EJB, 买了本书，J2EE 从入门到精通(就是那本传说中的黃皮宝典系列)，写了一个无状态 session bean 来访问数据源，死活找不到数据源：NamingException: xxx not found. 在 IBM developerworks 上看到一篇文章，茅塞顿开，原来那本书讲的是J2EE 1.2, 我用的 WSAD 5.1.2 开发用的默认配置都是 J2EE 1.3。这里面引出了 JNDI LinkRef, 为了实现上面 4 里面所说的服务器上配置一个资源，但应用程序里面配置一个引用的话，现在的应用服务器在处理这点JNDI技术实现上基本上都是用 LinkRef 来实现的，这是 JNDI 里面的一个类。服务器启动时会创建一个 jdbc/training/db2 和 jdbc/training/oracle 两个 DataSource 对象 (用的是 ObjectFactory), 当一个应用程序访问了准备访问数据源时，服务器检测到了 web.xml/ejb-jar.xml 中指定了 它就会创建一个 LinkRef 放到 context 中去，它的名称是：jdbc/training,但它的 ref 是 jdbc/training/db2.这样我们 ctx.lookup(“java:jdbc/training”) 时，java 协议对应的 javaURLContextFactory 会把这个 jdbc/training 对象找出来，在检测到它是一个 LinkRef 对象时，会自动再用它的 ref 值(这里是 jdbc/training/db2) 再 lookup 一遍，这下终于找到 jdbc/training/db2 这个 data source 对象。 6.JNDI 里面还有其他的相关的东西。再结合一个 Reference 概念看，LinkRef 是继承它的。想再具体的了解一个实现细节，请拿一份 apache commons-xxx.jar (名字我忘记了，不过用过 spring / hibernate 来创建数据源的人可能知道它们用 xxxDataSource 做一个不需要在服务器上配置，但却能使用 data source 的办法)，我不是推荐你这个 jar, 我是推荐你看这个xxxDataSource 源码，里面演示了一个 ObjectFactory 用法。这和 JMS ConnectionFactory等其他 J2EE 托管资源的配置和使用都是用的同样的技术实现的。举一反三。想了解更，就再看一个 StateFactory 的实现以及 Reference 的源码之类的。作为期望迈入 J2EE 中级编程的你，至少在概念和理论上要知道 ObjectFactory / LinkRef / SPI / resource ref 配置这几点，如果你再知道 StateFactory 是怎么实现的就更好了。 转载自https://blog.csdn.net/wn084/article/details/80729230]]></content>
  </entry>
  <entry>
    <title><![CDATA[树莓派-系统篇]]></title>
    <url>%2FMeBlog%2F2019%2F11%2F22%2F%E6%A0%91%E8%8E%93%E6%B4%BE-%E7%B3%BB%E7%BB%9F%E7%AF%87%2F</url>
    <content type="text"><![CDATA[shell程序开机启动核心文件是 /etc/profile 1234vim /etc/profile#将需要开机自启动的文件路径加入/home/pi/text.sh 获取系统位数1getconf LONG_BIT]]></content>
  </entry>
  <entry>
    <title><![CDATA[树莓派-apt篇]]></title>
    <url>%2FMeBlog%2F2019%2F11%2F22%2F%E6%A0%91%E8%8E%93%E6%B4%BE-apt%E7%AF%87%2F</url>
    <content type="text"><![CDATA[添加apt source 资源路径主要修改/etc/apt/sources.list 文件 添加阿里镜像1234sudo vim /etc/apt/sources.list#添加如下内容deb http://mirrors.aliyun.com/raspbian/raspbian/ wheezy main non-free contribdeb-src http://mirrors.aliyun.com/raspbian/raspbian/ wheezy main non-free contrib]]></content>
  </entry>
  <entry>
    <title><![CDATA[Anaconda 工具]]></title>
    <url>%2FMeBlog%2F2019%2F09%2F27%2FAnaconda%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Pythonversion 环境切换列出当前Anaconda python拥有的环境列表12345(python36) spiderbao@spiderbao-CW65S:~$ conda info -e# conda environments:#base /home/spiderbao/anaconda3python36 * /home/spiderbao/anaconda3/envs/python36 其中base 为安装Anaconda 所默认安装的 查看当前Python的版本12(python36) spiderbao@spiderbao-CW65S:~$ python -VPython 3.6.9 :: Anaconda, Inc. 安装新的Python 版本1conda create --name python36 python=3.6 其中 python36 为别名 新版本安装完后一些常用的库和包需要手动安装 切换Python 版本1conda activate python36 其中Python36 为别名 切换会之前的环境1conda deactivate 删除指定的版本环境1conda remove --name python34 --all 其中python34 为别名 手动安装常用的库和包12345conda install numpyconda install scipyconda install matplotlib]]></content>
  </entry>
  <entry>
    <title><![CDATA[python带我飞-note]]></title>
    <url>%2FMeBlog%2F2019%2F09%2F18%2FPython%E5%B8%A6%E6%88%91%E9%A3%9E-note%2F</url>
    <content type="text"><![CDATA[第二篇 进阶变量变量是编程语言中最基础的术语，用来指计算机中存储的可变数据。如下例子 1Val = "hello" 变量的规则类型不同，存储功能不同 申明变量无需定义变量类型，直接赋值即可 如何做到直接赋值，原因是Python内部对变量进行了对象封装，并且它具有三个重要的属性id,type,value 变量的类型Python3中的类型划分为6种： number 数字可以划分为 int float bool complex 等 string 字符串 tuple 元组 sets 集合 dictionaries 字典 变量类型的帮助函数dir 用来查询类型的所有属性。如dir(number) help 用来查询类型具体的说明文档。如help(number)]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql必知必会-note]]></title>
    <url>%2FMeBlog%2F2019%2F09%2F10%2Fmysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-note%2F</url>
    <content type="text"><![CDATA[了解sql数据库基础术语什么是数据库数据库是一个以某种有组织的方式存储的数据集合。所以本人认为数据库是一个管理数据的概念。 表表是某种特定类型数据的结构化清单。 模式模式 是关于数据库和表的布局及特性的信息 列列 column 表中的一个字段，所有表是由一个或多个列组成。 数据类型数据类型 datatype 表示所容许的数据类型。每个表的列都有相应的数据类型，它限制了列中存储的数据。数据类型对于数据的排序，和优化磁盘使用方面起到了重要的作用。 行行 row 表中的一行记录。 主键主键 primarykey 由一列或列表示。它们与普通的列不同，它们具有其值具有表中唯一性切不为null的特性。 什么是sqlsql 的全称是structured query language （结构化查询语言）它是一个专门用来跟数据库通讯的语言。 sql具有的特定及优点如下 1.互通性 sql 不是某个DBMS厂商的专属语言，所以使用sql可以操作大多数DBMS产品 如MySQL 2.简单易学。sql的大多数功能由一个或几个关键字组成，所以学习成本较低。 3.在保持语法简单的情况下，做到了功能强大操作灵活。 mysql简介什么是MySQL首先MySQL它是一种DBMS产品，DBMS是databaseManageSystem 的简称。其次MySQL具有如下特性 1.成本底，由于MySQL是开源产品所以企业商业是不需要支付费用的。 2.性能，MySQL在DBMS系列产品中的性能优越 3.可信赖，就像Linux内核一样。MySQL的开源使得其的使用者和维护者增多。 4.简单易用 DBMS产品分类DBMS产品可以大致分为2类，一类是基于共享文件系统如File Maker 等。另一类是基于客户机与服务器的如MySQL、Oracle等 MySQL工具（客户端）MySQL workbench mysql命令行（自带） 使用MySQL链接链接一般用于像 MySQL workbench 这样的工具或程序代码中。 链接案例如下： 1root@localhost:3306 其中 root表示用户名 localhost 表示IP地址 3306 表示服务端口 选择数据库登录数据库后使用MySQL命令行工具选择切换数据库可以使用关键字USE实现 1USE 存在的数据库名称 关于SHOW的一些操作显示所有的数据库名称 1234567891011121314mysql&gt; SHOW DATABASES;+--------------------+| Database |+--------------------+| information_schema || crashcourse || fileupload || maven_study || mybatis_study || mysql || performance_schema || sys |+--------------------+8 rows in set (0.00 sec) 显示数据库中的所有表名称，注意：此时需要使用USE选择要查看的数据库 1234567891011121314mysql&gt; USE crashcourse;Database changedmysql&gt; SHOW TABLES;+-----------------------+| Tables_in_crashcourse |+-----------------------+| customers || orderitems || orders || productnotes || products || vendors |+-----------------------+6 rows in set (0.00 sec) 显示表中列column的信息 123456789mysql&gt; SHOW COLUMNS FROM orders;+------------+----------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+------------+----------+------+-----+---------+----------------+| order_num | int(11) | NO | PRI | NULL | auto_increment || order_date | datetime | NO | | NULL | || cust_id | int(11) | NO | MUL | NULL | |+------------+----------+------+-----+---------+----------------+3 rows in set (0.00 sec) 此查询还有一个快捷方式就是 123456789mysql&gt; DESCRIBE orders;+------------+----------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+------------+----------+------+-----+---------+----------------+| order_num | int(11) | NO | PRI | NULL | auto_increment || order_date | datetime | NO | | NULL | || cust_id | int(11) | NO | MUL | NULL | |+------------+----------+------+-----+---------+----------------+3 rows in set (0.00 sec) DESCRIBE 是 SHOW COLUMNS FROM的一种快捷方式 显示数据库创建语句或表的创建语句 123456789101112131415161718192021222324mysql&gt; SHOW CREATE DATABASE crashcourse;+-------------+---------------------------------------------------------------------------------------+| Database | Create Database |+-------------+---------------------------------------------------------------------------------------+| crashcourse | CREATE DATABASE `crashcourse` /*!40100 DEFAULT CHARACTER SET utf8 COLLATE utf8_bin */ |+-------------+---------------------------------------------------------------------------------------+1 row in set (0.00 sec)mysql&gt; SHOW CREATE TABLE order;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;order&apos; at line 1mysql&gt; SHOW CREATE TABLE orders;+--------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+--------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| orders | CREATE TABLE `orders` ( `order_num` int(11) NOT NULL AUTO_INCREMENT, `order_date` datetime NOT NULL, `cust_id` int(11) NOT NULL, PRIMARY KEY (`order_num`), KEY `fk_orders_customers` (`cust_id`), CONSTRAINT `fk_orders_customers` FOREIGN KEY (`cust_id`) REFERENCES `customers` (`cust_id`)) ENGINE=InnoDB AUTO_INCREMENT=20010 DEFAULT CHARSET=utf8 COLLATE=utf8_bin |+--------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) 关于SHOW的一些命令可以通过 HELP SHOW获取 检索数据SELECT语句select是sql中最常用的查询语句 检索单个列1234567891011121314151617181920mysql&gt; SELECT prod_name FROM products;+----------------+| prod_name |+----------------+| .5 ton anvil || 1 ton anvil || 2 ton anvil || Detonator || Bird seed || Carrots || Fuses || JetPack 1000 || JetPack 2000 || Oil can || Safe || Sling || TNT (1 stick) || TNT (5 sticks) |+----------------+14 rows in set (0.00 sec) 本次查询只是单纯的检索了单个列的数据，没有对数据做过滤和排序。 个人认为过滤不是必须的，但排序是必须的。因为不指定排序的数据顺序是不可控的。 检索多个列1234567891011121314151617181920mysql&gt; SELECT prod_id,prod_name,prod_price FROM products;+---------+----------------+------------+| prod_id | prod_name | prod_price |+---------+----------------+------------+| ANV01 | .5 ton anvil | 5.99 || ANV02 | 1 ton anvil | 9.99 || ANV03 | 2 ton anvil | 14.99 || DTNTR | Detonator | 13.00 || FB | Bird seed | 10.00 || FC | Carrots | 2.50 || FU1 | Fuses | 3.42 || JP1000 | JetPack 1000 | 35.00 || JP2000 | JetPack 2000 | 55.00 || OL1 | Oil can | 8.99 || SAFE | Safe | 50.00 || SLING | Sling | 4.49 || TNT1 | TNT (1 stick) | 2.50 || TNT2 | TNT (5 sticks) | 10.00 |+---------+----------------+------------+14 rows in set (0.00 sec) 注意多个列间使用,分割最后一个不需要加入,不然会出现语法错误 如果现在需要检索表中的所有列，可以使用通配符*代替列名。 检索数据去重12345678910111213141516171819202122232425262728293031mysql&gt; SELECT vend_id FROM products;+---------+| vend_id |+---------+| 1001 || 1001 || 1001 || 1002 || 1002 || 1003 || 1003 || 1003 || 1003 || 1003 || 1003 || 1003 || 1005 || 1005 |+---------+14 rows in set (0.00 sec)mysql&gt; SELECT DISTINCT vend_id FROM products;+---------+| vend_id |+---------+| 1001 || 1002 || 1003 || 1005 |+---------+4 rows in set (0.00 sec) 第一次select 查询获取了products.vend_id的所有数据第二次select 查询内容同上但是加入了DISTINCT关键字对数据进行了去重。 DISTINCT使用注意事项 1.不能对部分列使用，如 prod_id,DISTINCT vend_id。 2.DISTINCT 位于 SELECT 后 列前 ，所有的被检索的列将都具有去重功能。 检索限制输出想要控制输出就使用 limit关键字如下 输出查询结果的前5行1234567891011mysql&gt; SELECT prod_name FROM products LIMIT 5;+--------------+| prod_name |+--------------+| .5 ton anvil || 1 ton anvil || 2 ton anvil || Detonator || Bird seed |+--------------+5 rows in set (0.00 sec) 从第1行开始显示3行 123456789mysql&gt; SELECT prod_name FROM products LIMIT 1,3;+-------------+| prod_name |+-------------+| 1 ton anvil || 2 ton anvil || Detonator |+-------------+3 rows in set (0.00 sec) 使用完全限定之前的查询语句中使用的都是先对表名，举个对比的例子如下 未使用完全限定的查询语句 SELECT prod_name FROM products LIMIT 1,3 使用完全限定的查询语句 SELECT products.prod_name FROM crashcourse.products LIMIT 1,3 使用完全限定时语句更严谨。推荐使用！ 排序检索数据单列排序数据1234567891011121314151617181920mysql&gt; SELECT prod_name FROM products ORDER BY prod_name;+----------------+| prod_name |+----------------+| .5 ton anvil || 1 ton anvil || 2 ton anvil || Bird seed || Carrots || Detonator || Fuses || JetPack 1000 || JetPack 2000 || Oil can || Safe || Sling || TNT (1 stick) || TNT (5 sticks) |+----------------+14 rows in set (0.00 sec) 根据products.prod_name 按字母升序排序。 多列排序顺序1234567891011121314151617181920mysql&gt; SELECT prod_id,prod_price,prod_name FROM products ORDER BY prod_price,prod_name;+---------+------------+----------------+| prod_id | prod_price | prod_name |+---------+------------+----------------+| FC | 2.50 | Carrots || TNT1 | 2.50 | TNT (1 stick) || FU1 | 3.42 | Fuses || SLING | 4.49 | Sling || ANV01 | 5.99 | .5 ton anvil || OL1 | 8.99 | Oil can || ANV02 | 9.99 | 1 ton anvil || FB | 10.00 | Bird seed || TNT2 | 10.00 | TNT (5 sticks) || DTNTR | 13.00 | Detonator || ANV03 | 14.99 | 2 ton anvil || JP1000 | 35.00 | JetPack 1000 || SAFE | 50.00 | Safe || JP2000 | 55.00 | JetPack 2000 |+---------+------------+----------------+14 rows in set (0.00 sec) 上述例子中的输出，仅在多行拥有相同的prod_price值时，才对产品prod_name进行排序。如果prod_price的值都是唯一的就不会使用prod_name的条件进行排序 排序的方向默认排序的方向是升序，相反降序的案例如下 1234567891011121314151617181920mysql&gt; SELECT prod_id,prod_price,prod_name FROM products ORDER BY prod_price DESC;+---------+------------+----------------+| prod_id | prod_price | prod_name |+---------+------------+----------------+| JP2000 | 55.00 | JetPack 2000 || SAFE | 50.00 | Safe || JP1000 | 35.00 | JetPack 1000 || ANV03 | 14.99 | 2 ton anvil || DTNTR | 13.00 | Detonator || FB | 10.00 | Bird seed || TNT2 | 10.00 | TNT (5 sticks) || ANV02 | 9.99 | 1 ton anvil || OL1 | 8.99 | Oil can || ANV01 | 5.99 | .5 ton anvil || SLING | 4.49 | Sling || FU1 | 3.42 | Fuses || FC | 2.50 | Carrots || TNT1 | 2.50 | TNT (1 stick) |+---------+------------+----------------+14 rows in set (0.00 sec) 另外 DESC 不同于 DISTINCT 它可用于不同的条件列，只需要在每个列后加入DESC即可。 SELECT prod_id,prod_price,prod_name FROM products ORDER BY prod_price DESC,prod_name; 表示按价格降序排序，如果有价格相同的按商品名称升序排序。 过滤数据where子语句where子语句可以添加一些查询条件，过滤数据。 根据where 操作符过滤where操作符如下 = 等于 &lt;&gt; 不等于 != 不等于 &lt; 小于 &lt;= 小于等于 大于 = 大于等于 BETWEEN 在指定两个值之间，包括指定的值 BETWEEN 使用获取价格在5-10元的商品1234567891011mysql&gt; SELECT prod_name,prod_price FROM products WHERE prod_price BETWEEN 5 AND 10 ORDER BY prod_price DESC;+----------------+------------+| prod_name | prod_price |+----------------+------------+| Bird seed | 10.00 || TNT (5 sticks) | 10.00 || 1 ton anvil | 9.99 || Oil can | 8.99 || .5 ton anvil | 5.99 |+----------------+------------+5 rows in set (0.00 sec) 空值null过滤获取商品价格为null 的所有商品 12mysql&gt; SELECT prod_name FROM products WHERE prod_price IS NULL;Empty set (0.00 sec) 获取商品价格不为null 的所有商品 1234567891011121314151617181920mysql&gt; SELECT prod_name FROM products WHERE prod_price IS NOT NULL;+----------------+| prod_name |+----------------+| .5 ton anvil || 1 ton anvil || 2 ton anvil || Detonator || Bird seed || Carrots || Fuses || JetPack 1000 || JetPack 2000 || Oil can || Safe || Sling || TNT (1 stick) || TNT (5 sticks) |+----------------+14 rows in set (0.00 sec) AND OR IN NOT 操作符操作符（operator）的定义：用来联结或改变WHERE字句中的关键字。也称为逻辑操作符 AND相当于语句中的并且，用作条件追加。 查询厂商id为1003 并且价格大于等于10 12345678910mysql&gt; SELECT vend_id,prod_id,prod_price,prod_name FROM products WHERE vend_id = 1003 AND prod_price &gt;= 10 ORDER BY prod_name;+---------+---------+------------+----------------+| vend_id | prod_id | prod_price | prod_name |+---------+---------+------------+----------------+| 1003 | FB | 10.00 | Bird seed || 1003 | DTNTR | 13.00 | Detonator || 1003 | SAFE | 50.00 | Safe || 1003 | TNT2 | 10.00 | TNT (5 sticks) |+---------+---------+------------+----------------+4 rows in set (0.00 sec) AND 可以在一次查询中多次使用 OR相当于语句中或者，用于条件选择。 查询厂商id为1003或1002的商品信息 123456789101112131415mysql&gt; SELECT vend_id,prod_name,prod_price FROM products WHERE vend_id = 1003 OR vend_id = 1002 ORDER BY prod_name;+---------+----------------+------------+| vend_id | prod_name | prod_price |+---------+----------------+------------+| 1003 | Bird seed | 10.00 || 1003 | Carrots | 2.50 || 1003 | Detonator | 13.00 || 1002 | Fuses | 3.42 || 1002 | Oil can | 8.99 || 1003 | Safe | 50.00 || 1003 | Sling | 4.49 || 1003 | TNT (1 stick) | 2.50 || 1003 | TNT (5 sticks) | 10.00 |+---------+----------------+------------+9 rows in set (0.00 sec) OR 可以在一次查询中多次使用 AND OR 联合使用使用时需要注意优先级问题。 MySQL中默认 AND 与 OR 同时出现时 AND 优先被执行。 误区案例 查询厂商为1002或1003的价格大于等于10的商品123456789101112mysql&gt; SELECT vend_id,prod_name,prod_price FROM products WHERE vend_id = 1002 OR vend_id = 1003 AND prod_price &gt;= 10 ORDER BY prod_name;+---------+----------------+------------+| vend_id | prod_name | prod_price |+---------+----------------+------------+| 1003 | Bird seed | 10.00 || 1003 | Detonator | 13.00 || 1002 | Fuses | 3.42 || 1002 | Oil can | 8.99 || 1003 | Safe | 50.00 || 1003 | TNT (5 sticks) | 10.00 |+---------+----------------+------------+6 rows in set (0.00 sec) 此时发现 价格 为 3.42 和 8.99的商品被查出。原因是上面所说的优先级导致的。 误区解决 12345678910mysql&gt; SELECT vend_id,prod_name,prod_price FROM products WHERE (vend_id = 1002 OR vend_id = 1003) AND prod_price &gt;= 10 ORDER BY prod_name;+---------+----------------+------------+| vend_id | prod_name | prod_price |+---------+----------------+------------+| 1003 | Bird seed | 10.00 || 1003 | Detonator | 13.00 || 1003 | Safe | 50.00 || 1003 | TNT (5 sticks) | 10.00 |+---------+----------------+------------+4 rows in set (0.00 sec) 当OR条件加入（）时它的优先级就大于了AND,就像是数学运算的优先级问题一样被（）解决。 AND 和 OR 同时使用的场景下建议使用（）。 ININ 用来指定条件范围使用OR操作符过滤数据的一些案例，同样使用IN也可以完成 查询厂商id为1003或1002的商品信息 123456789101112131415mysql&gt; SELECT vend_id,prod_name,prod_price FROM products WHERE vend_id IN (1002,1003) ORDER BY prod_name;+---------+----------------+------------+| vend_id | prod_name | prod_price |+---------+----------------+------------+| 1003 | Bird seed | 10.00 || 1003 | Carrots | 2.50 || 1003 | Detonator | 13.00 || 1002 | Fuses | 3.42 || 1002 | Oil can | 8.99 || 1003 | Safe | 50.00 || 1003 | Sling | 4.49 || 1003 | TNT (1 stick) | 2.50 || 1003 | TNT (5 sticks) | 10.00 |+---------+----------------+------------+9 rows in set (0.00 sec) IN与OR比较具有的优点如下 1.语法更清晰简洁 2.在使用IN时操作符优先级问题会减少 3.执行更快 4.IN可以包含其他的SELECT语句。使得能够动态创建WHERE字句 NOTWHERE 字句中的NOT操作符有且只能有一个，功能是否定之后所跟的任何条件。 查询厂商id不是1002,1003的所有商品信息1234567891011mysql&gt; SELECT prod_name,prod_price FROM products WHERE vend_id NOT IN (1002,1003) ORDER BY prod_name;+--------------+------------+| prod_name | prod_price |+--------------+------------+| .5 ton anvil | 5.99 || 1 ton anvil | 9.99 || 2 ton anvil | 14.99 || JetPack 1000 | 35.00 || JetPack 2000 | 55.00 |+--------------+------------+5 rows in set (0.00 sec) NOT支持的取反的操作符有 IN、BETWEEN、EXISTS。 通配符进行过滤LIKELIKE 是开启通配符匹配的关键字。 通配符号 % _ %表示匹配任意字符_表示匹配一个字符 查询商品名称中包含 anvil123456789101112131415161718mysql&gt; SELECT prod_id,prod_name FROM products WHERE prod_name LIKE &apos;%anvil&apos;;+---------+--------------+| prod_id | prod_name |+---------+--------------+| ANV01 | .5 ton anvil || ANV02 | 1 ton anvil || ANV03 | 2 ton anvil |+---------+--------------+3 rows in set (0.00 sec)mysql&gt; SELECT prod_id,prod_name FROM products WHERE prod_name LIKE &apos;_ ton anvil&apos;;+---------+-------------+| prod_id | prod_name |+---------+-------------+| ANV02 | 1 ton anvil || ANV03 | 2 ton anvil |+---------+-------------+2 rows in set (0.00 sec) 使用通配符的技巧 1.不要过度使用通配符，会造成数据库运算压力。 2.在明确需要使用通配符时，除非绝对有必要，否则不要把他们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。 3.仔细注意通配符的位置。 使用正则表达式进行搜索MySQL开启使用正则表达式的关键字符是 REGEXP 12345678mysql&gt; SELECT prod_name FROM products WHERE prod_name REGEXP &apos;.000&apos; ORDER BY prod_name;+--------------+| prod_name |+--------------+| JetPack 1000 || JetPack 2000 |+--------------+2 rows in set (0.00 sec) 创建计算字段计算字段计算字段是原先表中不存在的字段，通过使用数据库函数或计算后并重命名的字段。 拼接字段vendors 表中厂商名称和地址是分离的。客户端需要获取一个vend—title的字段。格式是这样的 vend_name (vend_country) 123456789101112mysql&gt; SELECT Concat(Trim(vend_name),&apos; (&apos;,Trim(vend_country),&apos;)&apos;) AS vend_title FROM vendors ORDER BY vend_name;+-------------------------+| vend_title |+-------------------------+| ACME (USA) || Anvils R Us (USA) || Furball Inc. (USA) || Jet Set (England) || Jouets Et Ours (France) || LT Supplies (USA) |+-------------------------+6 rows in set (0.00 sec) 其中函数 Concat 用于链接多个字符串 Trim函数用于去除字段左右的空格 AS 关键字用于起别名 alias 执行算数计算在表查询中，需要添加一个字段，这个字段来至于表中2个字段的乘积 1234567891011121314151617mysql&gt; SELECT prod_id,quantity,item_price,quantity*item_price AS expended_price FROM orderitems ORDER BY expended_price;+---------+----------+------------+----------------+| prod_id | quantity | item_price | expended_price |+---------+----------+------------+----------------+| SLING | 1 | 4.49 | 4.49 || OL1 | 1 | 8.99 | 8.99 || FB | 1 | 10.00 | 10.00 || FB | 1 | 10.00 | 10.00 || ANV03 | 1 | 14.99 | 14.99 || ANV02 | 3 | 9.99 | 29.97 || TNT2 | 5 | 10.00 | 50.00 || JP2000 | 1 | 55.00 | 55.00 || ANV01 | 10 | 5.99 | 59.90 || FC | 50 | 2.50 | 125.00 || TNT2 | 100 | 10.00 | 1000.00 |+---------+----------+------------+----------------+11 rows in set (0.00 sec) 测试计算使用 SELECT 函数 或运算即可 测试now函数获取当前时间1234567mysql&gt; SELECT NOW();+---------------------+| NOW() |+---------------------+| 2019-09-03 16:07:01 |+---------------------+1 row in set (0.00 sec) 测试 三乘五1234567mysql&gt; SELECT 3*5;+-----+| 3*5 |+-----+| 15 |+-----+1 row in set (0.00 sec) MySQL函数sql是通用的，但是函数并不是通用的。以下介绍关于MySQL提供的函数 文本处理函数下面列举一些关于MySQL处理文本的函数 Left() 返回字符串左边的字符 length() 返回字符串的长度 Locate() 找出字符串的一个子串 Lower() 将字符串转换为小写 LTrim() 去掉字符串左边的空格 Right() 返回字符串右边的字符 RTrim() 去掉字符串右边的空格 Soundex() 返回字符串的soundex值（用于声音模糊查询） SubString() 返回字符串的字符 Upper() 将字符串转换为大写 Upper示例 123456789101112mysql&gt; SELECT vend_name,UPPER(vend_name) AS vend_name_upper FROM vendors ORDER BY vend_name;+----------------+-----------------+| vend_name | vend_name_upper |+----------------+-----------------+| ACME | ACME || Anvils R Us | ANVILS R US || Furball Inc. | FURBALL INC. || Jet Set | JET SET || Jouets Et Ours | JOUETS ET OURS || LT Supplies | LT SUPPLIES |+----------------+-----------------+6 rows in set (0.00 sec) 日期和时间处理函数关于MySQL处理日期和时间的函数 AddDate() 添加一个日期 AddTime() 添加一个时间 CurDate() 返回当前日期 CurTime() 返回当前时间 Date() 返回日期时间的日期部分 DateDiff() 计算两个日期之差 Date_Add() 高度灵活的日期运算函数 Date_Format 返回一个格式化的日期或时间串 Day() 返回一个日期的天数部分 DayOfWeek() 对于一个日期返回对应的星期 Hour() 返回时间中的小时 Minute() 返回时间中的分钟 Month() 返回一个日期的月份部分 Now() 返回当前日期和时间 Second() 返回一个时间的秒 Time() 返回日期时间的时间部分 Year() 返回一个日期的年份部分 Year示例 1234567891011mysql&gt; SELECT order_date,Year(order_date) AS order_date_year From orders ORDER BY order_date_year;+---------------------+-----------------+| order_date | order_date_year |+---------------------+-----------------+| 2005-09-01 00:00:00 | 2005 || 2005-09-12 00:00:00 | 2005 || 2005-09-30 00:00:00 | 2005 || 2005-10-03 00:00:00 | 2005 || 2005-10-08 00:00:00 | 2005 |+---------------------+-----------------+5 rows in set (0.00 sec) MySQL中的数值处理函数Abs() 返回一个数的绝对值 Cos() 返回一个角度的余弦 Exp() 返回一个数的指数值 Mod() 返回操作的余数 Pi() 返回圆周率 Rand() 返回一个随机数 Sin() 返回一个角度的正弦 Sqrt() 返回一个数的平方根 Tan() 返回一个角度的正切 汇总数据聚集函数AVGAVG() 返回某列的平均值 案例：获取所有商品的平均价格 1234567mysql&gt; SELECT AVG(prod_price) AS prod_price_avg FROM products;+----------------+| prod_price_avg |+----------------+| 16.133571 |+----------------+1 row in set (0.00 sec) COUNTCOUNT() 统计表中的行数，参数（parameter）为*时代表所有列null也会被统计。当指定特定的列时只针对指定的列统计并且null不会计入统计。 案例：统计商品个数 123456789101112131415mysql&gt; SELECT COUNT(*) FROM customers;+----------+| COUNT(*) |+----------+| 5 |+----------+1 row in set (0.00 sec)mysql&gt; SELECT COUNT(cust_email) FROM customers;+-------------------+| COUNT(cust_email) |+-------------------+| 3 |+-------------------+1 row in set (0.00 sec) MAXMAX() 获取指定列中的最大值，必须传入指定的列。当遇到null会忽略 案例：获取商品的最大价格 1234567mysql&gt; SELECT MAX(prod_price) AS max_price FROM products;+-----------+| max_price |+-----------+| 55.00 |+-----------+1 row in set (0.00 sec) MINMIN() 与MAX相反获取列中的最小值。注意事项一致。 案例：获取商品的最小值 1234567mysql&gt; SELECT MIN(prod_price) AS min_price FROM products;+-----------+| min_price |+-----------+| 2.50 |+-----------+1 row in set (0.00 sec) SUNSUN() 求和函数。null被忽略 案例：获取20005订单的商品的数量 1234567mysql&gt; SELECT SUM(quantity) AS items_ordered FROM orderitems WHERE order_num = 20005;+---------------+| items_ordered |+---------------+| 19 |+---------------+1 row in set (0.00 sec) 聚集函数中DISTINCT和All聚集函数默认取值范围是all（指定列的所有值）我们可以在上面的几个聚集函数中使用DISTINCT去重后进行聚合计算 上面的5个函数中MAX和MIN使用DISTINCT无意义。因为我们要获取的是最大值或最小值 DISTINCT不能用于COUNT(*)，因为不允许使用COUNT(DISTINCT)。类似的DISTINCT必须使用列名。 案例：获取不同商品价格的平均值 1234567mysql&gt; SELECT AVG(DISTINCT prod_price) AS avg_price FROM products;+-----------+| avg_price |+-----------+| 17.780833 |+-----------+1 row in set (0.00 sec) 组合聚合函数案例：获取所有商品数量，商品的最大值、最小值以及商品的平均值 1234567mysql&gt; SELECT COUNT(*) AS num_item,MAX(prod_price) AS max_price,MIN(prod_price) AS min_price,AVG(prod_price) AS avg_price FROM products;+----------+-----------+-----------+-----------+| num_item | max_price | min_price | avg_price |+----------+-----------+-----------+-----------+| 14 | 55.00 | 2.50 | 16.133571 |+----------+-----------+-----------+-----------+1 row in set (0.00 sec) 分组数据数据分组数据为什么要分组，当遇到求每组每种……的需求时我们可以考虑使用分组。 使用group by可以实现分组声明。同时下面列举一些关于分组的规定 1.GROUP BY 分组后，数据将在最后规定的分组上进行汇总。也就是说分组后不能从个别的列中获取数据 2.GROUP BY子句中列出的每列都必须是检索或有效的表达式（不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。 3.除聚集计算外，SELECT语句中的每个列必须在GROUP BY字句中给出 4.如果分组中存在null值，则将null作为一个分组返回。如果列中存在多行null值，它们将分为一组。 5.GROUP BY 语法顺序在 WHERE之后ORDER BY之前。 案例：获取每个厂商的商品个数 12345678910mysql&gt; SELECT vend_id,COUNT(*) FROM products GROUP BY vend_id ORDER BY vend_id;+---------+----------+| vend_id | COUNT(*) |+---------+----------+| 1001 | 3 || 1002 | 2 || 1003 | 7 || 1005 | 2 |+---------+----------+4 rows in set (0.00 sec) 过滤分组就是在分组的前提下过滤数据，可使用HAVING完成过滤 案例：获取每个厂商商品数量，厂商商品数量小于2过滤掉。 12345678910mysql&gt; SELECT vend_id,COUNT(*) AS prod_num FROM products GROUP BY vend_id HAVING prod_num &gt;=2;+---------+----------+| vend_id | prod_num |+---------+----------+| 1001 | 3 || 1002 | 2 || 1003 | 7 || 1005 | 2 |+---------+----------+4 rows in set (0.00 sec) 过滤分组+排序案例：获取每个厂商商品数量，厂商商品数量小于2过滤掉。最后按商品数量的升序排列 12345678910mysql&gt; SELECT vend_id,COUNT(*) AS prod_num FROM products GROUP BY vend_id HAVING prod_num &gt;=2 ORDER BY prod_num;+---------+----------+| vend_id | prod_num |+---------+----------+| 1002 | 2 || 1005 | 2 || 1001 | 3 || 1003 | 7 |+---------+----------+4 rows in set (0.01 sec) 行过滤+分组过滤+排序案例：获取每个厂商商品数量，过滤掉商品价格小于10的商品，厂商商品数量小于2也过滤掉。最后按商品数量的升序排列 12345678mysql&gt; SELECT vend_id,COUNT(*) AS prod_num FROM products WHERE prod_price &gt;=10 GROUP BY vend_id HAVING prod_num &gt;=2 ORDER BY prod_num;+---------+----------+| vend_id | prod_num |+---------+----------+| 1005 | 2 || 1003 | 4 |+---------+----------+2 rows in set (0.00 sec) WHERE GROUP BY HAVING ORDER BY 各自的作用WHERE 用于行过滤 GROUP BY 用于分组说明 HAVING 用于分组过滤 ORDER BY 用于输出排序 子查询首先子查询是MySQL4.1引入的特性。 子查询可以组合使用 子查询的效率不高，尽量少用 下面列举2个例子 1.列出订购物品TNT2的所有客户信息 12345678910mysql&gt; SELECT cust_name,cust_contact FROM customers WHERE cust_id IN (SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = &apos;TNT2&apos;)) -&gt; ;+----------------+--------------+| cust_name | cust_contact |+----------------+--------------+| Coyote Inc. | Y Lee || Yosemite Place | Y Sam |+----------------+--------------+2 rows in set (0.00 sec) 2.获取customers表中每个顾客的订单总数 1234567891011mysql&gt; SELECT cust_name,cust_state,(SELECT COUNT(*) FROM orders WHERE customers.cust_id = orders.cust_id) AS orders FROM customers ORDER BY cust_name;+----------------+------------+--------+| cust_name | cust_state | orders |+----------------+------------+--------+| Coyote Inc. | MI | 2 || E Fudd | IL | 1 || Mouse House | OH | 0 || Wascals | IN | 1 || Yosemite Place | AZ | 1 |+----------------+------------+--------+5 rows in set (0.00 sec) 使用子查询的诀窍是分步骤循序渐进的运行（编写）sql 联结表联结表就是将一些关系表联结起来，获取数据。 关系表关系表简单说就是2张表之间存在关联性。它具有以下优点 1.因为每张表都是根据其特性建立的，所以它不允许出现重复的字段。复用性强 2.可以细粒度的利用字段进行查询过滤 3.操作简单，一次操作多次引用 联结案例： 1234567891011121314151617181920mysql&gt; SELECT vend_name,prod_name,prod_price FROM vendors,products WHERE vendors.vend_id = products.vend_id ORDER BY vend_name,prod_name;+-------------+----------------+------------+| vend_name | prod_name | prod_price |+-------------+----------------+------------+| ACME | Bird seed | 10.00 || ACME | Carrots | 2.50 || ACME | Detonator | 13.00 || ACME | Safe | 50.00 || ACME | Sling | 4.49 || ACME | TNT (1 stick) | 2.50 || ACME | TNT (5 sticks) | 10.00 || Anvils R Us | .5 ton anvil | 5.99 || Anvils R Us | 1 ton anvil | 9.99 || Anvils R Us | 2 ton anvil | 14.99 || Jet Set | JetPack 1000 | 35.00 || Jet Set | JetPack 2000 | 55.00 || LT Supplies | Fuses | 3.42 || LT Supplies | Oil can | 8.99 |+-------------+----------------+------------+14 rows in set (0.00 sec) 内联结笛卡尔集123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990mysql&gt; SELECT vend_name,prod_name,prod_price FROM vendors,products ORDER BY vend_name,prod_name;+----------------+----------------+------------+| vend_name | prod_name | prod_price |+----------------+----------------+------------+| ACME | .5 ton anvil | 5.99 || ACME | 1 ton anvil | 9.99 || ACME | 2 ton anvil | 14.99 || ACME | Bird seed | 10.00 || ACME | Carrots | 2.50 || ACME | Detonator | 13.00 || ACME | Fuses | 3.42 || ACME | JetPack 1000 | 35.00 || ACME | JetPack 2000 | 55.00 || ACME | Oil can | 8.99 || ACME | Safe | 50.00 || ACME | Sling | 4.49 || ACME | TNT (1 stick) | 2.50 || ACME | TNT (5 sticks) | 10.00 || Anvils R Us | .5 ton anvil | 5.99 || Anvils R Us | 1 ton anvil | 9.99 || Anvils R Us | 2 ton anvil | 14.99 || Anvils R Us | Bird seed | 10.00 || Anvils R Us | Carrots | 2.50 || Anvils R Us | Detonator | 13.00 || Anvils R Us | Fuses | 3.42 || Anvils R Us | JetPack 1000 | 35.00 || Anvils R Us | JetPack 2000 | 55.00 || Anvils R Us | Oil can | 8.99 || Anvils R Us | Safe | 50.00 || Anvils R Us | Sling | 4.49 || Anvils R Us | TNT (1 stick) | 2.50 || Anvils R Us | TNT (5 sticks) | 10.00 || Furball Inc. | .5 ton anvil | 5.99 || Furball Inc. | 1 ton anvil | 9.99 || Furball Inc. | 2 ton anvil | 14.99 || Furball Inc. | Bird seed | 10.00 || Furball Inc. | Carrots | 2.50 || Furball Inc. | Detonator | 13.00 || Furball Inc. | Fuses | 3.42 || Furball Inc. | JetPack 1000 | 35.00 || Furball Inc. | JetPack 2000 | 55.00 || Furball Inc. | Oil can | 8.99 || Furball Inc. | Safe | 50.00 || Furball Inc. | Sling | 4.49 || Furball Inc. | TNT (1 stick) | 2.50 || Furball Inc. | TNT (5 sticks) | 10.00 || Jet Set | .5 ton anvil | 5.99 || Jet Set | 1 ton anvil | 9.99 || Jet Set | 2 ton anvil | 14.99 || Jet Set | Bird seed | 10.00 || Jet Set | Carrots | 2.50 || Jet Set | Detonator | 13.00 || Jet Set | Fuses | 3.42 || Jet Set | JetPack 1000 | 35.00 || Jet Set | JetPack 2000 | 55.00 || Jet Set | Oil can | 8.99 || Jet Set | Safe | 50.00 || Jet Set | Sling | 4.49 || Jet Set | TNT (1 stick) | 2.50 || Jet Set | TNT (5 sticks) | 10.00 || Jouets Et Ours | .5 ton anvil | 5.99 || Jouets Et Ours | 1 ton anvil | 9.99 || Jouets Et Ours | 2 ton anvil | 14.99 || Jouets Et Ours | Bird seed | 10.00 || Jouets Et Ours | Carrots | 2.50 || Jouets Et Ours | Detonator | 13.00 || Jouets Et Ours | Fuses | 3.42 || Jouets Et Ours | JetPack 1000 | 35.00 || Jouets Et Ours | JetPack 2000 | 55.00 || Jouets Et Ours | Oil can | 8.99 || Jouets Et Ours | Safe | 50.00 || Jouets Et Ours | Sling | 4.49 || Jouets Et Ours | TNT (1 stick) | 2.50 || Jouets Et Ours | TNT (5 sticks) | 10.00 || LT Supplies | .5 ton anvil | 5.99 || LT Supplies | 1 ton anvil | 9.99 || LT Supplies | 2 ton anvil | 14.99 || LT Supplies | Bird seed | 10.00 || LT Supplies | Carrots | 2.50 || LT Supplies | Detonator | 13.00 || LT Supplies | Fuses | 3.42 || LT Supplies | JetPack 1000 | 35.00 || LT Supplies | JetPack 2000 | 55.00 || LT Supplies | Oil can | 8.99 || LT Supplies | Safe | 50.00 || LT Supplies | Sling | 4.49 || LT Supplies | TNT (1 stick) | 2.50 || LT Supplies | TNT (5 sticks) | 10.00 |+----------------+----------------+------------+84 rows in set (0.00 sec) inner join(ANSI SQL语法)1234567891011121314151617181920mysql&gt; SELECT vend_name,prod_name,prod_price FROM vendors INNER JOIN products ON vendors.vend_id = products.vend_id;+-------------+----------------+------------+| vend_name | prod_name | prod_price |+-------------+----------------+------------+| Anvils R Us | .5 ton anvil | 5.99 || Anvils R Us | 1 ton anvil | 9.99 || Anvils R Us | 2 ton anvil | 14.99 || LT Supplies | Fuses | 3.42 || LT Supplies | Oil can | 8.99 || ACME | Detonator | 13.00 || ACME | Bird seed | 10.00 || ACME | Carrots | 2.50 || ACME | Safe | 50.00 || ACME | Sling | 4.49 || ACME | TNT (1 stick) | 2.50 || ACME | TNT (5 sticks) | 10.00 || Jet Set | JetPack 1000 | 35.00 || Jet Set | JetPack 2000 | 55.00 |+-------------+----------------+------------+14 rows in set (0.00 sec) 当两个表中vend_id都同时存在并对应的数据 性能问题联结会影响数据库性能，所以使用联结时要尽量避免出现不必要的表联结。 高级联结不同类型的联结自联结单个表使用别名被联结后获取数据的情况属于自联结 12345678910111213mysql&gt; SELECT p1.prod_id,p1.prod_name FROM products as p1 INNER JOIN products as p2 ON p1.vend_id = p2.vend_id WHERE p2.prod_id = &apos;DTNTR&apos; ORDER BY p1.prod_name;+---------+----------------+| prod_id | prod_name |+---------+----------------+| FB | Bird seed || FC | Carrots || DTNTR | Detonator || SAFE | Safe || SLING | Sling || TNT1 | TNT (1 stick) || TNT2 | TNT (5 sticks) |+---------+----------------+7 rows in set (0.00 sec) 自联结的好处是，它可以替代子查询完成相同的操作。并且比子查询性能要高 自然联结明确联结后检索的列，并且不重复的的情况属于自然联结 之前的大多数联结案例都属于自然联结 外部联结外部联结分为做联结和右联结 使用联结的注意事项1.联结的时候，联结类型要考虑清楚 2.联结条件很重要，所以也需要深思。不提供条件的话会出现笛卡尔集 组合查询组合查询就是将多条sql查询组合后使用。前提是这两条sql语句检索的列必须一致。 创建组合查询1234567891011121314mysql&gt; SELECT vend_id,prod_id,prod_price FROM products WHERE prod_price &lt;=5 UNION SELECT vend_id,prod_id,prod_price FROM products WHERE vend_id IN (1001,1002);+---------+---------+------------+| vend_id | prod_id | prod_price |+---------+---------+------------+| 1003 | FC | 2.50 || 1002 | FU1 | 3.42 || 1003 | SLING | 4.49 || 1003 | TNT1 | 2.50 || 1001 | ANV01 | 5.99 || 1001 | ANV02 | 9.99 || 1001 | ANV03 | 14.99 || 1002 | OL1 | 8.99 |+---------+---------+------------+8 rows in set (0.00 sec) 组合查询使用注意事项 组合查询中SELECT最少为2条 组合查询中每条查询语句中检索的列必须相同，顺序可以不一样。数据类型是数据库支持的类型 组合查询ORDER by要用在最后. 组合查询会自动过滤重复的数据。如果不想被过滤可以使用 union all 如下面的例子 123456789101112131415mysql&gt; SELECT vend_id,prod_id,prod_price FROM products WHERE prod_price &lt;=5 UNION ALL SELECT vend_id,prod_id,prod_price FROM products WHERE vend_id IN (1001,1002);+---------+---------+------------+| vend_id | prod_id | prod_price |+---------+---------+------------+| 1003 | FC | 2.50 || 1002 | FU1 | 3.42 || 1003 | SLING | 4.49 || 1003 | TNT1 | 2.50 || 1001 | ANV01 | 5.99 || 1001 | ANV02 | 9.99 || 1001 | ANV03 | 14.99 || 1002 | FU1 | 3.42 || 1002 | OL1 | 8.99 |+---------+---------+------------+9 rows in set (0.00 sec) 全文本搜索由于本章内容myISAM 引擎不支持中文所以不做笔记介绍 插入数据插入完整一行12mysql&gt; INSERT INTO customers VALUES(null,&apos;Pep E. LaPew&apos;,&apos;100 Main Street&apos;,&apos;Los Angeles&apos;,&apos;CA&apos;,&apos;90046&apos;,&apos;USA&apos;,null,null);Query OK, 1 row affected (0.04 sec) 提高性能降低insert的优先级如果数据检索是最重要的，在insert into 将加入 low_priority可降低insert语句的优先级。这样别的用户的查询语句就有可能被优先执行。 1insert low_priority into 插入多个行123mysql&gt; INSERT INTO customers(cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country) values(&apos;Pep e. LaPew&apos;,&apos;100 Main Street&apos;,&apos;Los Angeles&apos;,&apos;CA&apos;,&apos;90046&apos;,&apos;USA&apos;),(&apos;M.martian&apos;,&apos;42 Galaxy Way&apos;,&apos;New York&apos;,&apos;Ny&apos;,&apos;11213&apos;,&apos;USA&apos;);Query OK, 2 rows affected (0.06 sec)Records: 2 Duplicates: 0 Warnings: 0 插入检索后的行1234567891011121314151617INSERT INTO customers( cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_country)select cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city,cust_country from custnew; 插入时的注意事项 插入数据时应该明确指定要插入的列 更新和删除数据更新数据123mysql&gt; UPDATE customers SET cust_email = &apos;elmer@fudd.com&apos; WHERE cust_id = 10005;Query OK, 1 row affected (0.09 sec)Rows matched: 1 Changed: 1 Warnings: 0 IGNORE如果update更新多行，并且更新中如果一行或多行出现错误时，会取消整个update操作。使用ignore可以忽略错误行完成修改更新。(谨慎使用，个人认为它打破了sql执行时数据的一致性) 删除数据12mysql&gt; DELETE FROM customers Where cust_id = 10006;Query OK, 1 row affected (0.06 sec) 删除表内所有数据12mysql&gt; truncate table custnew1;Query OK, 0 rows affected (0.24 sec) update 和 delete使用注意事项 更新或删除数据时要考虑where条件，除非操作是针对全表内容的 更新或删除的where条件，操作前要在SELECT 中查询并确认]]></content>
  </entry>
  <entry>
    <title><![CDATA[quartz-初始]]></title>
    <url>%2FMeBlog%2F2019%2F09%2F10%2Fquartz%2F</url>
    <content type="text"><![CDATA[quartz 简介maven坐标quartz 快速入门12345678910111213141516171819StdSchedulerFactory stdSchedulerFactory = new StdSchedulerFactory();//创建StdSchedulerFactory工厂Scheduler scheduler = stdSchedulerFactory.getScheduler();scheduler.start();JobDetail job = newJob(HelloJob.class) .withIdentity("myJob","group1") .build();Trigger trigger = newTrigger() .withIdentity("myTrigger","group1") .startNow() //调度触发执行内容和时间的操作 .withSchedule(simpleSchedule() .withIntervalInSeconds(4) .repeatForever()) .build();scheduler.scheduleJob(job,trigger);while (true)&#123;&#125;//测试用，防止主线程结束 Quartz 常用接口Scheduler (与调度程序交)生命周期开始：SchedulerFactory 创建后开始 结束：Scheduler调用shutdown结束 Job (调度的内容实现定义)JobDetail (作业实例)Trigger （触发器）公共属性所有类型的trigger都有TriggerKey这个属性，表示trigger的身份；除此之外，trigger还有很多其它的公共属性。这些属性，在构建trigger的时候可以通过TriggerBuilder设置。 trigger的公共属性有： jobKey属性：当trigger触发时被执行的job的身份； startTime属性：设置trigger第一次触发的时间；该属性的值是java.util.Date类型，表示某个指定的时间点；有些类型的trigger，会在设置的startTime时立即触发，有些类型的trigger，表示其触发是在startTime之后开始生效。比如，现在是1月份，你设置了一个trigger–“在每个月的第5天执行”，然后你将startTime属性设置为4月1号，则该trigger第一次触发会是在几个月以后了(即4月5号)。 endTime属性：表示trigger失效的时间点。比如，”每月第5天执行”的trigger，如果其endTime是7月1号，则其最后一次执行时间是6月5号。 优先级（priority）如果你的trigger很多(或者Quartz线程池的工作线程太少)，Quartz可能没有足够的资源同时触发所有的trigger；这种情况下，你可能希望控制哪些trigger优先使用Quartz的工作线程，要达到该目的，可以在trigger上设置priority属性。比如，你有N个trigger需要同时触发，但只有Z个工作线程，优先级最高的Z个trigger会被首先触发。如果没有为trigger设置优先级，trigger使用默认优先级，值为5；priority属性的值可以是任意整数，正数、负数都可以。 注意：只有同时触发的trigger之间才会比较优先级。10:59触发的trigger总是在11:00触发的trigger之前执行。 注意：如果trigger是可恢复的，在恢复后再调度时，优先级与原trigger是一样的。 错过触发描述（misfire instructions）trigger还有一个重要的属性misfire；如果scheduler关闭了，或者Quartz线程池中没有可用的线程来执行job，此时持久性的trigger就会错过(miss)其触发时间，即错过触发(misfire)。不同类型的trigger，有不同的misfire机制。它们默认都使用“智能机制(smart policy)”，即根据trigger的类型和配置动态调整行为。当scheduler启动的时候，查询所有错过触发(misfire)的持久性trigger。然后根据它们各自的misfire机制更新trigger的信息。当你在项目中使用Quartz时，你应该对各种类型的trigger的misfire机制都比较熟悉，这些misfire机制在JavaDoc中有说明 Simple TriggerJobBuilder (用于构建JobDetail)TriggerBuilder (用于构建Trigger)Scheduler Job Trigger 三者的调用关系Scheduler 调度计划，如果想要执行调度，需要将Job和Trigger放入scheduler实例化后，可以启动(start)、暂停(stand-by)、停止(shutdown)注意：scheduler被停止后，除非重新实例化，否则不能重新启动；只有当scheduler启动后，即使处于暂停状态也不行，trigger才会被触发 Job 用来定义工作内容 Trigger用来定义调度的触发时间，以及绑定工作组 JobDataMap的使用1.Job类123456789101112131415161718public class DumbJob implements Job &#123; public DumbJob() &#123; &#125; public void execute(JobExecutionContext context) throws JobExecutionException &#123; JobKey key = context.getJobDetail().getKey(); JobDataMap dataMap = context.getJobDetail().getJobDataMap(); String jobSays = dataMap.getString("jobSays"); float myFloatValue = dataMap.getFloat("myFloatValue"); System.err.println("Instance " + key + " of DumbJob says: " + jobSays + ", and val is: " + myFloatValue); &#125; &#125; 2.调度定义时123456// define the job and tie it to our DumbJob classJobDetail job = newJob(DumbJob.class) .withIdentity("myJob", "group1") // name "myJob", group "group1" .usingJobData("jobSays", "Hello World!") .usingJobData("myFloatValue", 3.141f) .build(); 自动填充jobDataMap参数只需要修改Job类，在类中添加map相对应的字段提供set方法即可。如下 1234567891011121314151617181920212223242526272829303132333435public class DumbJob implements Job &#123; String jobSays; float myFloatValue; ArrayList state; public DumbJob() &#123; &#125; public void execute(JobExecutionContext context) throws JobExecutionException &#123; JobKey key = context.getJobDetail().getKey(); JobDataMap dataMap = context.getMergedJobDataMap(); // Note the difference from the previous example state.add(new Date()); System.err.println("Instance " + key + " of DumbJob says: " + jobSays + ", and val is: " + myFloatValue); &#125; public void setJobSays(String jobSays) &#123; this.jobSays = jobSays; &#125; public void setMyFloatValue(float myFloatValue) &#123; myFloatValue = myFloatValue; &#125; public void setState(ArrayList state) &#123; state = state; &#125; &#125; @PersistJobDataAfterExecution由于Job类的创建是由Scheduler上的JobFactory 运行时动态创建的，所以个人猜测框架创作人使用了动态代理的技术。所以Job的成员变量与外界的交互就成为了难题。如何实现呢？答案就是在实现Job的类上加入@PersistJobDataAfterExecution注解，这样JobDataMap中的数据就可以与外界交互了。 @DisallowConcurrentExecution个人目前还没有使用过，w3cschool的官方文档上是这样介绍的： 1@DisallowConcurrentExecution：将该注解加到job类上，告诉Quartz不要并发地执行同一个job定义（这里指特定的job类）的多个实例]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux-系统结构]]></title>
    <url>%2FMeBlog%2F2019%2F08%2F27%2Flinux%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[简单的说Linux系统可分为 Linux内核 + 应用程序 对于Linux系统的细致划分，可以分为 Linux 内核 系统调用 库函数 shell 应用程序 内核模式与系统调用内核模式计算机的硬件资源又系统内核来操控，应用程序要想调用系统硬件资源需要通过访问或调用内核接口来实现指定的功能。这时系统的内核就是操控硬件的基础操作。我们把内核程序的活动称为内核模式，应用程序的活动称为用户模式。 系统调用应用程序通过内核接口调用内核程序的过程称为系统调用。 Linux中的系统调用接口大约有200多种，我们可以通过shell查看Linux下的所有系统调用 1man 2 syscalls man 中的参数2表示系统调用，不理解的可通过 man man 查看系统帮助文档. 系统调用常见的有 read 文件读取 write 文件写入 fork 复制当前进程 wait 等待某个进程完成 chdir 改变工作目录 通过系统调用，Linux用户可以体验到内核封装的好处。使得我们不必关系硬件驱动使用的一些底层细节。我更专注与程序的功能和要实现的目的。 库函数库函数是什么，个人认为库函数就是系统调用的更上一层的封装。将系统调用的一些指令结合起来写成函数的形式，以方便调用。就像是C语言中的C标准库一样，有了他们程序开发起来更便捷。 除了C标准库，Linux还有一些其他的库比如 POSIX等 shellshell 是一个交互程序，他是为了普通用户通过shell在不需要自己编程的情况下使用系统的一些资源。 用户程序用户程序是基于编程语言开发后的程序，它也是通过其语言调用系统内核功能来使用系统的一些硬件资源。和库函数不同的是1它是面向用户的，2它针对的功能更专一，使用更方便。 早期由于Linux程序中大部分用户程序是用C编写的，然而Linux系统内核也是由C编写的。所以我觉得我们有必要了解下C中的函数调用与进程空间]]></content>
  </entry>
  <entry>
    <title><![CDATA[vim篇]]></title>
    <url>%2FMeBlog%2F2019%2F08%2F26%2Fvim%E7%AF%87%2F</url>
    <content type="text"><![CDATA[vim文本编辑器vim常用操作​ vim是荷兰一位名叫 Bram Moolenaar 的工程师开发并分享的开源编辑器插件 vim区域复制，进入Ctrl+V 选择要复制的区域后 按y复制 p粘贴 vim使用技巧 上面连续行注释中 /表示隔离符 \表示转移符 个人用户下编辑添加 .vimrc 文件可以保存一些关于vim的配置和快捷键的使用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ssh协议]]></title>
    <url>%2FMeBlog%2F2019%2F08%2F23%2Fssh%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[Http headersif-modified-since首先他是一个条件式头部信息 个人认为它用来标识修改的时间，时间指的是上次响应头中的last-modified的时间 if-match首先它是一个条件式头部信息 GET方式的请求中使用它后，服务器会验证ETag是否匹配，如果不匹配则不返回数据 PUT等不安全的方法判断同上，不同之处在于不能上传数据或修改数据 它们比较的算法默认为强比较算法，也就是对比每一个比特位，都相同时认为文件或信息是相同的。如果在ETag前加入“w/”那么比较的算法就会由强比较改为相对宽松的算法]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux-权限整合篇]]></title>
    <url>%2FMeBlog%2F2019%2F08%2F05%2FLinux-%E6%9D%83%E9%99%90%E6%95%B4%E5%90%88%E7%AF%87%2F</url>
    <content type="text"><![CDATA[基本权限管理chmod基本权限管理使用 chmod 命令 如给一个文件设置属主，所属组，其他的权限如下所示1234spiderbao@spiderbao-CW65S:~/桌面$ touch test.txtspiderbao@spiderbao-CW65S:~/桌面$ chmod 774 test.txt spiderbao@spiderbao-CW65S:~/桌面$ ll test.txt -rwxrwxr-- 1 spiderbao spiderbao 0 8月 5 16:29 test.txt* 给文件夹赋予权限同上所示，上面使用数字的方式给权限赋值，4表示读 ，2表示修改，1表示执行 chownchown 命令可以修改文件的所有者以及所属组 案例： 123456#修改文件的所属组spiderbao@spiderbao-CW65S:~/桌面$ ll test.txt -rwxrwxr-- 1 spiderbao spiderbao 0 8月 5 16:29 test.txt*spiderbao@spiderbao-CW65S:~/桌面$ sudo chown spiderbao.ftp test.txt spiderbao@spiderbao-CW65S:~/桌面$ ll test.txt -rwxrwxr-- 1 spiderbao ftp 0 8月 5 16:29 test.txt* umask默认权限管理查看系统默认umask12345spiderbao@spiderbao-CW65S:~/桌面$ umask -Su=rwx,g=rx,o=rxspiderbao@spiderbao-CW65S:~/桌面$ umask 0022 解析 umaks 0022 代表什么 其中 第一位 特殊权限位，如果是1表示文件具有SBIT权限，2表示具有SetGID权限，4表示具有SetUID权限，0表示站位符 第二位 所属主位，4 （read），2 （write），1（execute） 第三位 所属组位，4 （read），2 （write），1（execute） 第四位 其他位，4 （read），2 （write），1（execute） 默认权限算法 文件夹的默认最大权限 777文件的最大默认权限 666 文件的默认值是根据 文件的最大权限值与umask设置的值进行或得出的。 666 表示 rw-rw-rw- 022 表示 —-w–w- 进行或运算后得 rw r r 所以这个就是系统中创建文件后的默认权限值 ACL 权限管理ACL 的全称是 Access Control List (访问控制列表) 它可以针对文件设置除基本权限外的 r w x的权限 举例，现在有一个文件test 是开发小组1共同需要操作所以小组 test拥有 rw的权限，同时文件的创建者拥有rw权限，其他人无权查看test文件的内容，有一天来了以为实习生，由于他刚来不久所以需要拥有test的r权限但是不能拥有w权限这时改基本权限又不太现实。那现在怎么办呢？看看接下来我用ACL权限是如何解决的吧 SetUID、SetGID、SBIT 权限管理chatter 权限sudo 权限]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu add-apt-repository]]></title>
    <url>%2FMeBlog%2F2019%2F07%2F03%2FUbuntu-add-apt-repository%2F</url>
    <content type="text"><![CDATA[简介：来自于Ubuntu自带文档上的介绍：12345678910111213141516171819202122add-apt-repository is a script which adds an external APT repository to either /etc/apt/sources.list or a file in /etc/apt/sources.list.d/ or removes an already existing repository. The options supported by add-apt-repository are: -h, --help Show help message and exit -m, --massive-debug Print a lot of debug information to the command line -r, --remove Remove the specified repository -y, --yes Assume yes to all queries -u, --update After adding the repository, update the package cache with packages from this repository (avoids need to apt-get update) -k, --keyserver Use a custom keyserver URL instead of the default -s, --enable-source Allow downloading of the source packages from the repository 来自百度百科的介绍：12add-apt-repository的提供方python-software-properties ，平台是Ubuntu Karmic (9.10)。在 Ubuntu Karmic (9.10) 我们可以使用 &quot;add-apt-repository&quot; 脚本添加 ppa 到当前的库中并且自动导入公钥.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux-wget]]></title>
    <url>%2FMeBlog%2F2019%2F07%2F03%2Fwget%2F</url>
    <content type="text"><![CDATA[简介： 来自 https://www.jianshu.com/p/2e2ba8ecc22a 用户的摘录： 123456wget是linux上的命令行的下载工具。这是一个GPL许可证下的自由软件。wget支持HTTP和FTP协议，支持代理服务器和断点续传功能，能够自动递归远程主机的目录，找到合乎条件的文件并将其下载到本地硬盘上；如果必要，wget将恰当地转换页面中的超级连接以在本地生成可浏览的镜像。由于没有交互式界面，wget可在后台运行，截获并忽略HANGUP信号，因此在用户推出登录以后，仍可继续运行。通常，wget用于成批量地下载Internet网站上的文件，或制作远程网站的镜像。作者：JeffYU链接：https://www.jianshu.com/p/2e2ba8ecc22a来源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。]]></content>
  </entry>
  <entry>
    <title><![CDATA[webgl中文网学习笔记]]></title>
    <url>%2FMeBlog%2F2019%2F07%2F03%2Fwebgl%E4%B8%AD%E6%96%87%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[chapter1：what is Three.js?什么是threejs，很简单，你将它理解成three + js就可以了。three表示3D的意思，js表示javascript的意思。那么合起来，three.js就是使用javascript 来写3D程序的意思。 Javascript是运行在网页端的脚本语言，那么毫无疑问Three.js也是运行在浏览器上的。 看到这里，也许你就开始有很多疑问了，那么让我来猜猜你的疑问吧。 1、javascript能写高效率的3D程序吗？ 能。技术在进步，几年前也许这是不行，写3D程序，最好是用c++，这样才能保证效率，但是现在，世界改变了。javascript的计算能力因为google的V8引 擎得到了迅猛的增强，做3D程序，做服务器都没有问题。如果你对服务器感兴趣，你可以看看nodejs，当然，不是现在。现在，你最好保持热情，将Three.js学精深，在以后的工作学习中做出 更大的成绩。 Three.js where come from?它源自github的一个开源项目. 先去下载代码，它的地址是： https://github.com/mrdoob/three.js。 如图所示 analysis of source directory structur? 要了解事物的真相，就要解析到它的深处去，我们来看看Three.js的源目录结果。用解压软件解开刚才的源码包，各个目录如下所示： Build目录：包含两个文件，three.js 和three.min.js 。这是three.js最终被引用的文件。一个已经压缩，一个没有压缩的js文件。 Docs目录：这里是three.js的帮助文档，里面是各个函数的api，可惜并没有详细的解释。试图用这些文档来学会three.js是不可能的。 Editor目录：一个类似3D-max的简单编辑程序，它能创建一些三维物体。 Examples目录：一些很有趣的例子demo，可惜没有文档介绍。对图像学理解不深入的同学，学习成本非常高。 Src目录：源代码目录，里面是所有源代码。 Test目录：一些测试代码，基本没用。 Utils目录：存放一些脚本，python文件的工具目录。例如将3D-Max格式的模型转换为three.js特有的json模型。 .gitignore文件：git工具的过滤规则文件，没有用。 CONTRIBUTING.md文件：一个怎么报bug，怎么获得帮助的说明文档。 LICENSE文件：版权信息。 README.md文件：介绍three.js的一个文件，里面还包含了各个版本的更新内容列表。 examples one1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt;canvas &#123; width: 100%; height: 100% &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src="js/three.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在chrome浏览器中 开发者工具中的console中输入 THREE.REVISION 控制台上会输出相应的版本信息。 chapter2：three component在Three.js中，要渲染物体到网页中，我们需要3个组建：场景（scene）、相机（camera）和渲染器（renderer）。有了这三样东西，才能将物体渲染到网页中去。 记住关建语句：有了这三样东西，我们才能够使用相机将场景渲染到网页上去。 创建这三要素的代码如下： 12345var scene = new THREE.Scene(); // 场景var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);// 透视相机var renderer = new THREE.WebGLRenderer(); // 渲染器renderer.setSize(window.innerWidth, window.innerHeight); // 设置渲染器的大小为窗口的内宽度，也就是内容区的宽度document.body.appendChild(renderer.domElement); 在Threejs中场景就只有一种，用THREE.Scene来表示，要构件一个场景也很简单，只要new一个对象就可以了，代码如下： var scene = new THREE.Scene(); 场景是所有物体的容器，如果要显示一个苹果，就需要将苹果对象加入场景中。 camera另一个组建是相机，相机决定了场景中那个角度的景色会显示出来。相机就像人的眼睛一样，人站在不同位置，抬头或者低头都能够看到不同的景色。 场景只有一种，但是相机却又很多种。和现实中一样，不同的相机确定了呈相的各个方面。比如有的相机适合人像，有的相机适合风景，专业的摄影师根据实际用途不一样，选择不同的相机。对程序员来说，只要设置不同的相机参数，就能够让相机产生不一样的效果。 在Threejs中有多种相机，这里介绍两种，它们是： 透视相机（THREE.PerspectiveCamera）、这里我们使用一个透视相机，透视相机的参数很多，这里先不详细讲解。后面关于相机的那一章，我们会花大力气来讲。定义一个相机的代码如下所示：（已经迫不及待想看看相机的参数了，点这里） 1var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000); renderer最后一步就是设置渲染器，渲染器决定了渲染的结果应该画在页面的什么元素上面，并且以怎样的方式来绘制。这里我们定义了一个WebRenderer渲染器，代码如下所示： 123var renderer = new THREE.WebGLRenderer();renderer.setSize(window.innerWidth, window.innerHeight);document.body.appendChild(renderer.domElement); 注意，渲染器renderer的domElement元素，表示渲染器中的画布，所有的渲染都是画在domElement上的，所以这里的appendChild表示将这个domElement挂接在body下面，这样渲染的结果就能够在页面中显示了。 scene add object那现在，我们将一个物体添加到场景中： 1234var geometry = new THREE.CubeGeometry(1,1,1); var material = new THREE.MeshBasicMaterial(&#123;color: 0x00ff00&#125;);var cube = new THREE.Mesh(geometry, material); scene.add(cube); 代码中出现了THREE.CubeGeometry，THREE.CubeGeometry是什么东东，他是一个几何体，几何体由什么组成，已经不是本课的主要内容了，后面的课程我们会详细的学到。不过这里你只需要知道CubeGeometry是一个正方体或者长方体，究竟是什么，由它的3个参数所决定，cubeGeometry的原型如下代码所示： 1CubeGeometry(width, height, depth, segmentsWidth, segmentsHeight, segmentsDepth, materials, sides); width：立方体x轴的长度 height：立方体y轴的长度 depth：立方体z轴的深度，也就是长度 想一想大家就明白，以上3个参数就能够确定一个立方体。 剩下的几个参数就要费解和复杂一些了，不过后面我们会自己来写一个立方体，到时候，你会更明白这些参数的意义，这里你可以将这些参数省略。 render终于到了最后一步，这一步做完后，就可以该干嘛干嘛去了。 渲染应该使用渲染器，结合相机和场景来得到结果画面。实现这个功能的函数是 renderer.render(scene, camera); 渲染函数的原型如下： render( scene, camera, renderTarget, forceClear ) 各个参数的意义是： scene：前面定义的场景 camera：前面定义的相机 renderTarget：渲染的目标，默认是渲染到前面定义的render变量中 forceClear：每次绘制之前都将画布的内容给清除，即使自动清除标志autoClear为false，也会清除。 loop render渲染有两种方式：实时渲染和离线渲染 。 先看看离线渲染，想想《西游降魔篇》中最后的佛主，他肯定不是真的，是电脑渲染出来的，其画面质量是很高的，它是事先渲染好一帧一帧的图片，然后再把图片拼接成电影的。这就是离线渲染。如果不事先处理好一帧一帧的图片，那么电影播放得会很卡。CPU和GPU根本没有能力在播放的时候渲染出这种高质量的图片。 实时渲染：就是需要不停的对画面进行渲染，即使画面中什么也没有改变，也需要重新渲染。下面就是一个渲染循环： 123456function render() &#123; cube.rotation.x += 0.1; cube.rotation.y += 0.1; renderer.render(scene, camera); requestAnimationFrame(render);&#125; 其中一个重要的函数是requestAnimationFrame，这个函数就是让浏览器去执行一次参数中的函数，这样通过上面render中调用requestAnimationFrame()函数，requestAnimationFrame()函数又让rander()再执行一次，就形成了我们通常所说的游戏循环了。 the relationship between scene 、 camera 、renderThree.js中的场景是一个物体的容器，开发者可以将需要的角色放入场景中，例如苹果，葡萄。同时，角色自身也管理着其在场景中的位置。 相机的作用就是面对场景，在场景中取一个合适的景，把它拍下来。 渲染器的作用就是将相机拍摄下来的图片，放到浏览器中去显示。他们三者的关系如下图所示： chapter3.1composition of the 3d World在计算机世界里，3D世界是由点组成，两个点能够组成一条直线，三个不在一条直线上的点就能够组成一个三角形面，无数三角形面就能够组成各种形状的物体，如下图： 我们通常把这种网格模型叫做Mesh模型。给物体贴上皮肤，或者专业点就叫做纹理，那么这个物体就活灵活现了。最后无数的物体就组成了我们的3D世界。 那么3D世界的组成，是否真的这样简单？是的，从编程的角度，目前为此，你只需要知道这些。下一节，我们从点说起。 dot在三维空间中的某一个点可以用一个坐标点来表示。一个坐标点由x,y,z三个分量构成。在three.js中，点可以在右手坐标系中表示： 空间几何中，点可以用一个向量来表示，在Three.js中也是用一个向量来表示的，代码如下所示： 1234567THREE.Vector3 = function ( x, y, z ) &#123;this.x = x || 0;this.y = y || 0;this.z = z || 0;&#125;; 我们来分析这段代码：前面我们已经知道了THREE是Three.js引擎的一个全局变量。只要你想用它，就可以在任何地方用它。有点充气娃娃的意思，不需要你同意，你想用就用吧。 那么THREE.Vector3呢，就是表示Vector3是定义在THREE下面的一个类。以后要用Vector3，就必须要加THREE前缀。当然Three.js的设计者，也可以不加THREE这个前缀，但是他们预见到，Three.js引擎中会有很多类型，最好给这些类型加一个前缀，以免与开发者的代码产生冲突。 THREE.Vector3被赋值为一个函数。这个函数有3个参数，分别代表x坐标，y坐标和z坐标的分量。函数体内的代码将他们分别赋值给成员变量x，y，z。看看上面的代码，中间使用了一个“||”（或）运算符，就是当x=null或者undefine时，this.x的值应该取0。 dot operaction在3D世界中点可以用THREE.Vector3D来表示。对应源码为/src/math/Vector3.js（注意：源码所在的位置，可能不同版本不一样，请自己搜索Vector3关键词来确定）。在您继续学习之前，你可以打开该文件浏览一下，推荐使用WebStorm，如果没有，你也可以用NotePad++。 现在来看看怎么定义个点，假设有一个点x=4，y=8，z=9。你可以这样定义它： 1var point1 = new THREE.Vecotr3(4,8,9); 另外你也可以使用set方法，代码如下： 12var point1 = new THREE.Vector3();point1.set(4,8,9); chapter3.2coordinate我们下面会学习使用直线画一个网格出来，为了更好的理解这个网格在空间中的位置，我们是时候，讲一讲空间坐标系了。 right handed cartesian coordinateThreejs使用的是右手坐标系，这源于opengl默认情况下，也是右手坐标系。下面是右手坐标系的图例，如果对这个概念不理解，可以百度一下，我保证你伸出手比划的那一瞬间你就明白了，如果不明白请给作者留言，我会尽快补上关于坐标系的知识。 图中右边那个手对应的坐标系，就是右手坐标系。在Threejs中，坐标和右边的坐标完全一样。x轴正方向向右，y轴正方向向上，z轴由屏幕从里向外。 line在Threejs中，一条线由点，材质和颜色组成。 点由THREE.Vector3表示，Threejs中没有提供单独画点的函数，它必须被放到一个THREE.Geometry形状中，这个结构中包含一个数组vertices，这个vertices就是存放无数的点（THREE.Vector3）的数组。 为了绘制一条直线，首先我们需要定义两个点，如下代码所示： 123var p1 = new THREE.Vector3( -100, 0, 100 );var p2 = new THREE.Vector3( 100, 0, -100 ); 请大家思考一下，这两个点在坐标系的什么位置，然后我们声明一个THREE.Geometry，并把点加进入，代码如下所示： 12345var geometry = new THREE.Geometry();geometry.vertices.push(p1);geometry.vertices.push(p2); geometry.vertices的能够使用push方法，是因为geometry.vertices是一个数组。这样geometry 中就有了2个点了。 然后我们需要给线加一种材质，可以使用专为线准备的材质，THREE.LineBasicMaterial。 最终我们通过THREE.Line绘制了一条线，如下代码所示: 1var line = new THREE.Line( geometry, material, THREE.LinePieces ); ok，line就是我们要的线条了。 chapter4loop render物体运动还有一个关键点，就是要渲染物体运动的每一个过程，让它显示给观众。渲染的时候，我们调用的是渲染器的render() 函数。代码如下： renderer.render( scene, camera ); 如果我们改变了物体的位置或者颜色之类的属性，就必须重新调用render()函数，才能够将新的场景绘制到浏览器中去。不然浏览器是不会自动刷新场景的。 如果不断的改变物体的颜色，那么就需要不断的绘制新的场景，所以我们最好的方式，是让画面执行一个循环，不断的调用render来重绘，这个循环就是渲染循环，在游戏中，也叫游戏循环。 为了实现循环，我们需要javascript的一个特殊函数，这个函数是requestAnimationFrame。 调用requestAnimationFrame函数，传递一个callback参数，则在下一个动画帧时，会调用callback这个函数。 于是，我们的游戏循环会这样写。 1234567function animate() &#123; render(); requestAnimationFrame( animate );&#125; 这样就会不断的执行animate这个函数。也就是不断的执行render()函数。在render()函数中不断的改变物体或者摄像机的位置，并渲染它们，就能够实现动画了。 Stats关于性能：测试一个程序，性能上是否有瓶颈，在3D世界里，经常使用帧数的概念，首先我们来定义一下帧数的意义。 帧数：图形处理器每秒钟能够刷新几次，通常用fps（Frames Per Second）来表示。如下是每秒钟59次刷新的应用： 当物体在快速运动时,当人眼所看到的影像消失后，人眼仍能继续保留其影像1/24秒左右的图像，这种现象被称为视觉暂留现象。是人眼具有的一种性质。人眼观看物体时，成像于视网膜上，并由视神经输入人脑，感觉到物体的像。一帧一帧的图像进入人脑，人脑就会将这些图像给连接起来，形成动画。 毫无疑问，帧数越高，画面的感觉就会越好。所以大多数游戏都会有超过30的FPS。为了监视FPS，看看你的程序哪里占用了很多的CPU时间，就需要学习一下性能监视器。 在Three.js中，性能由一个性能监视器来管理，它的介绍在https://github.com/mrdoob/stats.js 可以看到。性能监视器的截图如下所示: 其中FPS表示：上一秒的帧数，这个值越大越好，一般都为60左右。点击上面的图，就会变成下面的另一个视图。 MS表示渲染一帧需要的毫秒数，这个数字是越小越好。再次点击又可以回到FPS视图中。 性能监视器Stats的使用在Three.js中，性能监视器被封装在一个类中，这个类叫做Stats，下面是一段伪代码，表示Stats的使用。 123456789101112var stats = new Stats();stats.setMode(1); // 0: fps, 1: ms// 将stats的界面对应左上角stats.domElement.style.position = 'absolute';stats.domElement.style.left = '0px';stats.domElement.style.top = '0px';document.body.appendChild( stats.domElement );setInterval( function () &#123; stats.begin(); // 你的每一帧的代码 stats.end();&#125;, 1000 / 60 ); 你现在可以自己写一段代码，来验证一下，你的程序的帧数了。 Stats到底做了什么事情呢？我们来分析一下。 1、setMode函数参数为0的时候，表示显示的是FPS界面，参数为1的时候，表示显示的是MS界面。 2、stats的domElementstats的domElement表示绘制的目的地（DOM），波形图就绘制在这上面。 3、stats的begin函数begin，在你要测试的代码前面调用begin函数，在你代码执行完后调用end()函数，这样就能够统计出这段代码执行的平均帧数了。 封装后的使用 12345678910function initStats() &#123; //监视器 stats = new Stats(); stats.domElement.style.position = 'absolute'; stats.domElement.style.left = '0px'; stats.domElement.style.top = '0px'; document.getElementById('canvas-frame').appendChild(stats.domElement);&#125;在需要监视的代码块中使用方法 stats.update();即可 Tween engine上面介绍了通过移动相机和移动物体来产生动画的效果。使用的方法是在渲染循环里去移动相机或者物体的位置。如果动画稍微复杂一些，这种方式实现起来就比较麻烦一些了。 为了使程序编写更容易一些，我们可以使用动画引擎来实现动画效果。和three.js紧密结合的动画引擎是Tween.js,你可以再https://github.com/sole下载。 对于快速构件动画来说，Tween.js是一个容易上手的工具 使用步骤： 1 在head中引入 &lt;-/script&gt; 2 第二步，就是构件一个Tween对象，对Tween进行初始化，本例的代码是: 123456function initTween()&#123; new TWEEN.Tween( mesh.position) .to( &#123; x: -400 &#125;, 3000 ).repeat( Infinity ).start();&#125; TWEEN.Tween的构造函数接受的是要改变属性的对象，这里传入的是mesh的位置。Tween的任何一个函数返回的都是自身，所以可以用串联的方式直接调用各个函数。 to函数，接受两个参数，第一个参数是一个集合，里面存放的键值对，键x表示mesh.position的x属性，值-400表示，动画结束的时候需要移动到的位置。第二个参数，是完成动画需要的时间，这里是3000ms。 repeat( Infinity )表示重复无穷次，也可以接受一个整形数值，例如5次。 Start表示开始动画，默认情况下是匀速的将mesh.position.x移动到-400的位置。 3 需要在渲染函数中去不断的更新Tween，这样才能够让mesh.position.x移动位置: 1234567function animation()&#123; renderer.render(scene, camera); requestAnimationFrame(animation); stats.update(); TWEEN.update();&#125; 其中的TWEEN.update()完成了让动画动起来到目标。如果不调用这个函数场景就不能动起来了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[webGlDay01]]></title>
    <url>%2FMeBlog%2F2019%2F06%2F27%2FwebGLDay01%2F</url>
    <content type="text"><![CDATA[WebGL 简介webgl是一项可以在浏览器中流畅展示3D模型和场景的一种技术。它使用JavaScript作为编程语言，调用浏览器支持的3D绘制函数，来实现3D模型和场景的展现。 为什么浏览器可以实现3D绘制因为浏览器实现了opengl es的规范，这套规范可以直接使用指令操作显卡，使显卡渲染3D世界，直接反应到浏览器中。 操作流程： JavaScript ——&gt; opengl es ——&gt; 显卡 webgl可以做什么只要涉及到3D都有webgl的用武之地。比如游戏、家居、城市地图 webgl之three.jsthree.js是什么three.js是一个封装好的webgl库，使用它可以更便捷的使用webgl.]]></content>
  </entry>
  <entry>
    <title><![CDATA[maven]]></title>
    <url>%2FMeBlog%2F2019%2F06%2F27%2Fmaven%2F</url>
    <content type="text"><![CDATA[maven介绍什么是mavenMaven 的正确发音是[ˈmevən],而不是“马瘟”以及其他什么瘟。Maven 在美国是一个口语化的词 语,代表专家、内行的意思。 maven 是一个项目管理工具,它包含了一个项目对象模型（pom:project object model）一组标准集合,一个项目生命周期（project Lifecycle）,一个依赖管理系统（dependency management system）和用来运行定义在生命周期阶段中插件目标的逻辑 maven 能做什么1.引入jar包，可控制jar包冲突问题 2.编译（java文件编译为字节码） 3.运行测试用例 4.打包 maven 的特点依赖管理根据pom中的坐标将jar包导入项目中，可以做到jar包的复用。 如将一个junit导入项目使用maven则体现为 123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 依赖传递下面从字面依赖和传递两个方面了解依赖传递的概念 依赖：项目A中引入了项目B,这时我们就可以说A依赖于B 传递：项目B中依赖了项目C由于A依赖于B,所以根据依赖的关系A也就依赖了项目C maven的依赖传递可以方便引入一些项目，但是存在一个问题就是如果一个项目同时依赖2个项目。而依赖的2个项目分别又依赖同一个项目的不同版本。这里由于版本的不同可能会引发一些兼容性问题。我们把这种情况称之为依赖传递冲突。 maven对这种冲突提供的解决方案如下： 依赖调节原则： 1、第一声明者优先原则：在 pom 文件定义依赖,先声明的依赖为准。2、路径近者优先原则:例如:A项目依赖B B依赖C C又依赖D 如果我们在A中申明依赖D的不同版本，那么A项目就会依赖D的声明版本而不是传递的D版本。 只要我们遵循原则maven会帮我们自动处理依赖 ，但我们如果不想遵循原则就不能解决冲突了吗？答案肯定是可以，毕竟maven是一款优秀的自动化构建工具 不遵循原则如何解决冲突： 1.排除依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;com.itcast.ssm&lt;/groupId&gt; &lt;artifactId&gt;ssm_service&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;XXX&lt;/groupId&gt; &lt;artifactId&gt;XXX&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 2.锁定版本12345678910 &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 3.可选依赖当坐标被赋予1&lt;optional&gt;true&lt;/optional&gt; 时此坐标不会被传递依赖。 example：1234567891011 &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 一键构建maven 规范化流程如下图 一键构建是指，如果用户需要实现上述流程中的清理，只需要使用maven自带的mvn clean命令即可完成项目的清空。 如果是实现流程中的打包，则使用命令mvn package 即可，并且它还会执行打包前的所有流程项。 maven 安装后目录解析bin:存放了 maven 的命令,比如我们前面用到的 mvn tomcat:runboot:存放了一些 maven 本身的引导程序,如类加载器等conf:存放了 maven 的一些配置文件,如 setting.xml 文件lib:存放了 maven 本身运行所需的一些 jar 包在使用maven前电脑需安装jdk或jre因为maven是用java编写的 maven 命令查看maven的帮助信息1spiderbao@spiderbao-CW65S:~$ mvn -help maven 查看版本信息1234567spiderbao@spiderbao-CW65S:~$ mvn -vApache Maven 3.6.0Maven home: xxxJava version: 1.8.0_191, vendor: Oracle Corporation, runtime: xxxjava-8-openjdk-amd64/jreDefault locale: zh_CN, platform encoding: UTF-8OS name: &quot;linux&quot;, version: &quot;4.18.0-18-generic&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot; compile 编译12345678910111213141516171819spiderbao@spiderbao-CW65S:~/idea_dev/hello_maven$ mvn complie[INFO] Scanning for projects...[INFO] [INFO] ----------------------&lt; com.itheima:hello_maven &gt;-----------------------[INFO] Building hello_maven Maven Webapp 1.0-SNAPSHOT[INFO] --------------------------------[ war ]---------------------------------[INFO] ------------------------------------------------------------------------[INFO] BUILD FAILURE[INFO] ------------------------------------------------------------------------[INFO] Total time: 0.145 s[INFO] Finished at: 2019-05-08T14:24:23+08:00[INFO] ------------------------------------------------------------------------[ERROR] Unknown lifecycle phase &quot;complie&quot;. You must specify a valid lifecycle phase or a goal in the format &lt;plugin-prefix&gt;:&lt;goal&gt; or &lt;plugin-group-id&gt;:&lt;plugin-artifact-id&gt;[:&lt;plugin-version&gt;]:&lt;goal&gt;. Available lifecycle phases are: validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy, pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy. -&gt; [Help 1][ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.[ERROR] Re-run Maven using the -X switch to enable full debug logging.[ERROR] [ERROR] For more information about the errors and possible solutions, please read the following articles:[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/LifecyclePhaseNotFoundException mvn complie 打错 改为 compile1234567891011121314151617181920spiderbao@spiderbao-CW65S:~/idea_dev/hello_maven$ mvn compile[INFO] Scanning for projects...[INFO] [INFO] ----------------------&lt; com.itheima:hello_maven &gt;-----------------------[INFO] Building hello_maven Maven Webapp 1.0-SNAPSHOT[INFO] --------------------------------[ war ]---------------------------------[INFO] [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ hello_maven ---[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.[INFO] skip non existing resourceDirectory /home/spiderbao/idea_dev/hello_maven/src/main/resources[INFO] [INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ hello_maven ---[INFO] Changes detected - recompiling the module![INFO] Compiling 1 source file to /home/spiderbao/idea_dev/hello_maven/target/classes[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 1.307 s[INFO] Finished at: 2019-05-08T14:26:40+08:00[INFO] ------------------------------------------------------------------------ test 测试1234567891011121314151617181920212223242526272829spiderbao@spiderbao-CW65S:~/idea_dev/hello_maven$ mvn test[INFO] Scanning for projects...[INFO] [INFO] ----------------------&lt; com.itheima:hello_maven &gt;-----------------------[INFO] Building hello_maven Maven Webapp 1.0-SNAPSHOT[INFO] --------------------------------[ war ]---------------------------------[INFO] [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ hello_maven ---[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.[INFO] skip non existing resourceDirectory /home/spiderbao/idea_dev/hello_maven/src/main/resources[INFO] [INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ hello_maven ---[INFO] Nothing to compile - all classes are up to date[INFO] [INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ hello_maven ---[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.[INFO] skip non existing resourceDirectory /home/spiderbao/idea_dev/hello_maven/src/test/resources[INFO] [INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ hello_maven ---[INFO] No sources to compile[INFO] [INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ hello_maven ---[INFO] No tests to run.[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 1.072 s[INFO] Finished at: 2019-05-08T14:27:10+08:00[INFO] ------------------------------------------------------------------------ 由于没有写测试用例所以No tests to run.clean 清空1234567891011121314spiderbao@spiderbao-CW65S:~/idea_dev/hello_maven$ mvn clean[INFO] Scanning for projects...[INFO] [INFO] ----------------------&lt; com.itheima:hello_maven &gt;-----------------------[INFO] Building hello_maven Maven Webapp 1.0-SNAPSHOT[INFO] --------------------------------[ war ]---------------------------------[INFO] [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ hello_maven ---[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 0.289 s[INFO] Finished at: 2019-05-08T14:23:21+08:00[INFO] ------------------------------------------------------------------------ package 打包12345678910111213141516171819202122232425262728293031323334353637spiderbao@spiderbao-CW65S:~/idea_dev/hello_maven$ mvn package[INFO] Scanning for projects...[INFO] [INFO] ----------------------&lt; com.itheima:hello_maven &gt;-----------------------[INFO] Building hello_maven Maven Webapp 1.0-SNAPSHOT[INFO] --------------------------------[ war ]---------------------------------[INFO] [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ hello_maven ---[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.[INFO] skip non existing resourceDirectory /home/spiderbao/idea_dev/hello_maven/src/main/resources[INFO] [INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ hello_maven ---[INFO] Nothing to compile - all classes are up to date[INFO] [INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ hello_maven ---[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.[INFO] skip non existing resourceDirectory /home/spiderbao/idea_dev/hello_maven/src/test/resources[INFO] [INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ hello_maven ---[INFO] No sources to compile[INFO] [INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ hello_maven ---[INFO] No tests to run.[INFO] [INFO] --- maven-war-plugin:2.2:war (default-war) @ hello_maven ---[INFO] Packaging webapp[INFO] Assembling webapp [hello_maven] in [/home/spiderbao/idea_dev/hello_maven/target/hello_maven][INFO] Processing war project[INFO] Copying webapp resources [/home/spiderbao/idea_dev/hello_maven/src/main/webapp][INFO] Webapp assembled in [22 msecs][INFO] Building war: /home/spiderbao/idea_dev/hello_maven/target/hello_maven.war[INFO] WEB-INF/web.xml already added, skipping[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 1.515 s[INFO] Finished at: 2019-05-08T14:28:25+08:00 install 安装123456789101112131415161718192021222324252627282930313233343536373839404142spiderbao@spiderbao-CW65S:~/idea_dev/hello_maven$ mvn install[INFO] Scanning for projects...[INFO] [INFO] ----------------------&lt; com.itheima:hello_maven &gt;-----------------------[INFO] Building hello_maven Maven Webapp 1.0-SNAPSHOT[INFO] --------------------------------[ war ]---------------------------------[INFO] [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ hello_maven ---[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.[INFO] skip non existing resourceDirectory /home/spiderbao/idea_dev/hello_maven/src/main/resources[INFO] [INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ hello_maven ---[INFO] Nothing to compile - all classes are up to date[INFO] [INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ hello_maven ---[INFO] Using &apos;UTF-8&apos; encoding to copy filtered resources.[INFO] skip non existing resourceDirectory /home/spiderbao/idea_dev/hello_maven/src/test/resources[INFO] [INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ hello_maven ---[INFO] No sources to compile[INFO] [INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ hello_maven ---[INFO] No tests to run.[INFO] [INFO] --- maven-war-plugin:2.2:war (default-war) @ hello_maven ---[INFO] Packaging webapp[INFO] Assembling webapp [hello_maven] in [/home/spiderbao/idea_dev/hello_maven/target/hello_maven][INFO] Processing war project[INFO] Copying webapp resources [/home/spiderbao/idea_dev/hello_maven/src/main/webapp][INFO] Webapp assembled in [23 msecs][INFO] Building war: /home/spiderbao/idea_dev/hello_maven/target/hello_maven.war[INFO] WEB-INF/web.xml already added, skipping[INFO] [INFO] --- maven-install-plugin:2.4:install (default-install) @ hello_maven ---[INFO] Installing /home/spiderbao/idea_dev/hello_maven/target/hello_maven.war to /home/spiderbao/.m2/repository/com/itheima/hello_maven/1.0-SNAPSHOT/hello_maven-1.0-SNAPSHOT.war[INFO] Installing /home/spiderbao/idea_dev/hello_maven/pom.xml to /home/spiderbao/.m2/repository/com/itheima/hello_maven/1.0-SNAPSHOT/hello_maven-1.0-SNAPSHOT.pom[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 1.604 s[INFO] Finished at: 2019-05-08T14:42:26+08:00[INFO] ------------------------------------------------------------------------ maven 库maven库可以分为3类分别是： 本地仓库本地仓库 :用来存储从远程仓库或中央仓库下载的插件和 jar 包,项目使用一些插件或 jar 包, 优先从本地仓库查找 远程仓库远程仓库:如果本地需要插件或者 jar 包,本地仓库没有,默认去远程仓库下载。 远程仓库可以在互联网内也可以在局域网内。 中央仓库中央仓库 :在 maven 软件中内置一个远程仓库地址 http://repo1.maven.org/maven2 ,它是中 央仓库,服务于整个互联网,它是由 Maven 团队自己维护,里面存储了非常全的 jar 包,它包含了世界上大部分流行的开源项目构件。 settingsetting 文件主要用来配置maven的一些仓库设置，如本地仓库，远程仓库等。 全局setting 和用户 setting在 maven 安装目录下的有 conf/setting.xml 文件,此 setting.xml 文件用于 maven 的所有 project项目,它作为 maven 的全局配置。如需要个性配置则需要在用户配置中设置,用户配置的 setting.xml 文件默认的位置在: ${user.dir}/.m2/settings.xml 目录中,${user.dir} 指 windows 中的用户目录。或在项目中添加setting.xmlmaven 会先找用户配置,如果找到则以用户配置文件为准,否则使用全局配置文件。 maven 工程认识maven 工程的目录结构如下图 作为一个 maven 工程,它的 src 目录和 pom.xml 是必备的。进入 src 目录后,我们发现它里面的目录结构如下: src/main/java —— 存放项目的.java 文件src/main/resources —— 存放项目资源文件,如 spring, hibernate 配置文件src/test/java —— 存放所有单元测试.java 文件,如 JUnit 测试类src/test/resources —— 测试资源文件target —— 项目输出位置,编译后的 class 文件会输出到此目录pom.xml——maven 项目核心配置文件注意:如果是普通的 java 项目,那么就没有 webapp 目录。 maven 指令的生命周期maven 对项目构建过程分为三套相互独立的生命周期,请注意这里说的是“三套”,而且“相互独立”,这三套生命周期分别是: Clean Lifecycle 在进行真正的构建之前进行一些清理工作。Default Lifecycle 构建的核心部分,编译,测试,打包,部署等等。Site Lifecycle 生成项目报告,站点,发布站点 maven 概念模型Maven 包含了一个项目对象模型 (Project Object Model),一组标准集合,一个项目生命周期(ProjectLifecycle),一个依赖管理系统(Dependency Management System),和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。 项目对象模型 (Project Object Model)一个 maven 工程都有一个 pom.xml 文件,通过 pom.xml 文件定义项目的坐标、项目依赖、项目信息、插件目标等。 依赖管理系统(Dependency Management System)通过 maven 的依赖管理对项目所依赖的 jar 包进行统一管理。比如:项目依赖 junit4.9,通过在 pom.xml 中定义 junit4.9 的依赖即使用 junit4.9,如下所示是 junit4.9的依赖定义: 12345678910111213&lt;!-- 依赖关系 --&gt;&lt;dependencies&gt; &lt;!-- 此项目运行使用 junit,所以此项目依赖 junit --&gt; &lt;dependency&gt; &lt;!-- junit 的项目名称 --&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;!-- junit 的模块名称 --&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!-- junit 版本 --&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;!-- 依赖范围:单元测试时使用 junit --&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 一个项目生命周期(Project Lifecycle)使用 maven 完成项目的构建,项目构建包括:清理、编译、测试、部署等过程,maven 将这些过程规范为一个生命周期,如下所示是生命周期的各各阶段:maven 通过执行一些简单命令即可实现上边生命周期的各各过程,比如执行 mvn compile 执行编译、执行 mvn clean 执行清理。 一组标准集合maven 将整个项目管理过程定义一组标准,比如:通过 maven 构建工程有标准的目录结构,有标准的生命周期阶段、依赖管理有标准的坐标定义等。 插件(plugin)目标(goal)maven 管理项目生命周期过程都是基于插件完成的 maven的继承和聚合maven的继承 继承后maven的子模块会拥有父模块的所有pom信息12345&lt;parent&gt; &lt;artifactId&gt;ssm_parent&lt;/artifactId&gt; &lt;groupId&gt;com.itcast.ssm&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; maven的聚合 我把maven的聚合看做，一个pom件就可以构建指定模块并组合成为一个项目 maven 坐标的来源方式坐标搜索网站central or mvnrepository maven 私服搭建及其使用maven私服搭建下载nexus安装包123 $ cd /opt $ wget http://download.sonatype.com/nexus/oss/nexus-2.10.0-02-bundle.tar.gz 解压并安装1234567 $ cd /opt/ $ tar -zxvf nexus-2.10.0-02-bundle.tar.gz $ cd /opt/nexus-2.10.0-02/bin $ vim nexus 在 nexus文件中添加RUN_AS_USER用户如下1RUN_AS_USER=root 启动nexus1 $ ./nexus start nexus 配置解析： 查看 nexus 的配置文件 conf/nexus.properties 1234567891011# Jetty sectionapplication-port=8081 # nexus 的访问端口配置application-host=0.0.0.0 # nexus 主机监听配置(不用修改)nexus-webapp=$&#123;bundleBasedir&#125;/nexusnexus-webapp-context-path=/nexus# nexus 工程目录# nexus 的 web 访问路径# Nexus sectionnexus-work=$&#123;bundleBasedir&#125;/../sonatype-work/nexus# nexus 仓库目录runtime=$&#123;bundleBasedir&#125;/nexus/WEB-INF # nexus 运行程序目录 nexus仓库类型nexus 的仓库有 4 种类型: 1.hosted,宿主仓库,部署自己的 jar 到这个类型的仓库,包括 releases 和 snapshot 两部分,Releases 公司内部发布版本仓库、 Snapshots 公司内部测试版本仓库 2.proxy,代理仓库,用于代理远程的公共仓库,如 maven 中央仓库,用户连接私服,私服自动去中央仓库下载 jar 包或者插件。 3.group,仓库组,用来合并多个 hosted/proxy 仓库,通常我们配置自己的 maven 连接仓库组。 4.virtual(虚拟):兼容 Maven1 版本的 jar 或者插件 nexus 仓库默认在 sonatype-work 目录中 将项目发布到私服1.setting配置添加 server 12345678910&lt;server&gt; &lt;id&gt;releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt;&lt;server&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt; 2.项目pom添加仓库12345678910&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;releases&lt;/id&gt; &lt;url&gt;http://localhost:8081/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;url&gt;http://localhost:8081/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt; 3.使用maven命令发布 1mvn deploy maven 配置私服下载jar包没有配置nexus之前,如果本地仓库没有,去中央仓库下载,通常在企业中会在局域网内部署一台私服服务器,有了私服本地项目首先去本地仓库找 jar,如果没有找到则连接私服从私服下载 jar 包,如果私服没有 jar 包私服同时作为代理服务器从中央仓库下载 jar 包,这样做的好处是一方面由私服对公司项目的依赖 jar 包统一管理,一方面提高下载速度,项目连接私服下载 jar 包的速度要比项目连接中央仓库的速度快的多。 setting配置 12345678910111213141516171819202122&lt;profile&gt; &lt;!--仓库id--&gt; &lt;id&gt;dev&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;!--仓库 id,repositories 可以配置多个仓库,保证 id 不重复--&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;!--仓库地址,即 nexus 仓库组的地址--&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;/profile&gt;&lt;activeProfiles&gt; &lt;activeProfile&gt;dev&lt;/activeProfile&gt;&lt;/activeProfiles&gt; 将第三方jar导入本地maven12mvn install:install-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37-Dfile= fastjson-1.1.37.jar -Dpackaging=jar 参数说明DgroupId 和 DartifactId 构成了该 jar 包在 pom.xml 的坐标,项目就是依靠这两个属性定位。自己起名字也行。Dfile 表示需要上传的 jar 包的绝对路径。Durl 私服上仓库的位置,打开 nexus——&gt;repositories 菜单,可以看到该路径。DrepositoryId 服务器的表示 id,在 nexus 的 configuration 可以看到。Dversion 表示版本信息 将第三方jar导入私服1.在setting中配置第三方server12345&lt;server&gt; &lt;id&gt;thirdparty&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt; 1234mvn deploy:deploy-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37-Dpackaging=jar -Dfile=fastjson-1.1.37.jar-Durl=http://localhost:8081/nexus/content/repositories/thirdparty/-DrepositoryId=thirdparty 参数说明DgroupId 和 DartifactId 构成了该 jar 包在 pom.xml 的坐标,项目就是依靠这两个属性定位。自己起名字也行。Dfile 表示需要上传的 jar 包的绝对路径。Durl 私服上仓库的位置,打开 nexus——&gt;repositories 菜单,可以看到该路径。DrepositoryId 服务器的表示 id,在 nexus 的 configuration 可以看到。Dversion 表示版本信息]]></content>
  </entry>
  <entry>
    <title><![CDATA[mongodb]]></title>
    <url>%2FMeBlog%2F2019%2F06%2F10%2Fmongodb%2F</url>
    <content type="text"><![CDATA[mongodb入门简介mongodb是一个基于分布式文件存储的数据库。由c++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。 mongoab是一个介于关系型数据库和非关系型数据库之间的产品，是非关系型数据库当中功能丰富，最像关系型数据库的一个产品。它支持的数据格式有json,bson等。他最大的特点是它的查询语法类似于面向对象语言。并且它还支持对数据创建索引。 下面的图片是百度百科对mongodb的介绍 基础概念在mongodb中是通过数据库、集合、文档的方式来管理数据的。下边是mongodb与关系型数据库的一些概念比较图。和关系型数据库一样，mongodb允许一个实例创建多个数据库，一个数据库创建多个集合，一个集合创建多个文档 链接mongodbmongodb使用CS架构开发。client shell使用链接命令如下：1mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]] 数据库操作的相关命令查询数据库show dbs: 查询所有数据库信息 db 创建数据库use 库名使用指定的库，没有则创建（注意：当使用一个新建的库，而且没有插入任何数据时。此时的库实际没有被创建。） 删除数据库db.dropDatabase 集合相关操作命令创建集合db.createConllection(name,options)name:表示集合的名称options:表示创建参数 删除集合db..drop() 表示选中的集合 文档先关操作集合中插入文档db..insert(document) 表示选中的集合document:表示文档，可以是json类型的数据格式 集合中修改指定文档信息db..update(,,) 表示选中的集合 表示 查询条件,相当于sql语句的where 表示 更新文档内容 表示 选项 $set修改器db.test_collection.update({“age”:18},{$set:{“name”:”wan”,”age”:16}},{multi:true}) test_collection：集合名称 {“age”:18} ：查询结果 {$set:{“name”:”wan”,”age”:16}} 修改条件 {multi:true}：参数 multi 为true时表示修改全部，false时表示修改第一个匹配的文档。默认为false 集合中移除指定文档db..remove() 表示选中的集合 表示查询的结果删除前最好先执行查询 集合中搜索指定文档db..find(query,projection) 表示选中的集合query :查询条件projection:投影查询key 投影查询db.test_collection.find({“age”:18},{name:1,age:1,address:1,_id:0})test_collection:制定的集合{“age”:18} ：查询条件{name:1,age:1,address:1,_id:0} ：投影参数，个人不明白只有_id可以设置为0，如果别的设置为0会报Projection cannot have a mix of inclusion and exclusion.异常 用户相关操作命令添加用户1234567db.createUser(&#123; user:&quot;spiderBao&quot;, pwd:&quot;xxx&quot;, roles:[ &#123;role:&quot;root&quot;,db:&quot;admin&quot;&#125; ] &#125;) 修改用户12345db.updateUser( &apos;spiderBao1&apos;,&#123; roles:[ &#123;role:&quot;readWriteAnyDatabase&quot;,db:&quot;admin&quot;&#125;] &#125;) 查询用户1show users 删除用户1db.dropUser(&quot;spiderBao1&quot;) 修改密码1db.changeUserPassword(&quot;test1&quot;,&quot;123&quot;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java—日志框架解析-转载]]></title>
    <url>%2FMeBlog%2F2019%2F06%2F10%2FJava%E2%80%94%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90-%E8%BD%AC%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[导语作为Java程序员，幸运的是，Java 拥有功能和性能都非常强大的日志库；不幸的是，这样的日志库有不止一个相信每个人都曾经迷失在JUL(Java Util Log), JCL(Commons Logging), Log4j, SLF4J, Logback，Log4j2等等的迷宫中。在我见过的绝大多数项目中，都没有能够良好的配置和使用日志库。这篇文章先讲述Java常见日志库的历史和关系，后续会讲日志使用的最佳实践。让我们从头(Java Util Log)开始说起吧。 Java Util Log简称JUL，是JDK 中自带的log功能。虽然是官方自带的log lib，JUL的使用确不广泛。主要原因: 1.JUL从JDK1.4 才开始加入(2002年)，当时各种第三方log lib已经被广泛使用了2.JUL早期存在性能问题，到JDK1.5上才有了不错的进步，但现在和Logback/Log4j2相比还是有所不如3.JUL的功能不如Logback/Log4j2等完善，比如Output Handler就没有Logback/Log4j2的丰富，有时候需要自己来继承定制，又比如默认没有从ClassPath里加载配置文件的功能 Log4j 1.xLog4j 是在 Logback 出现之前被广泛使用的 Log Lib, 由 Gülcü 于2001年发布，后来成为Apache基金会的顶级项目。Log4j 在设计上非常优秀，对后续的 Java Log 框架有长久而深远的影响，也产生了Log4c, Log4s, Log4perl 等到其他语言的移植。Log4j 的短板在于性能，在Logback 和 Log4j2出来之后，Log4j的使用也减少了。 Commons Logging简称JCL，是Apache下面的项目。JCL 是一个Log Facade，只提供 Log API，不提供实现，然后有 Adapter来使用 Log4j 或者 JUL 作为Log Implementation。 就像之前所说，JDK现在带了自己的JUL，然后又有第三方的Log4j等日志库存在，不同的项目可能各自使用了不同的日志库。如果你的项目依赖的其他lib各自使用了不同的日志库，你想控制日志行为，就需要针对每个日志库都写一个配置文件，是不是很酸爽? 然后这个时候 JCL 就出现了。在程序中日志创建和记录都是用JCL中的接口，在真正运行时，会看当前ClassPath中有什么实现，如果有Log4j 就是用 Log4j, 如果啥都没有就是用 JDK 的 JUL。 这样，在你的项目中，还有第三方的项目中，大家记录日志都使用 JCL 的接口，然后最终运行程序时，可以按照自己的需求(或者喜好)来选择使用合适的Log Implementation。如果用Log4j, 就添加 Log4j 的jar包进去，然后写一个 Log4j 的配置文件；如果喜欢用JUL，就只需要写个JUL的配置文件。如果有其他的新的日志库出现，也只需要它提供一个Adapter，运行的时候把这个日志库的 jar 包加进去。 到这个时候一切看起来都很简单，很美好。接口和实现做了良好的分离，在统一的JCL之下，不改变任何代码，就可以通过配置就换用功能更强大，或者性能更好的日志库实现。 这种简单美好一直持续到SLF4J出现。 SLF4J/LogbackSLF4J(The Simple Logging Facade for Java)和Logback也是Gülcü创立的项目，其创立主要是为了提供更高性能的实现。其中，SLF4j 是类似于JCL 的Log Facade,Logback 是类似于Log4j 的 Log Implementation。 之前已经说过，Apache 有了个JCL，用来做各种Log lib统一的接口，如果 Gülcü 要搞一个更好的Log实现的话，直接写一个实现就好了，为啥还要搞一个和SLF4J呢? 原因是Gülcü 认为 JCL 的 API 设计得不好，容易让使用者写出性能有问题的代码。 比如在用 JCL 输出一个 debug 级别的 log: 1logger.debug("start process request, url:" + url); 这个有什么问题呢？一般生产环境 log 级别都会设到 info 或者以上，那这条 log 是不会被输出的。然而不管会不会输出，这其中都会做一个字符串连接操作，然后生产一个新的字符串。如果这条语句在循环或者被调用很多次的函数中，就会多做很多无用的字符串连接，影响性能。 所以 JCL 的最佳实践推荐这么写： 123if (logger.isDebugEnabled()) &#123; logger.debug("start process request, url:" + url);&#125; 然而开发者常常忽略这个问题或是觉得麻烦而不愿意这么写。所以SLF4J提供了新的API，方便开发者使用: 1logger.debug("start process request, url:&#123;&#125;", url); 这样的话，在不输出 log 的时候避免了字符串拼接的开销；在输出的时候需要做一个字符串format，代价比手工拼接字符串大一些,但是可以接受。 而 Logback 则是作为 Log4j 的继承者来开发的，提供了性能更好的实现，异步 logger，Filter等更多的特性。 现在事情变复杂了。我们有了两个流行的 Log Facade，以及三个流行的 Log Implementation。Gülcü是个追求完美的人，他决定让这些Log之间都能够方便的互相替换，所以做了各种 Adapter 和 Bridge 来连接: 可以看到甚至 Log4j 和 JUL 都可以桥接到SLF4J，再通过 SLF4J 适配到到 Logback! 在这里需要注意不能搞出循环的桥接，比如下面这些依赖就不能同时存在: 1.jcl-over-slf4j 和 slf4j-jcl2.log4j-over-slf4j 和 slf4j-log4j123.jul-to-slf4j 和 slf4j-jdk14 总感觉事情在变得更麻烦呢！ Log4j2现在有了更好的 SLF4J 和 Logback——你会想事情到这里总该了解了吧，让他们慢慢取代JCL 和 Log4j 好了。 然而维护 Log4j 的人不这样想，他们不想坐视用户一点点被 SLF4J /Logback 蚕食，继而搞出了 Log4j2。 Log4j2 和 Log4j1.x 并不兼容，设计上很大程度上模仿了 SLF4J/Logback，性能上也获得了很大的提升。 Log4j2 也做了 Facade/Implementation 分离的设计，分成了 log4j-api 和 log4j-core。 现在好了，我们有了三个流行的Log 接口和四个流行的Log实现，如果画出桥接关系的图来回事什么样子呢? 是不是感觉有点晕呢？同样，在添加依赖的时候，要小心不要搞成循环依赖。对于如今的局面我的日志使用方案是 个人推荐日志搭配方案1. 总是使用Log Facade，而不是具体Log Implementation正如之前所说的，使用 Log Facade 可以方便的切换具体的日志实现。而且，如果依赖多个项目，使用了不同的Log Facade，还可以方便的通过 Adapter 转接到同一个实现上。如果依赖项目使用了多个不同的日志实现，就麻烦的多了。 具体来说，现在推荐使用 Log4j-API 或者 SLF4j，不推荐继续使用 JCL。 2. 只添加一个 Log Implementation依赖毫无疑问，项目中应该只使用一个具体的 Log Implementation，建议使用 Logback 或者Log4j2。如果有依赖的项目中，使用的 Log Facade不支持直接使用当前的 Log Implementation，就添加合适的桥接器依赖。具体的桥接关系可以看上一篇文章的图。 3. 具体的日志实现依赖应该设置为optional和使用runtime scope在项目中，Log Implementation的依赖强烈建议设置为runtime scope，并且设置为optional。例如项目中使用了 SLF4J作为 Log Facade，然后想使用 Log4j2 作为 Implementation，那么使用 maven 添加依赖的时候这样设置: 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 设为optional，依赖不会传递，这样如果你是个lib项目，然后别的项目使用了你这个lib，不会被引入不想要的LogImplementation 依赖； Scope设置为runtime，是为了防止开发人员在项目中直接使用Log Implementation中的类，而不适用Log Facade中的类。 4. 如果有必要, 排除依赖的第三方库中的Log Impementation依赖这是很常见的一个问题，第三方库的开发者未必会把具体的日志实现或者桥接器的依赖设置为optional，然后你的项目继承了这些依赖——具体的日志实现未必是你想使用的，比如他依赖了Log4j，你想使用Logback，这时就很尴尬。另外，如果不同的第三方依赖使用了不同的桥接器和Log实现，也极容易形成环。 这种情况下，推荐的处理方法，是使用exclude来排除所有的这些Log实现和桥接器的依赖，只保留第三方库里面对Log Facade的依赖。 比如阿里的JStorm就没有很好的处理这个问题，依赖jstorm会引入对Logback和log4j-over-slf4j的依赖，如果你想在自己的项目中使用Log4j或其他Log实现的话，就需要加上excludes: 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.alibaba.jstorm&lt;/groupId&gt; &lt;artifactId&gt;jstorm-core&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 5. 避免为不会输出的log付出代价(减少对不输出日志的成本)Log库都可以灵活的设置输出界别，所以每一条程序中的log，都是有可能不会被输出。这时候要注意不要额外的付出代价。（字符拼接代价） 先看两个有问题的写法： 12logger.debug("start process request, url: " + url);logger.debug("receive request: &#123;&#125;", toJson(request)); 第一条是直接做了字符串拼接，所以即使日志级别高于debug也会做一个字符串连接操作；第二条虽然用了SLF4J/Log4j2中的懒求值方式来避免不必要的字符串拼接开销，但是toJson()这个函数却是都会被调用并且开销更大。 推荐的写法如下: 123456logger.debug("start process request, url:&#123;&#125;", url); // SLF4J/LOG4J2logger.debug("receive request: &#123;&#125;", () -&gt; toJson(request)); // LOG4J2logger.debug(() -&gt; "receive request: " + toJson(request)); // LOG4J2if (logger.isDebugEnabled()) &#123; // SLF4J/LOG4J2 logger.debug("receive request: " + toJson(request)); &#125; 6. 日志格式中最好不要使用行号，函数名等字段原因是，为了获取语句所在的函数名，或者行号，log库的实现都是获取当前的stacktrace，然后分析取出这些信息，而获取stacktrace的代价是很昂贵的。如果有很多的日志输出，就会占用大量的CPU。在没有特殊需要的情况下，建议不要在日志中输出这些这些字段。 7. log中不要输出稀奇古怪的字符！部分开发人员为了方便看到自己的log，会在log语句中加上醒目的前缀，比如: 1logger.debug("========================start process request============="); 虽然对于自己来说是方便了，但是如果所有人都这样来做的话，那log输出就没法看了！正确的做法是使用grep（linux 中的shell命令） 来看只自己关心的日志。 转载处：https://zhuanlan.zhihu.com/p/24272450]]></content>
  </entry>
  <entry>
    <title><![CDATA[AJAX]]></title>
    <url>%2FMeBlog%2F2019%2F05%2F30%2Fajax%2F</url>
    <content type="text"><![CDATA[AJAX 简介AJAX 全称 Asynchronous JavaScript and XML AJAX = 异步 JavaScript 和 XML。 AJAX 是一种用于创建快速动态网页的技术。 AJAX 工作流程图 ajax基于InternetAJAX是基于现有的Internet标准，并且联合使用它们： XMLHttpRequest 对象 (异步的与服务器交换数据) JavaScript/DOM (信息显示/交互) CSS (给数据定义样式) XML (作为转换数据的格式) lamp AJAX应用程序与浏览器和平台无关的！ ajax实例基础实例123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;script&gt; function loadXMLDoc()&#123; var xmlhttp; if (window.XMLHttpRequest)&#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp=new XMLHttpRequest(); &#125; else&#123; // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)&#123; document.getElementById("myDiv").innerHTML=xmlhttp.responseText; &#125; &#125; xmlhttp.open("GET","https://www.runoob.com/try/ajax/ajax_info.txt",true); xmlhttp.send(); &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="myDiv"&gt;&lt;h2&gt;使用 AJAX 修改该文本内容&lt;/h2&gt;&lt;/div&gt;&lt;button type="button" onclick="loadXMLDoc()"&gt;修改内容&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 内容解析： xmlHttpRequest 请求运行流程 1.创建xmlHttpRequest对象 2.使用xmlHttpRequest对象开启一个请求方式 3.发送请求1234567891011121314151617181.创建xmlHttpRequest对象xmlhttp=new XMLHttpRequest(); //创建xmlHttpRequest对象，IE7+, Firefox, Chrome, Opera, Safari 浏览器可执行代码xmlhttp=new ActiveXObject("Microsoft.XMLHTTP"); //同样也是创建XMLHttpRequest对象，针对IE 6,5老版本的创建方式2.使用xmlHttpRequest对象开启一个请求//open(method,url,async) // 规定请求的类型、URL 以及是否异步处理请求。(开启一个请求)// method：请求的类型；GET 或 POST// url：文件在服务器上的位置，服务器请求路径// async：true（异步）或 false（同步),ajax中此选项一般都是 truexmlhttp.open("GET","https://www.runoob.com/try/ajax/ajax_info.txt",true);//send(string)// 将请求发送到服务器。// string：仅用于 POST 请求,用于添加post请求中的数据xmlhttp.send(); GET 于 POST 的对比与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。 然而，在以下情况中，请使用 POST 请求： 1.无法使用缓存文件（更新服务器上的文件或数据库）2.向服务器发送大量数据（POST 没有数据量限制）3.发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 xmlHttpRequest.setRequestHeader(header,value)此方法用于，向请求添加 HTTP 头。 header: 规定头的名称value: 规定头的值 例如1xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded"); responseText and responseXMLresponseText 用于获取服务器中的文本信息资源 responseXML 用于获取服务器中的XML格式资源 使用实例1document.getElementById("myDiv").innerHTML=xmlhttp.responseText; onreadystatechange 事件当请求被发送到服务器时，我们需要执行一些基于响应的任务。 每当 readyState 改变时，就会触发 onreadystatechange 事件。 readyState 属性存有 XMLHttpRequest 的状态信息。 下面是 XMLHttpRequest 对象的三个重要的属性： onreadystatechange ：存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState ： 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 status ：200: OK HTTP 响应状态码。404 :未找到页面 使用实例：123456789function myFunction()&#123; loadXMLDoc("/try/ajax/ajax_info.txt",function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)&#123; //要做的事情 todo document.getElementById("myDiv").innerHTML=xmlhttp.responseText; &#125; &#125;);&#125; 参考网址：https://www.runoob.com/ajax/ajax-tutorial.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[nginx]]></title>
    <url>%2FMeBlog%2F2019%2F05%2F22%2Fnginx%2F</url>
    <content type="text"><![CDATA[nginx 的安装ubuntu 下安装1apt install nginx nginx 虚拟主机配置1234567891011121314sudo vim /etc/nginx/nginx.conf在 http &#123;&#125;中添加server&#123; listen 80; //监听端口 server_name www.xuecheng.com; //服务名 ssi on; //是否开启ssi ssi_silent_errors on; location / &#123; alias /home/spiderbao/webStrom_dev/xc-ui-pc-static-portal/;//主机映射的路径 index index.html; &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2FMeBlog%2F2019%2F05%2F17%2Fgit%2F</url>
    <content type="text"><![CDATA[为什么使用git这个问题的答案就在于，集中式版本控制和分布式版本控制的的区别。 那么怎样算得上集中式版本控制呢？ 比如说SVN就是集中式版本控制系统，版本库是集中放在中央服务器的,而干活的时候,用的都是自己的电脑,所以首先要从中央服务器哪里得到最新的版本,然后干活,干完后,需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作,如果在局域网还可以,带宽够大,速度够快,如果在互联网下,如果网速慢的话,就郁闷了。 集中式版本控制存在如下缺陷： 依赖网络性强，由于只使用一个中央服务器，所以会有单点问题。 以上说了集中式版本控制，那么分布式版本控制工具又是怎么样的呢？ 分布式版本控制的代表就是git Git 是分布式版本控制系统,那么它就没有中央服务器,每个人的电脑就是一个完整的版本库,这样,工作的时候就不需要联网了,因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库,那多个人如何协作呢?比如说自己在电脑上改了文件A,其他人也在电脑上改了文件A,这时,你们两之间只需把各自的修改推送给对方,就可以互相看到对方的修改了。下图就是分布式版本控制工具管理方式: 分布式版本控制：解决了集中式版本控制的单点问题，和网络依赖性问题，适用于互联网多地区协同开发，但是在只是在局域网下开发，个人认为还是使用svn会更方便，git虽然性能优越但是使用上没有SVN简便。 git简介同生活中的许多伟大事件一样,Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991-2002 年间)。到 2002 年,整个项目组开始启用分布式版本控制系统 BitKeeper 来管理和维护代码。到 2005 年的时候,开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束,他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区(特别是 Linux 的缔造者 Linus Torvalds )不得不吸取教训,只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统订了若干目标:• 速度• 简单的设计• 对非线性开发模式的强力支持(允许上千个并行开发的分支)• 完全分布式• 有能力高效管理类似 Linux 内核一样的超大规模项目(速度和数据量) 工作流程一般工作流程如下:1.从远程仓库中克隆 Git 资源作为本地仓库。2.从本地仓库中 checkout 代码然后进行代码修改3.在提交前先将代码提交到暂存区。4.提交修改。提交到本地仓库。本地仓库中保存修改的各个历史版本。5.在修改完成后,需要和团队成员共享代码时,可以将代码 push 到远程仓库。下图展示了 Git 的工作流程: git 的工作目录介绍 其中 ./git 文件夹下就是git的本地仓库 git的使用创建仓库1git init 要初始的文件夹路径 添加文件到暂存区1git add 要加入的文件 将暂存区文件添加到本地仓库，并将本地仓库推送到远程仓库中将缓存区域文件添加到本地仓库1git commit 将本地仓库推送到远程仓库中123456789101112131415161718spiderbao@spiderbao-CW65S:~/git_study$ git push ssh://git@39.xxx.171.29/home/git/git_studyfatal: 当前分支 master 没有对应的上游分支。为推送当前分支并建立与远程上游的跟踪，使用 git push --set-upstream ssh://git@39.XXX.171.29/home/git/git_study masterspiderbao@spiderbao-CW65S:~/git_study$ git push --set-upstream ssh://git@39.XXX.171.29/home/git/git_study mastergit@39.XXX.171.29&apos;s password: Permission denied, please try again.git@39.XXX.171.29&apos;s password: 对象计数中: 6, 完成.Delta compression using up to 4 threads.压缩对象中: 100% (3/3), 完成.写入对象中: 100% (6/6), 523 bytes | 523.00 KiB/s, 完成.Total 6 (delta 0), reused 0 (delta 0)To ssh://39.XXX.171.29/home/git/git_study * [new branch] master -&gt; master分支 &apos;master&apos; 设置为跟踪来自 &apos;ssh://git@39.XXX.171.29/home/git/git_study&apos; 的远程分支 &apos;master&apos;。 查看修改历史123456789101112spiderbao@spiderbao-CW65S:~/git_study$ git logcommit 4cb2b4f87b03b6cf3301b000a3e14c44027e3f42 (HEAD -&gt; master)Author: spiderbao &lt;13593265401@163.com&gt;Date: Fri May 17 14:28:44 2019 +0800 第二次修改commit 1910c01353a8f12304e2a923164f69e33925a03aAuthor: spiderbao &lt;13593265401@163.com&gt;Date: Fri May 17 14:21:19 2019 +0800 first commit 还原修改reset 还原，还原后历史版本不存在12spiderbao@spiderbao-CW65S:~/git_study$ git reset --hard 1910c01353a8f12304e2a923164f69e33925a03aHEAD 现在位于 1910c01 first commit 删除文件12spiderbao@spiderbao-CW65S:~/git_study$ git rm test rm &apos;test&apos; 忽略文件或文件夹在文件目录下创建gitignore 文件12touch .gitignorevim .gitignore 忽略语法 123456789101112131415161718192021空行或是以 # 开头的行即注释行将被忽略。可以在前面添加正斜杠 / 来避免递归,下面的例子中可以很明白的看出来与下一条的区别。可以在后面添加正斜杠 / 来忽略文件夹,例如 build/ 即忽略 build 文件夹。可以使用 ! 来否定忽略,即比如在前面用了 *.apk ,然后使用 !a.apk ,则这个 a.apk 不会被忽略。* 用来匹配零个或多个字符,如 *.[oa] 忽略所有以&quot;.o&quot;或&quot;.a&quot;结尾, *~ 忽略所有以 ~ 结尾的文件(这种文件通常被许多编辑器标记为临时文件); [] 用来匹配括号内的任一字符,如 [abc] ,也可以在括号内加连接符,如 [0-9] 匹配 0 至 9 的数; ? 用来匹配单个字符。看了这么多,还是应该来个栗子:# 忽略 .a 文件*.a# 但否定忽略 lib.a, 尽管已经在前面忽略了 .a 文件!lib.a# 仅在当前目录下忽略 TODO 文件, 但不包括子目录下的 subdir/TODO/TODO# 忽略 build/ 文件夹下的所有文件build/# 忽略 doc/notes.txt, 不包括 doc/server/arch.txtdoc/*.txt# 忽略所有的 .pdf 文件 在 doc/ directory 下的doc/**/*.pdf 解决文件冲突编辑有冲突后的文件，再次提交即可 文件更新或拉取123456789101112spiderbao@spiderbao-CW65S:~/cloneToGit$ git clone ssh://git@39.xxx.xxx.29/home/git/git_study正克隆到 &apos;git_study&apos;...git@39.xxx.xxx.29&apos;s password: remote: Counting objects: 13, done.remote: Compressing objects: 100% (7/7), done.remote: Total 13 (delta 0), reused 0 (delta 0)接收对象中: 100% (13/13), 完成.spiderbao@spiderbao-CW65S:~/cloneToGit$ cd git_study/spiderbao@spiderbao-CW65S:~/cloneToGit/git_study$ git pullgit@39.xxx.xxx.29&apos;s password: 已经是最新的。 git分支管理创建分支1git branch 新分支名称 选择分支1git checkout 分支名称 合并分支123456spiderbao@spiderbao-CW65S:~/git_study$ git merge mybatis 更新 8c65eb0..458de41Fast-forward xiaoli | 1 + 1 file changed, 1 insertion(+) create mode 100644 xiaoli]]></content>
  </entry>
  <entry>
    <title><![CDATA[Docker]]></title>
    <url>%2FMeBlog%2F2019%2F05%2F17%2FDocker%2F</url>
    <content type="text"><![CDATA[Docker学习目标： 掌握Docker基础知识，能够理解Docker镜像与容器的概念 完成Docker安装与启动 掌握Docker镜像与容器相关命令 掌握Tomcat Nginx 等软件的常用应用的安装 掌握docker迁移与备份相关命令 能够运用Dockerfile编写创建容器的脚本 能够搭建与使用docker私有仓库 ​ 1 Docker简介1.1 什么是虚拟化​ 在计算机中，虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。这些资源的新虚拟部份是不受现有资源的架设方式，地域或物理组态所限制。一般所指的虚拟化资源包括计算能力和资料存储。 ​ 在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件 对资源充分利用 ​ 虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等。 1.2 什么是Docker​ Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。 ​ ​ Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。 ​ Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。 ​ 在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。 为什么选择Docker? （1）上手快。 ​ 用户只需要几分钟，就可以把自己的程序“Docker化”。Docker依赖于“写时复制”（copy-on-write）模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改”的境界。 随后，就可以创建容器来运行应用程序了。大多数Docker容器只需要不到1秒中即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。 （2）职责的逻辑分类 ​ 使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）” （3）快速高效的开发生命周期 ​ Docker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。（通俗一点说，Docker就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取。） （4）鼓励使用面向服务的架构 ​ Docker还鼓励面向服务的体系结构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。（当然，可以在一个容器中运行多个应用程序） 1.3 容器与虚拟机比较​ 下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。 与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。 1.4 Docker 组件1.4.1 Docker服务器与客户端​ Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。 1.4.2 Docker镜像与容器​ 镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。例如： 添加一个文件； 执行一个命令； 打开一个窗口。 也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新。 ​ Docker可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可。容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。 容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。 所以Docker容器就是： ​ 一个镜像格式； ​ 一些列标准操作； ​ 一个执行环境。 ​ Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。 和集装箱一样，Docker在执行上述操作时，并不关心容器中到底装了什么，它不管是web服务器，还是数据库，或者是应用程序服务器什么的。所有的容器都按照相同的方式将内容“装载”进去。 Docker也不关心你要把容器运到何方：我们可以在自己的笔记本中构建容器，上传到Registry，然后下载到一个物理的或者虚拟的服务器来测试，在把容器部署到具体的主机中。像标准集装箱一样，Docker容器方便替换，可以叠加，易于分发，并且尽量通用。 1.4.3 Registry（注册中心）​ Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像（说明：在Docker Hub下载镜像巨慢，可以自己构建私有的Registry）。 ​ https://hub.docker.com/ 2 Docker安装与启动2.1 安装Docker​ Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。 ​ 由于我们学习的环境都使用的是CentOS，因此这里我们将Docker安装到CentOS上。注意：这里建议安装在CentOS7.x以上的版本，在CentOS6.x的版本中，安装前需要安装其他很多的环境而且Docker很多补丁不支持更新。 ​ 请直接挂载课程配套的Centos7.x镜像 （1）yum 包更新到最新 1sudo yum update （2）安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 （3）设置yum源为阿里云 1sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo （4）安装docker 1sudo yum install docker-ce （5）安装后查看docker版本 1docker -v 2.2 设置ustc的镜像ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。 https://lug.ustc.edu.cn/wiki/mirrors/help/docker 编辑该文件： 1vi /etc/docker/daemon.json 在该文件中输入如下内容： 123&#123;&quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]&#125; 2.3 Docker的启动与停止systemctl命令是系统服务管理器指令 启动docker： 1systemctl start docker 停止docker： 1systemctl stop docker 重启docker： 1systemctl restart docker 查看docker状态： 1systemctl status docker 开机启动： 1systemctl enable docker 查看docker概要信息 1docker info 查看docker帮助文档 1docker --help 3 常用命令3.1 镜像相关命令3.1.1 查看镜像1docker images REPOSITORY：镜像名称 TAG：镜像标签 IMAGE ID：镜像ID CREATED：镜像的创建日期（不是获取该镜像的日期） SIZE：镜像大小 这些镜像都是存储在Docker宿主机的/var/lib/docker目录下 3.1.2 搜索镜像如果你需要从网络中查找需要的镜像，可以通过以下命令搜索 1docker search 镜像名称 NAME：仓库名称 DESCRIPTION：镜像描述 STARS：用户评价，反应一个镜像的受欢迎程度 OFFICIAL：是否官方 AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的 3.1.3 拉取镜像拉取镜像就是从中央仓库中下载镜像到本地 1docker pull 镜像名称 例如，我要下载centos7镜像 1docker pull centos:7 3.1.4 删除镜像按镜像ID删除镜像 1docker rmi 镜像ID 删除所有镜像 1docker rmi `docker images -q` 3.2 容器相关命令3.2.1 查看容器查看正在运行的容器 1docker ps 查看所有容器 1docker ps –a 查看最后一次运行的容器 1docker ps –l 查看停止的容器 1docker ps -f status=exited 3.2.2 创建与启动容器创建容器常用的参数说明： 创建容器命令：docker run -i：表示运行容器 -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。 –name :为创建的容器命名。 -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。 -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。 -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射 （1）交互式方式创建容器 1docker run -it --name=容器名称 镜像名称:标签 /bin/bash 这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态 退出当前容器 1exit （2）守护式方式创建容器： 1docker run -di --name=容器名称 镜像名称:标签 登录守护式容器方式： 1docker exec -it 容器名称 (或者容器ID) /bin/bash 3.2.3 停止与启动容器停止容器： 1docker stop 容器名称（或者容器ID） 启动容器： 1docker start 容器名称（或者容器ID） 3.2.4 文件拷贝如果我们需要将文件拷贝到容器内可以使用cp命令 1docker cp 需要拷贝的文件或目录 容器名称:容器目录 也可以将文件从容器内拷贝出来 1docker cp 容器名称:容器目录 需要拷贝的文件或目录 3.2.5 目录挂载我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。创建容器 添加-v参数 后边为 宿主机目录:容器目录，例如： 1docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos3 centos:7 如果你共享的是多级的目录，可能会出现权限不足的提示。 这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数 –privileged=true 来解决挂载的目录没有权限的问题 3.2.6 查看容器IP地址我们可以通过以下命令查看容器运行的各种数据 1docker inspect 容器名称（容器ID） 也可以直接执行下面的命令直接输出IP地址 1docker inspect --format=&apos;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&apos; 容器名称（容器ID） 3.2.7 删除容器删除指定的容器： 1docker rm 容器名称（容器ID） 4 应用部署4.1 MySQL部署（1）拉取mysql镜像 1docker pull centos/mysql-57-centos7 （2）创建容器 1docker run -di --name=tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql(镜像名称或ID) -p 代表端口映射，格式为 宿主机映射端口:容器运行端口 -e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是root用户的登陆密码 （3）远程登录mysql 连接宿主机的IP ,指定端口为33306 4.2 tomcat部署（1）拉取镜像 1docker pull tomcat:7-jre7 （2）创建容器 创建容器 -p表示地址映射 12docker run -di --name=mytomcat -p 9000:8080 -v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7(镜像名称或ID) 4.3 Nginx部署（1）拉取镜像 1docker pull nginx （2）创建Nginx容器 1docker run -di --name=mynginx -p 80:80 nginx 4.4 Redis部署（1）拉取镜像 1docker pull redis （2）创建容器 1docker run -di --name=myredis -p 6379:6379 redis 5 迁移与备份5.1 容器保存为镜像我们可以通过以下命令将容器保存为镜像 1docker commit mynginx mynginx_i 5.2 镜像备份我们可以通过以下命令将镜像保存为tar 文件 1docker save -o mynginx.tar mynginx_i 5.3 镜像恢复与迁移首先我们先删除掉mynginx_img镜像 然后执行此命令进行恢复 1docker load -i mynginx.tar -i 输入的文件 执行后再次查看镜像，可以看到镜像已经恢复 6 Dockerfile6.1 什么是DockerfileDockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。 1、对于开发人员：可以为开发团队提供一个完全一致的开发环境；2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了；3、对于运维人员：在部署时，可以实现应用的无缝移植。 6.2 常用命令 命令 作用 FROM image_name:tag 定义了使用哪个基础镜像启动构建流程 MAINTAINER user_name 声明镜像的创建者 ENV key value 设置环境变量 (可以写多条) RUN command 是Dockerfile的核心部分(可以写多条) ADD source_dir/file dest_dir/file 将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压 COPY source_dir/file dest_dir/file 和ADD相似，但是如果有压缩文件并不能解压 WORKDIR path_dir 设置工作目录 6.3 使用脚本创建镜像步骤： （1）创建目录 1mkdir –p /usr/local/dockerjdk8 （2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录 （3）创建文件Dockerfile vi Dockerfile 123456789101112131415#依赖镜像名称和IDFROM centos:7#指定镜像创建者信息MAINTAINER ITCAST#切换工作目录WORKDIR /usrRUN mkdir /usr/local/java#ADD 是相对路径jar,把java添加到容器中ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/#配置java环境变量ENV JAVA_HOME /usr/local/java/jdk1.8.0_171ENV JRE_HOME $JAVA_HOME/jreENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATHENV PATH $JAVA_HOME/bin:$PATH （4）执行命令构建镜像 1docker build -t=&apos;jdk1.8&apos; . 注意后边的空格和点，不要省略 （5）查看镜像是否建立完成 1docker images 7 Docker私有仓库7.1 私有仓库搭建与配置（1）拉取私有仓库镜像（此步省略） 1docker pull registry （2）启动私有仓库容器 1docker run -di --name=registry -p 5000:5000 registry （3）打开浏览器 输入地址http://192.168.184.141:5000/v2/_catalog看到`{&quot;repositories&quot;:[]}` 表示私有仓库搭建成功并且内容为空 （4）修改daemon.json 1vi /etc/docker/daemon.json 添加以下内容，保存退出。 1&#123;"insecure-registries":["192.168.184.141:5000"]&#125; 此步用于让 docker信任私有仓库地址 （5）重启docker 服务 1systemctl restart docker 7.2 镜像上传至私有仓库（1）标记此镜像为私有仓库的镜像 1docker tag jdk1.8 192.168.184.141:5000/jdk1.8 （2）再次启动私服容器 1docker start registry （3）上传标记的镜像 1docker push 192.168.184.141:5000/jdk1.8 8.Docker如何查看容器日志8.1 Docker logs​ 使用命令docker logs 容器名即可查看 1docker logs 容器名 ​ -f 查看实时日志 1docker logs -f 容器名 ​ -t查看日志产生的日期 1docker logs -t 容器名 ​ –since : 此参数指定了输出日志开始日期，即只输出指定日期之后的日志。 1docker logs -f -t --since=&quot;2017-05-31&quot; --tail=10 容器名 ​ –tail=10 : 查看最后的10条日志。 9.Docker的生命周期 10.进入Docker1docker exce -ti 容器名称 /bin/bash]]></content>
  </entry>
  <entry>
    <title><![CDATA[ubuntu 下的软件管理]]></title>
    <url>%2FMeBlog%2F2019%2F05%2F15%2Fubuntu%20%E4%B8%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[概念部分Ubuntu软件包管理概述Ubuntu Linux采用了Debian的软件包管理机制。由于软件包具有易用性、灵活性和扩展性的特点，再加上Internet的支持，使用户随时都能拥有最新的 Ubuntu系统，这也是Ubuntu受到推崇的一个重要原因。因而，Deb软件包管理也成为Ubuntu中最有活力的部分。本章介绍Ubuntu软件包 管理和dpkg软件包管理器。 Deb软件包概述Deb软件包本质上是文件包，这点类似于tar文件将多个文件合并为一个归档文件。但是Deb的身价不在于整合文件，而在于使应用程序更易于传播。 当年流行的两种软件包管理机制 最初，基于Linux系统的开发者在完成应用程序开 发后，将很多二进制文件发给用户，用户使用之前需要将相关程序逐个安装。因此，Debian Linux首先提出“软件包”的管理机制——Deb软件包，将应用程序的二进制文件、配置文档、man/info帮助页面等文件合并打包在一个文件中，用 户使用软件包管理器直接操作软件包，完成获取、安装、卸载、查询等操作。 随即，Redhat Linux基于这个理念推出了自己的软件包管理机制——Rpm软件包。当然，Redhat Linux采用了自己的打包格式生成Rpm包文件，由Rpm包管理器负责安装、维护、查询，甚至软件包版本管理。由于Redhat Linux系统的普及，Rpm软件包被广泛使用，甚至出现第三方开发的软件管理工具，专门管理Rpm格式的软件包。 随着Linux操作系统规模的不断扩大，系统中软件 包之间复杂的依赖关系，导致Linux用户麻烦不断。为了解决这个问题，Debian Linux开发出了APT软件包管理器。它能够自动检查和修复软件包之间的依赖关系。并且，利用Internet网络带来的快捷的连通手段，APT工具可 以帮助用户主动获取软件包。因此，APT工具再次促进了Deb软件包更为广泛地使用，成为Debian Linux的一个无法替代的亮点。 Ubuntu Linux系统的软件包管理机制延续了Debian的包管理方法。 软件包的类型Debian包文件包含了二进制可执行文件、库文件、配置文件和man/info帮助页面等文档。通常Debian包文件的后缀为.deb，因此称为“Deb软件包”。Ubuntu有两种类型的软件包：二进制软件包（deb）和源码包（deb-src）。 ● 二进制软件包（Binary Packages）：包含可执行文件、库文件、配置文件、man/info页面、版权声明和其他文档。 ● 源码包（Source Packages）：包含软件源代码、版本修改说明、构建指令以及编译工具等。先由tar工具归档为.tar.gz文件，然后再打包成.dsc文件。 用户不确定一个软件包具体类型时，可以使用file命令查看文件类型。例如下面命令用于证实一个软件包的文件类型是否是Deb软件包文件。 wdl@UbuntuFisher:~$ file g++_4.1.2-9ubuntu2_i386.deb g++_4.1.2-9ubuntu2_i386: Debian binary package (format 2.0) 在Ubuntu Linux中，需要说明一个概念——虚拟软件包。将系统中具有相同或相近功能的多个软件包作为一个软件包集合，称为虚拟软件包，并指定其中一个软件包作为 虚拟软件包的默认首选项。提出虚拟软件的意图就是为了防止软件安装过程中发生冲突。例如，exim、sendmail和postfix软件包都是用于邮件 传输代理，将“mail-transport-agent”指定为它们的虚拟软件包。当用户安装“mail-transport-agent”时，将选择 安装exim、sendmail和postfix其中的首选项。 软件包的命名在Ubuntu Linux中，软件包的命名遵循以下约定： Filename_Version-Reversion_Architecture.deb 其中，Filename表示软件包文件名，Version表示软件版本号，Reversion表示修订版本号，Architecture表示适用计算机架构。通常，修订版本号是由Ubuntu开发者或创建这个软件包的人指定。在软件包被修改过之后，将修改版本号加1。 以g++_4.1.2-9ubuntu2_i386.deb软件包为例，g++是软件包名，4.1.2是软件版本号，9ubuntu2是修订版本号，i386是适用的计算机架构。 配置部分Ubuntu 方便宜用，最值得让人称道的便是其安装软件的方式, 一条命令: sudo apt-get install xxx 就几乎能帮你搞定所有的软件安装难题。但是有时你可能有这样的需求，查看某个软件包是否安装、安装在哪..., 那我们就来介绍一下 Ubuntu 的软件包管理方式。 一、Ubuntu 采用 Debian 的软件包管理器 dpkg 来管理软件包, 类似 RPM. 系统中所有 packages 的信息都在 /var/lib/dpkg/ 目录下, 其子目录 /var/lib/dpkg/info 用于保存各个软件包的配置文件列表: (1).conffiles 记录了软件包的配置文件列表 (2).list 保存软件包中的文件列表, 用户可以从 .list 的信息中找到软件包中文件的具体安装位置. (3).md5sums 记录了软件包的md5信息, 这个信息是用来进行包验证的. (4).prerm 脚本在 Debian 包解包之前运行, 主要作用是停止作用于即将升级的软件包的服务, 直到软件包安装或升级完成. (5).postinst 脚本是完成 Debian 包解开之后的配置工作, 通常用于执行所安装软件包相关命令和服务重新启动. /var/lib/dpkg/available 文件的内容是软件包的描述信息, 该软件包括当前系统所使用的 Debian 安装源中的所有软件包, 其中包括当前系统中已安装的和未安装的软件包. /var/cache/apt/archives 目录是在用 apt-get install 安装软件时，软件包的临时存放路径 /etc/apt/sources.list 存放的是软件源站点, 当你执行 sudo apt-get install xxx 时，Ubuntu 就去这些站点下载软件包到本地并执行安装 命令操作部分apt和dpkg混合命令 (1)查看某软件包的安装内容 dpkg -L xxx (2)查找软件库中的软件包 apt-cache search 正则表达式 (3)显示系统安装包的统计信息 apt-cache stats (4)显示系统全部可用软件包的名称 apt-cache pkgnames (5)显示某软件包的详细信息 apt-cache show xxx (6)查找某文件属于哪个包 apt-file search xxx (7)查看已经安装了哪些软件包 dpkg -l (8)查询某软件依赖哪些软件包 apt-cache depends xxx (9)查询某软件被哪些软件包依赖 apt-cache rdepends xxx (10)增加一个光盘源 sudo apt-cdrom add 注: 顾名思义, 就是安装更新软件包时让其优先从Ubuntu 光盘上找(如果你不能上网安装/更新, 但有 Ubuntu 的 DVD ISO, 这会对你非常有用) (11)系统升级 sudo apt-get update (12)清除所有已删除软件包的残馀配置文件 dpkg -l |grep ^rc|awk ‘{print $2}’ |sudo xargs dpkg -P (13)编译时缺少h文件的自动处理 sudo auto-apt run ./configure (14)查看安装软件时下载软件包的临时存放目录 ls /var/cache/apt/archives (15)备份当前系统安装的所有软件包的列表 dpkg –get-selections | grep -v deinstall &gt; ~/somefile (16)从上面备份的安装包的列表文件恢复所有包 dpkg –set-selections &lt; ~/somefile sudo dselect (17)清理旧版本的软件缓存 sudo apt-get autoclean (18)清理所有软件缓存 sudo apt-get clean (19)删除系统不再使用的孤立软件 sudo apt-get autoremove (20)查看软件包在服务器上面的地址 apt-get -qq –print-uris install ssh | cut -d\’ -f2 (21)查看安装软件的一些路径信息 dpkg -L 软件包名 deb包安装sudo dpkg -i &apos;deb文件路径加文件名&apos;]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot]]></title>
    <url>%2FMeBlog%2F2019%2F05%2F14%2Fspringboot%2F</url>
    <content type="text"><![CDATA[springboot概述springboot是spring的一个boot版本，它的出现是为了让你能更快的体验或使用spring。我经常把它看做spring的简单易用版。那他是从那几个方面去做到spring的简单易用的呢？ 1.约定优于配置 —自动配置2.依赖自带了起步依赖的坐标。—起步依赖 springboot_quick （dome）1.pom构建：继承springbootparent ，起步依赖配置1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itcast&lt;/groupId&gt; &lt;artifactId&gt;springboot_quick&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 2.创建启动类1234567891011121314151617181920212223package com.itcast;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import javax.swing.*;/** * @className MysoringBoot * @Descirption springboot boot class * @Author WengLiangBao * @Date 19-5-12 下午1:21 * @Vsersion 1.0 */@SpringBootApplicationpublic class MysoringBoot &#123; /* SpringApplication.run(MysoringBoot.class) 代表运行SpringBoot的启动类,参数为SpringBoot启动类的字节码对象 */ public static void main(String[] args)&#123; SpringApplication.run(MysoringBoot.class); &#125;&#125; 3.构建访问控制层controller1234567891011121314151617181920212223package com.itcast.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;/** * @className QuickStartController * @Descirption quick dome contorller * @Author WengLiangBao * @Date 19-5-12 下午1:37 * @Vsersion 1.0 */@Controllerpublic class QuickStartController &#123; @RequestMapping("/quick") @ResponseBody public String quick()&#123; return "springboot 访问成功！"; &#125;&#125; pom中添加热部署 12345&lt;!-- 热部署--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt; 起步依赖自动配置springboot配置文件SpringBoot是基于约定的,所以很多配置都有默认值,但如果想使用自己的配置替换默认配置的话,就可以使用application.properties或者application.yml(application.yaml)进行配置。 SpringBoot默认会从Resources目录下加载application.properties或application.yml(application.yaml) 上面提及过,SpringBoot的配置文件,主要的目的就是对配置信息进行修改的,但在配置时的key从哪里去查询呢?我们可以查阅SpringBoot的官方文档文档URL:https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#common-application-properties 配置文件与配置类的属性映射关系@value1.在application.yml 中添加如下属性123person: name: xiaoming age: 18 2.在对应类中使用1234@Value("$&#123;person.name&#125;")private String name;@Value("$&#123;person.age&#125;")private Integer age; @configurationProperties1.在application.yml 中添加如下属性123person: name: xiaoming age: 18 2.在对应的实体类中使用12345678@ConfigurationProperties(prefix = "person")@Datapublic class QuickStartController &#123; private String name; private int age; 注意使用configurationProperties需要为指定的属性添加getting或setting ，本人使用lombok的@Data自动生成了getting，setting springboot整合mybatis 整合1.pom 中添加坐标1234567891011&lt;!--由于spring官方没有对mybatis整合提供技术方案支持，所以这里需要使用mybatis提供的整合jar包，并指定版本--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 2.application.yml 中配置mybatis及数据库链接信息12345678910#DB configurationspring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/mybatis_study?useUnicode=true&amp;charaterEncoding=utf-8&amp;useSSL=true username: spider password: *****#mybatis configurationmybatis: mapper-locations: classpath:mapper/*Mapper.xml 3.创建dao控制层和mapper映射文件 dao层文件12345678910111213141516171819package com.itcast.dao;import com.itcast.pojo.User;import org.apache.ibatis.annotations.Mapper;import java.util.List;/** * @className UserMapper * @Descirption * @Author WengLiangBao * @Date 19-5-12 下午3:09 * @Vsersion 1.0 */@Mapperpublic interface UserMapper &#123; public List&lt;User&gt; queryUserList();&#125; Mapper ,编写位置对应application.yml中mapper-locations的位置，内容为123456789&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.itcast.dao.UserMapper"&gt; &lt;select id="queryUserList" resultType="com.itcast.pojo.User"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 4.数据库对应pojo编写1234567891011121314151617181920212223package com.itcast.pojo;import lombok.Data;/** * @className User * @Descirption * @Author WengLiangBao * @Date 19-5-12 下午3:07 * @Vsersion 1.0 */@Datapublic class User &#123; private Integer id; private String username; private String password; private String name;&#125; Junit 整合1.pom中添加Junit起步依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;/dependency&gt; 2.编写测试类12345678910111213141516171819202122232425262728293031323334353637383940package com.itcast.daoTest;import com.itcast.MysoringBoot;import com.itcast.dao.UserMapper;import com.itcast.pojo.User;import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import java.util.ArrayList;import java.util.List;/** * @className UserMapperTest * @Descirption 用户映射测试 * @Author WengLiangBao * @Date 19-5-12 下午3:50 * @Vsersion 1.0 */@RunWith(SpringRunner.class)@SpringBootTest(classes = MysoringBoot.class)//程序启动入口类public class UserMapperTest &#123; @Autowired private UserMapper userMapper; @Test public void queryListUser()&#123; List&lt;User&gt; users = userMapper.queryUserList(); Assert.assertNotNull(users); List&lt;User&gt; array = new ArrayList&lt;User&gt;(); array.add(new User(1,"zhangsan","123","张三")); array.add(new User(2,"lisi","123","李四")); System.out.print(users); Assert.assertArrayEquals(users.toArray(),array.toArray()); &#125;&#125; redis 整合1.添加起步依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 2.application.yml 中配置redis所需属性1234spring: redis: host: xx.104.xxx.29 port: 6379 3.编写测试类测试1234567891011121314151617181920@Autowiredprivate UserMapper userMapper;@Autowiredprivate RedisTemplate&lt;String,String&gt; redisTemplate;@Testpublic void redisTest() throws JsonProcessingException &#123; String userListData = redisTemplate.boundValueOps("user.findAll").get(); if(userListData==null)&#123; List&lt;User&gt; users = userMapper.queryUserList(); String uD = new ObjectMapper().writeValueAsString(users); userListData = uD; redisTemplate.boundValueOps("user.findAll").set(uD); System.out.print("从数据库中获取"); &#125;else &#123; System.out.print("从redis缓存中获取"); &#125; System.out.print(userListData);&#125; springJPA 整合1.添加spring Data JPA起步依赖及其所需的一些坐标12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 2.application.yml中配置数据库及jpa的相关属性12345678910spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://127.0.0.1:3306/mybatis_study?useUnicode=true&amp;charaterEncoding=utf-8&amp;useSSL=truespring.datasource.username=spiderspring.datasource.password=*****spring.jpa.database=MySQLspring.jpa.show-sql=truespring.jpa.generate-ddl=truespring.jpa.hibernate.ddl-auto=updatespring.jpa.hibernate.naming_strategy=org.hibernate.cfg.ImprovedNamingStrategy 3.创建pojo并映射123456789101112131415161718192021222324252627282930package com.example.demo.pojo;import lombok.Data;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;/** * @className User * @Descirption * @Author WengLiangBao * @Date 19-5-12 下午4:58 * @Vsersion 1.0 */@Entity@Datapublic class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String username; private String password; private String name;&#125; 4.编写dao层的对应操作接口1234567891011121314151617package com.example.demo.dao;import com.example.demo.pojo.User;import org.springframework.data.jpa.repository.JpaRepository;import java.util.List;/** * @className UserRepository * @Descirption * @Author WengLiangBao * @Date 19-5-12 下午5:21 * @Vsersion 1.0 */public interface UserRepository extends JpaRepository&lt;User,Long&gt; &#123; public List&lt;User&gt; findAll();&#125; 5.编写测试类测试验证1234567891011121314151617181920212223242526package com.example.demo;import com.example.demo.dao.UserRepository;import com.example.demo.pojo.User;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import java.util.List;@RunWith(SpringRunner.class)@SpringBootTest(classes = DemoApplication.class)public class DemoApplicationTests &#123; @Autowired private UserRepository userRepository; @Test public void contextLoads() &#123; List&lt;User&gt; all = userRepository.findAll(); System.out.print(all); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[python_base64]]></title>
    <url>%2FMeBlog%2F2019%2F05%2F05%2Fpyhton_base64%2F</url>
    <content type="text"><![CDATA[目标1：了解base64基础知识，在python中会使用base64base64的编码原理（摘录）Base64是一种用64个字符来表示任意二进制数据的方法。 用记事本打开exe、jpg、pdf这些文件时，我们都会看到一大堆乱码，因为二进制文件包含很多无法显示和打印的字符，所以，如果要让记事本这样的文本处理软件能处理二进制数据，就需要一个二进制到字符串的转换方法。Base64是一种最常见的二进制编码方法。 Base64的原理很简单，首先，准备一个包含64个字符的数组： [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, ... &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, ... &apos;0&apos;, &apos;1&apos;, ... &apos;+&apos;, &apos;/&apos;] 然后，对二进制数据进行处理，每3个字节一组，一共是3x8=24bit，划为4组，每组正好6个bit： 这样我们得到4个数字作为索引，然后查表，获得相应的4个字符，就是编码后的字符串。 所以，Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。 如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用\x00字节在末尾补足后，再在编码的末尾加上1个或2个=号，表示补了多少字节，解码的时候，会自动去掉。 python中的base64加密1base64.b64encode(b'binary\x00string') 解密1base64.b64decode(b'YmluYXJ5AHN0cmluZw==') safe由于标准的Base64编码后可能出现字符+和/，在URL中就不能直接作为参数，所以又有一种&quot;url safe&quot;的base64编码，其实就是把字符+和/分别变成-和_ 1base64.urlsafe_b64encode(b'i\xb7\x1d\xfb\xef\xff') 以上内容参考https://www.liaoxuefeng.com/wiki/1016959663602400/1017684507717184]]></content>
  </entry>
  <entry>
    <title><![CDATA[python_argparse]]></title>
    <url>%2FMeBlog%2F2019%2F05%2F02%2Fpython_argparse%2F</url>
    <content type="text"><![CDATA[argparse由来​ 原文： The argparse module is a command line parsing library which provides more functionality than the existing command line parsing modules in the standard library, getopt [2] and optparse [3]. It includes support for positional arguments (not just options), subcommands, required options, options syntaxes like “/f” and “+rgb”, zero-or-more and one-or-more style arguments, and many other features the other two lack. The argparse module is also already a popular third-party replacement for these modules. It is used in projects like IPython (the Scipy Python shell) [4], is included in Debian testing and unstable [5], and since 2007 has had various requests for its inclusion in the standard library [6] [7] [8]. This popularity suggests it may be a valuable addition to the Python libraries. 个人理解： argparse 是一个命令行分析库，它比标准库中的getopt optparse要强大。argparse属于目前流行的第三方命令分析库。 命令解析模块必知的一些基础概念位置参数如 ls /home/XXX 其中的 ‘/home/XXX’就称之为位置参数 可选参数如 ls -l 其中的 ‘-l’ 就称之为可选参数 帮助文档如 ls --help 入门dome1 1234import argparseparse = argparse.ArgumentParser()parse.parse_args() 用来创建一个基础的命令程序 123456import argparseparse = argparse.ArgumentParser()parse.add_argument('echo',help='回显你输入的字符串')args = parse.parse_args()print(args.echo) 当用户使用命令行python 文件名 –help 会查看到 positional arguments: echo 回显你输入的字符串 positional arguments: what is positional arguments? 通常它代表命令中的坐标信息，并且它一个必选项参数。 下面的dome演示如何构建及其调用 123456789import argparseparse = argparse.ArgumentParser()parse.add_argument('echo',help='回显你输入的字符串')parse.add_argument('square',help='计算输入数的平方',type=int)args = parse.parse_args()print(args.echo)print(args.square**2) 当用户使用命令行python 文件名 –help 会查看到 positional arguments: echo 回显你输入的字符串 square 计算输入数的平方 optional arguments: -h, –help show this help message and exit optional arguments what is optional arguments? 它可以代表命令中的一些附件信息，如下面的2个dome一个是表示选择只有一个参数，一个表示选项可以有多个参数 多参数 123456789import argparseparse = argparse.ArgumentParser()parse.add_argument('--verbosity',help="increase output verbosity")args = parse.parse_args()if args.verbosity: print('verbosity turned on') 1234567891011121314151617spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py --versionusage: argparse_study.py [-h] [--verbosity VERBOSITY]spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py -husage: argparse_study.py [-h] [--verbosity VERBOSITY]optional arguments: -h, --help show this help message and exit --verbosity VERBOSITY increase output verbosityspiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py -verbosity 1usage: argparse_study.py [-h] [--verbosity VERBOSITY]argparse_study.py: error: unrecognized arguments: -verbosity 1spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py --verbosity 1verbosity turned onspiderbao@spiderbao-CW65S:~/python/study/code$ 单参数 123456789import argparseparse = argparse.ArgumentParser()parse.add_argument('--verbosity',help="increase output verbosity",action='store_true')args = parse.parse_args()if args.verbosity: print('verbosity turned on') 123456789101112spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py --verbosityverbosity turned onspiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py --verbosity 1usage: argparse_study.py [-h] [--verbosity]argparse_study.py: error: unrecognized arguments: 1spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py -husage: argparse_study.py [-h] [--verbosity]optional arguments: -h, --help show this help message and exit --verbosity increase output verbosityspiderbao@spiderbao-CW65S:~/python/study/code$ 短选项 1234567import argparseparse = argparse.ArgumentParser()parse.add_argument('-v','--verbosity',help='increase output verbosity',action='store_true')args = parse.parse_args()if args.verbosity: print('verbosity turned on') 命令行输入 123456spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py -v 1verbosity turned onspiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py -v verbosity turned onspiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py --verbosityverbosity turned on 组合Positional和Optional参数 1234567891011parse = argparse.ArgumentParser()parse.add_argument('-v','--verbosity',help='显示输出详情',action='count',default=1)parse.add_argument('square',help='计算输入数的平方',type=int)args = parse.parse_args()answer = args.square**2if args.verbosity&gt;=1: print('%s^2=%s' %(args.square,answer))if args.verbosity&gt;=2: print('runing %s'%__file__)if args.verbosity&lt;1: print(answer) 命令行输入显示 1234567891011121314151617181920212223242526spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py -h usage: argparse_study.py [-h] [-v] squarepositional arguments: square 计算输入数的平方optional arguments: -h, --help show this help message and exit -v, --verbosity 显示输出详情spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py -husage: argparse_study.py [-h] [-v] squarepositional arguments: square 计算输入数的平方optional arguments: -h, --help show this help message and exit -v, --verbosity 显示输出详情spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py 44^2=16spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py 4 -v4^2=16runing argparse_study.pyspiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py 4 -vv4^2=16runing argparse_study.py 选参互斥异常 12345678910111213141516parse = argparse.ArgumentParser(description='calculate X to the power of Y')group = parse.add_mutually_exclusive_group();group.add_argument("-v", "--verbose", action="store_true")group.add_argument("-q", "--quiet", action="store_true")#group 添加互斥项，相当于usage: argparse_study.py [-h] [-v | -q] x y 中的[-v | -q] 只能选取一个parse.add_argument("x", type=int, help="the base")parse.add_argument("y", type=int, help="the exponent")args = parse.parse_args()answer = args.x**args.yif args.quiet: print(answer)elif args.verbose: print("&#123;&#125; to the power &#123;&#125; equals &#123;&#125;".format(args.x, args.y, answer))else: print("&#123;&#125;^&#123;&#125; == &#123;&#125;".format(args.x, args.y, answer)) 命令行输入显示 12345678910111213141516171819202122spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py -husage: argparse_study.py [-h] [-v | -q] x ycalculate X to the power of Ypositional arguments: x the base y the exponentoptional arguments: -h, --help show this help message and exit -v, --verbose -q, --quietspiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py 4 24^2 == 16spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py 4 2 -v4 to the power 2 equals 16spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py 4 2 -q16spiderbao@spiderbao-CW65S:~/python/study/code$ python3 argparse_study.py 4 2 -vqusage: argparse_study.py [-h] [-v | -q] x yargparse_study.py: error: argument -q/--quiet: not allowed with argument -v/--verbose 以上内容参考https://docs.python.org/3/howto/argparse.html?highlight=argparse]]></content>
  </entry>
  <entry>
    <title><![CDATA[web认证机制]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2Fweb_%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[HTTP Basic Auth​ HTTP Basic Auth简单点说明就是每次请求API时都提供用户的username和password，简言之，Basic Auth是配合RESTful API 使用的最简单的认证方式，只需提供用户名密码即可，但由于有把用户名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的RESTful API时，尽量避免采用HTTP Basic Auth 个人观点：简单易于实现，安全性低 Cookie Auth​ Cookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time使cookie在一定时间内有效 个人观点：可以使应用认证有状态性，要想保证认证的有状态性使得服务器的session频繁创建，会对服务器的开销增加压力。安全性：一般 OAuth​ OAuth（开放授权）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一web服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。 OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的第三方系统（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容这种基于OAuth的认证机制适用于个人消者类的互联网产品，如社交类APP等应用，但是不太适合拥有自有认证权限管理的企业应用。 个人观点：安全性高。OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容这种基于OAuth的认证机制适用于个人消者类的互联网产品，如社交类APP等应用，但是不太适合拥有自有认证权限管理的企业应用。 Token Auth使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的： 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据 Token Auth的优点 ​ 支持跨域访问: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输. 无状态(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息. 更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可. 去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可. 更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。 CSRF:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。性能: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算 的Token验证和解析要费时得多. 不需要为登录页面做特殊处理: 如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理. 基于标准化:你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby,Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）.]]></content>
  </entry>
  <entry>
    <title><![CDATA[系统安全案例及设计理念]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2F%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[RBAC模型什么是RBACRBAC（全称：Role-Based Access Control）基于角色的权限访问控制，作为传统访问控制（自主访问，强制访问）的有前景的代替受到广泛的关注。在RBAC中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。在一个组织中，角色是为了完成各种工作而创造，用户则依据它的责任和资格来被指派相应的角色，用户可以很容易地从一个角色被指派到另一个角色。角色可依新的需求和系统的合并而赋予新的权限，而权限也可根据需要而从某角色中回收。角色与角色的关系可以建立起来以囊括更广泛的客观情况。访问控制是针对越权使用资源的防御措施，目的是为了限制访问主体（如用户等） 对访问客体（如数据库资源等）的访问权限。企业环境中的访问控制策略大部分都采用基于角色的访问控制（RBAC）模型，是目前公认的解决大型企业的统一资源访问控制的有效方法 基于RBAC实现的设计思路基于角色的访问控制基本原理是在用户和访问权限之间加入角色这一层，实现用户和权限的分离，用户只有通过激活角色才能获得访问权限。通过角色对权限分组，大大简化了用户权限分配表，间接地实现了对用户的分组，提高了权限的分配效率。且加入角色层后，访问控制机制更接近真实世界中的职业分配，便于权限管理。 表结构模型图 需求1前端 ​ 动态加载用户的功能模块 后端 ​ 根据用户权限使用API 基于RBAC dome 案例分析并实现后台无状态安全校验实现​ 底层数据 ​ 问题：数据如何存储便于后期的使用与管理。 ​ 方案：使用RBAC管理模型，根据用户、角色、权限三种概念。来实现数据的访问、使用等相关权限的合理分配。 ​ 数据传输 ​ 问题：数据传输依托于互联网，如何保证其安全。 ​ 方案：认证+校验 ​ 认证 ：依托web认证机制中的方案可实现 ​ 校验 ： ​ 实现逻辑 在请求到达controller 时拦截并校验。 ​ 实现方式有：filter intercept aop 他们三者的关系如下图 ​ ​ 本次案例使用的的过滤方式为，filter 过滤一些不存在token的请求，由intercept拦截校验接下来的数据信息。 后台有状态安全校验实现]]></content>
  </entry>
  <entry>
    <title><![CDATA[springBoot-MultipartAutoConfiguration]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2FSpringBoot-MultipartAutoConfiguration%2F</url>
    <content type="text"><![CDATA[前提：​ 今天本人想实现一个文件上传的功能。 ​ 文件上传的难点在以什么样的传输格式上传文件。 ​ 一般 表单 提交 所 形成 的 请求 结果是 很 简单 的， 就是 以“&amp;” 符 分割 的 多个 name- value 对。 例如 1firstName= Charles&amp; lastName= Xavier&amp; email= professorx% 40xmen. org &amp;username= professorx&amp; password= letmein01 尽管 这种 编码 形式 很 简单， 并且 对于 典型的 基于 文本 的 表单 提交 也 足够 满足要求， 但是 对于 传送 二进制 数据， 如上 传 图片等文件， 就 显得 力不从心 了。 ​ 那么对应二进制数据的上传依托Http请求要怎么去实现呢？ ​ multipart 格式 的 数据 会 将 一个 表单 拆分 为多 个 部分（ part）， 每个 部分 对应 一个 输入 域。 在 一般 的 表单 输入 域 中， 它 所 对应 的 部分 中会 放置 文本 型 数据， 但是 如果 上传 文件 的 话， 它 所 对应 的 部分 可以 是 二进制， 下面 展现 了 multipart 的 请求 体： 123456------WebKitFormBoundaryqgkaBn8IHJCuNmiW Content- Disposition: form- data; name=&quot; firstName&quot; Charles ------WebKitFormBoundaryqgkaBn8IHJCuNmiW Content- Disposition: form- data; name=&quot; lastName&quot; Xavier ------WebKitFormBoundaryqgkaBn8IHJCuNmiW Content- Disposition: form- data; name=&quot; email&quot; charles@ xmen. com ------WebKitFormBoundaryqgkaBn8IHJCuNmiW Content- Disposition: form- data; name=&quot; username&quot; professorx ------WebKitFormBoundaryqgkaBn8IHJCuNmiW Content- Disposition: form- data; name=&quot; password&quot; letmein01 ------WebKitFormBoundaryqgkaBn8IHJCuNmiW Content- Disposition: form- data; name=&quot; profilePicture&quot;; filename=&quot; me. jpg&quot; Content- Type: image/ jpeg [[ Binary image data goes here ]] ------WebKitFormBoundaryqgkaBn8IHJCuNmiW-- 在 这个 multipart 的 请求 中， 我们 可以 看到 profilePicture 部分 与其 他 部分 明显 不同。 除了 其他 内容 以外， 它 还有 自己的 Content- Type 头， 表明 它是 一个 JPEG 图片。 尽管 不一定 那么 明显， 但 profilePicture 部分 的 请求 体 是 二进制 数据， 而 不是 简单 的 文本。 尽管 multipart 请求 看起来 很复杂， 但通过 Spring MVC 处理 它们 却 很容易。 在 编写 控制器 方法 处理 文件 上传 之前， 我们 必须 要 配置 一个 multipart 解析 器， 通过 它来 告诉 DispatcherServlet 该 如何 读取 multipart 请求。 ​ spring mvc 对multipart 解析器定义了 multipart Resolver 接口规范。 并提供了CommonsMultipartResolver： 使用 Jakarta Commons FileUpload 解析 multipart 请求的实现和StandardServletMultipartResolver： 依赖于 Servlet 3. 0 对 multipart 请求 的 支持（ 始于 Spring 3. 1）。 使用springboot 如何操作multipart Resolver 接下来请看MultipartAutoConfiguration装配类都做了什么 MultipartAutoConfiguration]]></content>
  </entry>
  <entry>
    <title><![CDATA[modelAttribute注解]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2FmodelAttribute%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[@modelAttributemoelAttribute 是springmvc提供的注解。 1.运用在参数上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用； 2.运用在方法上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中； 运用在方法上实现案例，抽取request 和response、modelMap将其注入在baseController中。beseController12345678910111213141516171819import lombok.Data;import org.springframework.web.bind.annotation.ModelAttribute;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@Datapublic class BaseController &#123; protected HttpServletRequest request; protected HttpServletResponse response; @ModelAttribute public void initParams(HttpServletResponse response,HttpServletRequest request)&#123; this.request = request; this.response = response; &#125;&#125; 基础controller 1234567891011121314151617181920import com.healthengine.medpro.common.controller.BaseController;import org.springframework.web.bind.annotation.CrossOrigin;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping("/file")@CrossOriginpublic class FileBaseController extends BaseController &#123; @GetMapping("/modelAttributeTest") public String modelAttributeTest()&#123; request.getAuthType(); response.getStatus(); return "OK"; &#125;&#125; 注意：其中的response是多例线程不安全的，如果想要时其线程安全可以使用ThreadLocal]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 参数校验]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2Fspringboot_param_validation%2F</url>
    <content type="text"><![CDATA[解决方案​JSR-303 实现方案+JSR-349Bean 验证 JSR-303的实现使用hibernate的实现 @Valid注解 JSR-349Bean 验证的实现使用spring提供的@Validated注解 校验案例本案例的环境为，springboot2.0.5.RELEASE 基础代码实现： 导入坐标 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 此坐标包含了@Valid 和@Validated 创建入口启动类 1234567891011121314151617181920212223242526package com.healthengine.department;import com.healthengine.medpro.common.utils.IdWorker;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.domain.EntityScan;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;@SpringBootApplication()@ComponentScan("com.healthengine.department")@EntityScan("com.healthengine.medpro.department")@EnableJpaRepositories(basePackages = "com.healthengine.department.dao")public class DepartmentApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(DepartmentApplication.class,args); &#125; //雪花算法用来生成id @Bean public IdWorker idWorker()&#123; return new IdWorker(1,1); &#125;&#125; 注意：此入口启动类要放在Controller包的同级目录下，因为@SpringBootApplication注解会扫描同级目录及其子目录。此类只放在java目录下是不对的。要放在Java目录下的下级目录下 （正确目录格式） (错误目录格式) 配置文件设置 1234567891011121314server: port: 9002spring: application: name: medpro-department datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/medprotwo username: xxxx password: xxxx jpa: database: mysql show-sql: true open-in-view: true 创建controller 案例使用到的java Bean 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.healthengine.medpro.company;import com.healthengine.medpro.department.Department;import lombok.Data;import javax.persistence.Entity;import javax.persistence.Id;import javax.persistence.Table;import javax.validation.Valid;import javax.validation.constraints.NotBlank;import javax.validation.constraints.NotEmpty;import java.io.Serializable;import java.util.Date;import java.util.List;@Entity@Table(name="co_company")@Datapublic class Company implements Serializable &#123; private static final long serialVersionUID = 594829320797158219L; @Id private String id; @NotBlank(message = "用户名不能为空！",groups = &#123;AddDepartment.class&#125;) private String name; private String managerId; @NotBlank(message = "版本号不能为空",groups = &#123;AddDepartment.class&#125;) private String version; private Date renewalDate; private Date expirationDate; private String companyArea; private String companyAddress; private String businessLicenseId; private String legalRepresentative; private String companyPhone; private String mailbox; private String companySize; private String industry; private String remarks; private String auditState; private Integer state; private Double balance; private Date createTime; /** * 部门列表 */ @Valid //开启嵌套校验 @NotEmpty(groups = &#123;AddDepartment.class&#125;,message = "部门列表不能为空！") private List&lt;Department&gt; departmentList;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.healthengine.medpro.department;import lombok.Data;import javax.persistence.Entity;import javax.persistence.Id;import javax.persistence.Table;import javax.validation.constraints.NotBlank;import java.util.Date;@Entity@Table(name = "co_department")@Datapublic class Department &#123; /** * id */ @Id @NotBlank(message = "id不能为空") private String id; /** * 父id */ private String pid; /** * 企业id */ private String companyId; /** * 部门名称 */ private String name; /** * 部门编码，同级部门不可重复 */ private String code; /** * 负责人id */ private String managerId; /** * 负责人名称 */ private String manager; /** * 介绍 */ private String introduce; /** * 创建时间 */ private Date create;&#125; 1234package com.healthengine.medpro.company;public interface AddDepartment &#123;&#125; 基础校验（快速尝鲜）12345//对象参数校验@PostMapping("/test1")public Result test1(@Validated @RequestBody Company company)&#123; return new Result(ResultCode.SUCCESS);&#125; 单个参数校验 在类中加入@Validated 1234@RestController()@RequestMapping("/validation")@Validatedpublic class ValidationTest &#123; 方法上对参数使用校验注解 1234@GetMapping("/test2")public Result test2(@NotNull(message = "年齡不能為空") Integer age)&#123; return new Result(ResultCode.SUCCESS);&#125; 分组校验 创建分组标识接口 12public interface AddDepartment &#123;&#125; 在要校验的字段上使用校验注解并添加groups属性 12@NotBlank(message = "用户名不能为空！",groups = &#123;AddDepartment.class&#125;)private String name; 在方法上使用校验 1234@PostMapping("/test3")public Result test3(@Validated(AddDepartment.class) @RequestBody Company company)&#123; return new Result(ResultCode.SUCCESS);&#125; 嵌套属性校验 在要需要嵌套校验的对象上添加@valid 123456/** * 部门列表 */@Valid //开启嵌套校验@NotEmpty(groups = &#123;AddDepartment.class&#125;,message = "部门列表不能为空！")private List&lt;Department&gt; departmentList; 在方法上使用 1234@PostMapping("/test4")public Result test4(@Valid @Validated(AddDepartment.class) @RequestBody Company company)&#123; return new Result(ResultCode.SUCCESS);&#125; 非嵌套属性校验 1234@PostMapping("/test4")public Result test4(@Validated(AddDepartment.class) @RequestBody Company company)&#123; return new Result(ResultCode.SUCCESS);&#125; 自定义校验规则校验异常类全局处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.healthengine.department.exception;import com.healthengine.medpro.common.entity.Result;import org.springframework.http.converter.HttpMessageConversionException;import org.springframework.validation.BindingResult;import org.springframework.validation.FieldError;import org.springframework.validation.ObjectError;import org.springframework.web.bind.MethodArgumentNotValidException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestControllerAdvice;import javax.validation.ConstraintViolation;import javax.validation.ConstraintViolationException;import java.util.List;@RestControllerAdvicepublic class GlobalExceptionHandler &#123; /** * 单个参数异常抛出 */ @ExceptionHandler(ConstraintViolationException.class) public Result constraintViolationException(ConstraintViolationException ce)&#123; StringBuilder sb = new StringBuilder(); for(ConstraintViolation violation:ce.getConstraintViolations())&#123; sb.append("异常信息： "+violation.getMessage()); &#125; return new Result(500,sb.toString(),false); &#125; /** * 实体类异常抛出 * @param exception * @return */ @ExceptionHandler(MethodArgumentNotValidException.class) public Result validationBodyException(MethodArgumentNotValidException exception)&#123; StringBuilder sb = new StringBuilder(); BindingResult result = exception.getBindingResult(); if (result.hasErrors()) &#123; List&lt;ObjectError&gt; errors = result.getAllErrors(); errors.forEach(p -&gt;&#123; FieldError fieldError = (FieldError) p; sb.append("异常字段："+fieldError.getField()+" 异常信息："+fieldError.getDefaultMessage()).append(System.lineSeparator()); &#125;); &#125; return new Result(500,sb.toString(),false); &#125; /** * 参数类型转换错误 * * @param exception 错误 * @return 错误信息 */ @ExceptionHandler(HttpMessageConversionException.class) public Result parameterTypeException(HttpMessageConversionException exception)&#123; return new Result(500,exception.getCause().getLocalizedMessage(),false); &#125;&#125; 案例后发现的缺陷 使用hibernate参数校验注解后发现，使用Spring jpa 存入数据时也会产生校验。 目前解决方案，使用注解时为其分组。这样可以解决存入数据库时的校验，当存入数据库前，想做校验需要自己手动编写逻辑。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux-用户用户组篇]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2FLinux-%E7%94%A8%E6%88%B7%E7%94%A8%E6%88%B7%E7%BB%84%E7%AF%87%2F</url>
    <content type="text"><![CDATA[用户和用户组管理如何去做用户管理 越是对服务器安全性要求高的服务器，越需要建立合理的用户权限等级制度和服务器操作规范。 在Linux中主要是通过用户配置文件来查看和修改用户信息。 用户配置文件用户信息文件/etc/passwd这个 文件 中 保存 的 就是 系统 中 所有 的 用户 和 用户 的 主要 信息。 文档解读： ​ 文件中一行代表一个用户，每行分为7个字段，下面解释下这7个字段分别附有什么含有 ​ 1.用户名称 ​ 2.密码标识 ，具体密码信息需要进入/etc/shadow查看，并且密码采用SHA512散列加密算法. ​ 3.uid 用户的id标识 0表示超级用户，而且前499已经被系统占用 ​ 4.gid 表示用户组id标识 这里指的是用户的初始组 ​ 5.用户说明信息 ​ 6.用户的home 目录 ​ 7.用户登陆后所能执行的shell脚本 影子文件/etc/shadow​ 文件中存储了关于用户的密码的一些信息 ​ 同样每行表示每个用户的密码信息，每行分为6个字段 ​ 1.用户名称 ​ 2.密码 经过加密后的，被锁定的密码前会加入！！ ​ 3.密码最后一次修改日期 ​ 4.密码的两次修改时间间隔（和3做比较） ​ 5.密码的有效期（和3做比较） ​ 6.密码修改到期前的警告天数（和5做比较） 组织信息文件/etc/group和组密码文件/etc/gshadow​ /etc/group 存储了信息用户组的信息 ​ /etc/gshadow 存储了用户组管理员以及密码的一些信息 ​ 具体详情 可查阅 man 5 gshadow 用户管理相关的文件​ 1.用户的家目录 ​ /home/用户名称 或/root/ ​ 2.用户邮箱目录 ​ /var/spool/mail/用户名称 ​ 3.用户模板目录 ​ /etc/skel 用户管理命令​ 添加用户 useradd [选项] 用户名 ​ 指定修改用户密码 passwd [选项] 用户名 ​ 修改用户信息 usermod [选项] 用户名 ​ 删除用户 userdel [选项] 用户名 ​ 切换用户 su [选项] 用户名 ​ “-” 切换后使用切换用户的环境 ​ “-c” 仅执行一次命令 用户组管理命令​ 添加用户组 groupadd [选项] 组名 ​ 修改用户组 groupmod [选项] 组名 ​ 删除用户组 groupdel [选项] 组名 ​ 把用户加入组中 gpasswd 选项 组名 ​ “-a” 用户名 把用户加入组 ​ “-d”用户名 把用户从组中删除]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux-软件管理篇]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2FLinux-%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E7%AF%87%2F</url>
    <content type="text"><![CDATA[软件包管理简介 总结：Linux 软件安装包分为 ​ 源码包安装 ​ 优点：可控性高，可以自己查看或修改程序的源代码。安装后软件的执行效率高，比厂商提供的二进制包高5% ​ 缺点：需要自己手动编译源码后才可安装，操作难度高。 ​ 二进制包安装 ​ 优点：安装速度块，由于使用的是厂商编译过的二进制包，所有省去了自己对源码的手动编译。直接安装即可。 ​ 缺点：不可以直接查看程序的源代码。安装后软件的执行效率比自己手动编译的的软件包慢5%。并且安装软件存在依赖性问题 ​ 脚本包安装 ​ 优点：脚本包安装类似与Windows下的软件安装界面。它是源码包安装和二进制包安装的中和方式。运行脚本后，脚本会帮助你去编译软件的源代码并安装。 ​ 缺点：单独编写软件脚本 RPM 包管理（二进制包）rpm的命名规则 包名或包全名例子 ​ httpd-2.2.15-15.el6.centos.1.i686.rpm ​ 包名 : httpd ​ 包全名 : httpd-2.2.15-15.el6.centos.1.i686.rpm rpm的依赖性 总结： ​ rpm包的命名规则： ​ 软件包名-软件版本-软件的发布次数.适合的Linux平台.适合的硬件平台.rpm包扩展名 ​ rpm依赖性： ​ 树形依赖 ：如安装软件包a时发现需要安装软件包b,而安装软件包b又需要软件包c. 解决上述的树形依赖问题的方法：先安装软件包c然后依次安装软件包b,软件包a ​ 环形依赖：如安装软件包a时发现需要安装软件包b,而安装软件包b需要安装软件包c,但是安装软件包c却需要软件包a,这样就形成了环形的依赖结构。 环形依赖解决方案：同时安装包a,b,c即可解决此问题。 ​ 模块依赖：模块依赖和软件包依赖不同之处在于，模块所依赖的包，有可能不在系统安装包内。 解决方案：进入 www.rpmfind.net 搜索需要的模块包 包全名和包名的使用介绍 rpm安装升级卸载 总结： 什么时候使用包全名或包名 包全名，在软件没有安装并需要使用的情况下。如软件的安装或更新 包名，在软件已经被安装的情况下。如软件的卸载 rpm实现包安装 在进入安装包目录的情况下 1rpm -ivh 需要安装的包全名（need install package name） rpm实现包升级 在进入安装包目录的情况下 1rpm -Uvh 需要更新的包全名（need update package name） rpm实现包卸载 1rpm -e 需要卸载的包名 （need deleter package name） rpm查询查询是否安装 安装包的详细信息查询 RPM的安装位置查询 根据文件名查询rpm包 查询安装包的依赖性 总结： rpm查询 查询是否安装 1rpm -q 包名 （package name） 系统已经安装的所有安装包 1rpm -qa 安装包的详细信息查询 1rpm -qi 包名 （package name） RPM的安装位置查询 1rpm -ql 包名 （package name） 获取给定文件名属于哪个RPM 1rpm -qf 文件名 （file name） 查询RPM的依赖性 1rpm -qR 包名（package name） rpm包校验 rpm包提取 总结： rpm 包校验 rpm 包提取 /usr/bin/ls 文件提取 1rpm2cpio /mnt/cdrom/Packages/coreutils-8.22-23.el7.x86_64.rpm | cpio -idv ./usr/bin/ls yum在线管理-IP地址配置使用 red heat 的setup命令 本人使用的是contos7，发现使用setup后没有网络配置项，在网上查他们说需要使用yum去安装setup的一些功能项。（未做测试） 那我是怎么配置使自己的系统可以访问外网的呢？我直接修改改network 的配置文件（/etc/sysconfig/network-scripts/ifcfg-ens33）文件，将ONBOOT 设为 true，然后就可以上网了。 网络yum源本人安装的contos已经默认安装并配置了yum源，下面是有关yum源的一些配置属性的解释 使用镜像（mirror） 下载镜像repo配置文件 http://mirrors.aliyun.com/repo/Centos-7.repo 将原repo文件备份为 repo.backup 将下载好的Centos-7.repo 移动到/etc/yum.repos.d/下并改名为CentOS-Base.repo 总结： ​ 1.系统上网配置，使用setup 下的网络配置，配置ip 子网掩码 网关 CSDN 保存即可，设置后记得修改network 的网络配置文件，将ONBOOT 设为true， 之后service network restart 重启即可，然后使用ping命令测试系统是否联网 ​ 2.yum 配置使用contos默认即可 ​ 3.yum mirror设置，上述配置即可 yum命令查询 安装 ​ 注意 当更新时，没有指定包名，yum会更新整个系统中所有软件甚至内核也会被升级。 卸载 yum软件组使用 总结： ​ 系统安装原则：最小化安装，用需要用什么软件，就安装什么软件。最好不要卸载软件。更新软件时要注意指定软件名，不然就会更新整个系统（包括内核）。安装时-y 命令要在安装熟练时使用，一般慎用 yum光盘源搭建 源码包安装管理源码包和rpm包的区别​ 安装之前的区别：概念上的区别 ​ 安装之后的区别：安装位置不同 ​ 由于源码包和rpm 安装包的安装位置不同导致了，应用的启动方式选择面不同 ​ rpm 包安装的软件可以 使用 service 去执行命令，也可以使用 绝对路径 + 命令的方法操作 ​ 源码包 只能通过 绝对路径 + 命令的方法操作 ​ service 操作软件 1service tomcat start ​ 绝对路径+命令方式 1/usr/bin/tomcat start 源码包安装过程 源码包安装流程 下载源码包文件 解压源码包文件到 /usr/local/ 源码文件名 下 进入解压目录阅读 INSTALL 文档，查看如何安装。 使用make 命令编译源码 使用make install 命令安装 INSTALL安装说明文档 README使用说明 make 编译 make install 编译安装 make clean 清空编译 ###脚本安装包]]></content>
  </entry>
  <entry>
    <title><![CDATA[jodconverter]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2Fjodconverter%2F</url>
    <content type="text"><![CDATA[jodconverter入门​ 概念： ​ jodconverter的全称是 java Document Converter ,它可以在不同的办公室格式之间转换文档。它利用了Apache OpenOffice或LibreOffice， ​ JODConverter自动执行OpenOffice / LibreOffice支持的所有转换。支持的转化包括： 文件类型 输入格式 输出格式 文本 DOC，DOCX，ODT，OTT，RTF，TEXT DOC，DOCX，HTML，ODT，OTT，PDF，PNG，RTF，TXT 电子表格 CSV，ODS，OTS，TSV，XLS，XLSX CSV，HTML，ODS，OTS，PDF，PNG，TSV，XLS，XLSX 介绍 ODP，OTP，PPT，PPTX HTML，ODP，OTP，PDF，PNG，PPT，PPTX，SWF 画画 ODG，OTG ODG，OTG，PDF，PNG，SWF 其他 HTML DOC，DOCX，HTML，ODT，OTT，PDF，PNG，RTF，TXT 系统要求要使用JODConverter，您需要： Java运行时环境1.7或更高版本。 Apache OpenOffice或LibreOffice ; 通常建议使用最新的稳定版本。 任何可用于Java和Apache OpenOffice / LibreOffice的操作系统（Windows，Linux，Mac OS X，Solaris，FreeBSD等）。请参阅您计划用于操作系统要求的OOo分发的系统要求。 Apache OpenOffice 系统要求。 LibreOffice 系统要求。 要用作Web应用程序/ Web服务，您还需要一个servlet容器，例如Apache Tomcat。 组件（配置）officeHome此属性设置将用于执行文档转换的办公室安装的office主目录。 processManager当JODConverter需要处理已启动的办公流程时，将使用流程管理器。当JODConverter启动办公室进程时，它必须检索已启动进程的PID，以便以后能够在需要时终止它。 默认值：默认情况下，JODConverter将根据运行JODConverter的操作系统尝试查找最佳进程管理器。但是，如果在类路径中找到，则可以使用任何实现ProcessManager接口的进程管理器。 只有在启用了processManager后才可以使用jodconverter进行文件转换 其余属性请查看此链接https://github.com/sbraconnier/jodconverter/wiki/Configuration 官方Java中使用dome12345678910111213141516171819202122File inputFile = new File("document.doc");File outputFile = new File("document.pdf");// Create an office manager using the default configuration.// The default port is 2002. Note that when an office manager// is installed, it will be the one used by default when// a converter is created.final LocalOfficeManager officeManager = LocalOfficeManager.install(); try &#123; // Start an office process and connect to the started instance (on port 2002). officeManager.start(); // Convert JodConverter .convert(inputFile) .to(outputFile) .execute();&#125; finally &#123; // Stop the office process OfficeUtils.stopQuietly(officeManager);&#125; 本人整合springboot使用]]></content>
  </entry>
  <entry>
    <title><![CDATA[Gradle Wrapper]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2Fgradle-wrapper%2F</url>
    <content type="text"><![CDATA[关于Gradle Wrapper推荐的方式执行任何Gradle构建的帮助下Gradle包装器(总之只是“包装器”)。包装是一个脚本,该脚本调用它宣布版本,必要时预先下载它。因此,开发人员可以用Gradle项目迅速而不必遵循手动安装过程节省贵公司的时间和金钱 你将获得以下好处： 同一版本 减低了版本统一的维护成本，只需在wrapper 文件下声明处修改版本就可以 123task wrapper(type: Wrapper) &#123; gradleVersion = &apos;1.11&apos; //修改此处版本&#125; 使用wrapper 的3中情况创建一个新的项目并加入wrapper 在自己指定的工作空间目录下运行如下命令 1gradle wrapper 创建指令 –gradle-version ：用于指定gradle 的版本 –distribution-type ：用于指定gradle的类型 bin 或 all –gradle-distribution-url : 用于指导gradle的下载路径 –gradle-distribution-sha256-sum ：用于指定编码格式 案例：创建gradle 版本为5.1.1的all类型 1gradle wrapper --gradle-version 5.1.1 --distribution-type all 创建后的目录结构图 123456├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradlew└── gradlew.bat gradle-wrapper.jar wrapper的源文件 gradle-wrapper.properties wrapper的版本等配置属性 gradlew shell脚本工具 gradlew.bat windows 批处理工具 运行已经加入wrapper的项目 在项目目录下运行下列代码 1gradlew.bat build 在已有wrapper的gradle项目中更新gradle的版本为最新。使用前面的命令可进行更新 1gradle wrapper --gradle-version 5.1.1]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux-初识]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2FLinux-%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Linux简介Linux 学习方法 坚持使用命令行 遇到问题，不要马上问别人。先自行寻找答案 解决问题的的智慧： 帮助、文档、示例、查找 忘掉Windows思维方式 计划、坚持、专注、练习 Linux系统分区1.什么是磁盘分区： ​ 磁盘分区是使用分区编辑器（partition editor）在磁盘上划分几个逻辑部分，碟片一但划分成数个分区（partition）不同类的目录与文件可以存储进不同的分区。 example： 划分柜子，将一个大柜子划分为3个小柜子。这样可以方便使用者。 分区类型： 主分区：最多只能有4个（一块硬盘的前提条件下） 扩展分区： ​ 最多只能有1个（一块硬盘的前提条件下） ​ 主分区加扩展分区最多有4个（一块硬盘的前提条件下） ​ 不能写入数据，只能包含逻辑分区（一块硬盘的前提条件下） 逻辑分区 2.格式化 ​ 什么是格式化： ​ 格式化 （高级格式化）又称逻辑格式化。它是指根据用户选的的文件系统（FAT16、FAT32、NTFS、EXT3、EXT2、EXT4等）在磁盘的特定区域写入特定数据，在分区中划出一片用于存放文件的分配表、目录表等用于文件管理的磁盘空间。 Linux默认的文件系统：EXT4 关键词： ​ block ​ inode 号 3.硬件设备文件名 4.分区设备文件名 /dev/hda1 代表什么？ /dev 代表了这是系统的设备文件的根目录，hda1中hda表示用户使用的是IDE硬盘，1表示第几个分区（数字标识） IDE硬盘接口： 理论每秒传输133MB SCSI硬盘接口： 理论每秒传输200MB SATA硬盘接口： sata3代理论每秒传输500MB 5.挂载 ​ 必须分区 ​ /(根分区) ​ swap（交换分区、内存2倍） ​ 推荐分区 ​ /boot（启动分区，200MB） 文件系统结构 系统分区流程 ​ 分区 》格式化 》为分区指定设备文件名 》 挂载 密码原则：​ 复杂性 ​ 八位字符以上、大小写字母、数字、符号 ​ 不是单词 ​ 不是用户的相关信息 ​ 易记性 ​ 时效性 安装日志​ /root/install.log 存储了安装在系统中的软件包及其版本信息 ​ /root/install.log.syslog 存储了安装过程中留下来的事件信息 ​ /root/anaconda-ks.cfg 以Kickstrat配置文件的格式记录安装过程中设置的选项信息 linux 关于IP操作的一些命令ifconfig ：查看系统网卡信息 ifconfig eth0 [ip 地址] :临时配置网卡，系统重启后失效 Linux 注意事项​ 严格区分大小写 ​ Linux中所有的内容都是以文件形式保存，包括硬件 ​ 硬盘文件是/dev/sd[a-p] ​ 光盘文件是/dev/sr0等 ​ Linux不靠扩展名区分文件类型 ​ Linux所有存储设备都必须挂载之后用户才能使用,包括硬盘、U盘和光盘 ​ windows下的程序不能直接在Linux中安装和运行 服务器管理和维护建议服务器最好重启操作，不要关机操作 重启时应该关闭服务器 不要在服务器访问高峰运行高负载命令 远程配置防火墙时不要把自己踢出服务器 指定合理的密码规范并定期更新 合理分配权限 定期备份重要数据和日志]]></content>
  </entry>
  <entry>
    <title><![CDATA[jwt]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2Fjwt%2F</url>
    <content type="text"><![CDATA[什么是jwt​ JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。在Java世界中通过JJWT实现JWT创建和验证。 jjwt快速尝鲜 引入坐标 12345&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.6.0&lt;/version&gt;&lt;/dependency&gt; 上面使用的坐标是基于apache2.0 下的jwt实现 使用并测试 生成token 12345678JwtBuilder jwt = Jwts.builder() .setId("123") .setSubject("老王") .setIssuedAt(new Date())//发布时间 .setExpiration(new Date(System.currentTimeMillis()+6000))//到期时间 .signWith(SignatureAlgorithm.HS384,"XXXXX");//设置密钥String compact = jwt.compact();//签约生成tokenSystem.out.println(compact); 解析token 1234Claims cla = Jwts.parser() .setSigningKey("XXXXX")//设置密钥 .parseClaimsJws(key)//设置token .getBody(); 当token认证失败时会抛出ExpiredJwtException异常 自定义claims 生成 1234567891011//为了方便测试，我们将过期时间设置为1分钟long now = System.currentTimeMillis();//当前时间long exp = now + 1000*60;//过期时间为1分钟JwtBuilder builder= Jwts.builder().setId("888").setSubject("小白").setIssuedAt(new Date()).signWith(SignatureAlgorithm.HS256,"itcast").setExpiration(new Date(exp)).claim("roles","admin") //自定义claims存储数据.claim("logo","logo.png");System.out.println( builder.compact() ); 解析 1234567891011121314StringcompactJws="eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODgiLCJzdWIiOiLlsI_nmb0iLCJpYXQiOjE1MjM0MTczMjMsImV4cCI6MTUyMzQxNzM4Mywicm9sZXMiOiJhZG1pbiIsImxvZ28iOiJsb2dvLnBuZyJ9.b11p4g4rE94rqFhcfzdJTPCORikqP_1zJ1MP8KihYTQ";Claims claims =Jwts.parser().setSigningKey("itcast").parseClaimsJws(compactJws).getBody();System.out.println("id:"+claims.getId());System.out.println("subject:"+claims.getSubject());System.out.println("roles:"+claims.get("roles"));System.out.println("logo:"+claims.get("logo"));SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");System.out.println("签发时间:"+sdf.format(claims.getIssuedAt()));System.out.println("过期时间:"+sdf.format(claims.getExpiration()));System.out.println("当前时间:"+sdf.format(new Date()) );]]></content>
  </entry>
  <entry>
    <title><![CDATA[configuartionProperties注解]]></title>
    <url>%2FMeBlog%2F2019%2F04%2F29%2FConfigurationProperties%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[@configuartionProperties作用​ 用于将properties 文件中的属性或yml属性文件中的属性 放入pojo中 使用案例@configuartionProperties + @Component实体类 123456789101112131415161718192021import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@ConfigurationProperties(prefix = "me.user")@Datapublic class User &#123; private String name; private String password; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", password='" + password + '\'' + '&#125;'; &#125;&#125; 测试方法 123456789101112131415161718192021import com.healthengine.medpro.fileSystem.FileSystemApplication;import com.healthengine.medpro.fileSystem.controller.entity.User;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTest(classes = FileSystemApplication.class)public class ConfigurationProperties &#123; @Autowired private User user; @Test public void configuration()&#123; System.out.println(user); &#125;&#125; 配置文件设置 1234me: user: name: baowengliang password: 123456 测试结果 1User&#123;name=&apos;baowengliang&apos;, password=&apos;123456&apos;&#125; @Bean + @ConfigurationProperties实体类 1234567891011121314151617import lombok.Data;@Datapublic class User &#123; private String name; private String password; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", password='" + password + '\'' + '&#125;'; &#125;&#125; 启动类 12345678910111213@SpringBootApplication()public class FileSystemApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(FileSystemApplication.class,args); &#125; @Bean @ConfigurationProperties(prefix = "me.user") public User user()&#123; return new User(); &#125;&#125; 测试方法 123456789101112131415161718192021import com.healthengine.medpro.fileSystem.FileSystemApplication;import com.healthengine.medpro.fileSystem.controller.entity.User;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTest(classes = FileSystemApplication.class)public class ConfigurationProperties &#123; @Autowired private User user; @Test public void configuration()&#123; System.out.println(user); &#125;&#125; 配置文件设置 1234me: user: name: baowengliang password: 123456 测试结果1User&#123;name=&apos;baowengliang&apos;, password=&apos;123456&apos;&#125; @EnableConfigurationProperties + @ConfigurationProperties实体类 12345678910111213141516171819import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;@Data@ConfigurationProperties(prefix = "me.user")public class User &#123; private String name; private String password; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", password='" + password + '\'' + '&#125;'; &#125;&#125; 启动类 123456789@SpringBootApplication()@EnableConfigurationProperties(User.class)public class FileSystemApplication &#123; public static void main(String[] args)&#123; SpringApplication.run(FileSystemApplication.class,args); &#125; &#125; 配置文件 1234me: user: name: baowengliang password: 123456 测试类 123456789101112131415161718192021import com.healthengine.medpro.fileSystem.FileSystemApplication;import com.healthengine.medpro.fileSystem.controller.entity.User;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTest(classes = FileSystemApplication.class)public class ConfigurationProperties &#123; @Autowired private User user; @Test public void configuration()&#123; System.out.println(user); &#125;&#125; 测试结果 1User&#123;name=&apos;baowengliang&apos;, password=&apos;123456&apos;&#125;]]></content>
  </entry>
</search>
